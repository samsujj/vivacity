/****** js combine: 17 total file(s) ******/

/****** js file: dynamic_areas.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/plugins/dynamic_areas/js/dynamic_areas.js ******/
/****** last modified: 1466605105 (2016-06-22 09:18:25) ******/
// JavaScript Document

var dyna_area_elements = [];
var edit_pencil_size = 20;
var fade_duration = 400;
var last_check_for_dyna_elements = 0;
var listener_delay = 1000;
var dyna_areas_on = "off";

$(document).ready(function() {

		// Track mouse move
		$("body").mousemove(function(e) {
			if(typeof current_edit_mode_state !== "undefined" && !current_edit_mode_state)return;//do not draw edit link if edit mode is disables
			listen_for_and_update_dynamic_areas();
			determine_which_dyna_areas_are_hovered(e.pageX,e.pageY);
		});

	// A delay of 100 seems to work realiably, but, wanted a bit of a guarantee.
	var delay_da_init = setTimeout(function() {
		build_dyna_area_elements();
		listen_for_and_update_dynamic_areas();
	}, 150);

	var resizeTimer;

	$(window).resize(function()
		{
			clearTimeout(resizeTimer);//reset the timer each time the function is called
			resizeTimer = setTimeout(function()
				{
					build_dyna_area_elements();
					listen_for_and_update_dynamic_areas();
				},250);//only resize the dynamic areas if it has been 250ms since the last resize
		});
});

function activate_all_dyna_areas() {

	dyna_areas_on = "on";
	for(elem = 0; elem < (dyna_area_elements.length - 1); elem++) {
		$("#dynamic_area_" + dyna_area_elements[elem].id).data('fading', true).css({"opacity":0}).animate({"opacity":1}, {
			duration: fade_duration,
			step: function(now) {
				var dyna = $(this).attr("rel");
				$("#" + dyna).css('outline-color','rgba(255,0,0,'+now+')');
			},
			complete: function(now) {
				$(this).data('fading', false);
				$(this).data('active', true);
			}
		});
	}
}

function deactivate_all_dyna_areas() {
	dyna_areas_on = "off";
	for(elem = 0; elem < (dyna_area_elements.length - 1); elem++) {
		$("#dynamic_area_" + dyna_area_elements[elem].id).data('fading', true).css({"opacity":1}).animate({"opacity":0}, {
			duration: fade_duration,
			step: function(now) {
				var dyna = $(this).attr("rel");
				$("#" + dyna).css('outline-color','rgba(255,0,0,'+now+')');
			},
			complete: function(now) {
				$(this).data('fading', false);
				$(this).data('active', false);
			}
		});
	}
}

function toggle_ai_edit() {
	if(dyna_areas_on == "on") {
		deactivate_all_dyna_areas();
	} else {
		activate_all_dyna_areas();
	}
}

function build_dyna_area_elements() {
	$("div.dynamic_area_content").each(function() {

		var dyna_area_id = $(this).attr("id");
		var dyna_area_position = $(this).offset();
		var dyna_area_width = $(this).width();
		var dyna_area_height = $(this).height();

		var data = {};
		data.id = dyna_area_id;
		data.top = dyna_area_position.top;
		data.left = dyna_area_position.left;
		data.bottom = dyna_area_position.top + dyna_area_height;
		data.right = dyna_area_position.left + dyna_area_width;

		// Determine the position of the edit pencil, for now, just position where it falls, we will rely on the updater to move it to be visible
		var edit_position_top = dyna_area_position.top;
		var edit_position_left = dyna_area_position.left;

		data.edit_top = edit_position_top;
		data.edit_left = edit_position_left;
		data.edit_bottom = (edit_position_top + edit_pencil_size);
		data.edit_right = (edit_position_left + edit_pencil_size);

		dyna_area_elements.push(data);
	});
}

function enable_all_dynamic_areas() {
	$(".dynamic_area_edit_link").each(function() {
		// This resets all dyanmic areas and then also removes the display: none;
		$(this).removeAttr("disabled").show(0);
	});
}

function enable_dynamic_area(area) {
	$("#" + area).removeAttr("disabled");
}

function disable_dynamic_area(area) {
	$("#" + area).attr("disabled","disabled");
}

function disable_all_dynamic_areas_not_part_of_jonbox() {
	$('div.dynamic_area_content:not(#jonbox_content .dynamic_area_content)').each(function() {
		disable_dynamic_area('dynamic_area_' + $(this).attr("id"));
	});
}

function update_dynamic_areas_NOW() {
	last_check_for_dyna_elements = 0;
	listen_for_and_update_dynamic_areas();
}

function listen_for_and_update_dynamic_areas() {
	
	var current_timestamp = new Date().getTime();
	if(last_check_for_dyna_elements <= (current_timestamp - listener_delay)) {
		var new_dyna_area_elements = [];
		
		// Check all active dynamic areas, build into array
		$('div.dynamic_area_content:not(#jonbox_content .dynamic_area_content)').each(function() {
			add_update_dyna_element(new_dyna_area_elements,this);
		});

		$('#jonbox_content .dynamic_area_content').each(function() {
			add_update_dyna_element(new_dyna_area_elements,this);
		});

		// Set the old obj to the newly built  one
		dyna_area_elements = [];
		dyna_area_elements = new_dyna_area_elements;

		last_check_for_dyna_elements = new Date().getTime();
	}
}

function add_update_dyna_element(new_dyna_area_elements,dyna) {

	var dyna_area_id = $(dyna).attr("id");
	var dyna_area_position = $(dyna).offset();
	var dyna_area_width = $(dyna).width();
	var dyna_area_height = $(dyna).height();

	// Check to see if this dynamic area already exists
	var key = dyna_area_id_exists(dyna_area_id);
	if(key > 0) {
		// Check to see if it is moved
		if(
			// Top
			dyna_area_position.top != dyna_area_elements[key].top
			// Left
			|| dyna_area_position.left != dyna_area_elements[key].left
			// Bottom
			|| (dyna_area_position.top + dyna_area_height) != dyna_area_elements[key].bottom
			// Right
			|| (dyna_area_position.left + dyna_area_width) != dyna_area_elements[key].right
		) {
			$("#dynamic_area_" + dyna_area_id).css({
				"top":dyna_area_position.top + "px",
				"left":dyna_area_position.left + "px"
			});
		}
	}

	// Check and see if the actual image for this dyna area exists
	if($("#dynamic_area_" + dyna_area_id).attr("id") != "dynamic_area_" + dyna_area_id) {
		var appended_div = $("<img />", {src: "images/dynamic_edit.14.png", id: "dynamic_area_" + dyna_area_id, css: {
			"cursor":"pointer",
			"width":edit_pencil_size + "px",
			"height":edit_pencil_size + "px",
			"min-width":edit_pencil_size + "px",
			"min-height":edit_pencil_size + "px",
			"max-width":edit_pencil_size + "px",
			"max-height":edit_pencil_size + "px",
			"position":"absolute",
			"top":dyna_area_position.top + "px",
			"left":dyna_area_position.left + "px"
		}, class: "dynamic_area_edit_link", attr: {"rel": dyna_area_id}});
		$("body").append(appended_div);
	}

	// Build the data object
	var data = {};
	data.id = dyna_area_id;
	data.top = dyna_area_position.top;
	data.left = dyna_area_position.left;
	data.bottom = dyna_area_position.top + dyna_area_height;
	data.right = dyna_area_position.left + dyna_area_width;

	// Set the edit pencil info
	data.edit_top = dyna_area_position.top;
	data.edit_left = dyna_area_position.left;
	data.edit_bottom = (dyna_area_position.top + edit_pencil_size);
	data.edit_right = (dyna_area_position.left + edit_pencil_size);

	// Determine the position of the edit pencil and override it if necessary
	for(elem = 0; elem < (dyna_area_elements.length - 1); elem++) {
		if(dyna_area_elements[elem].id != dyna_area_id && dyna_area_elements[elem].top >= dyna_area_position.top && dyna_area_elements[elem].top < (dyna_area_position.top + edit_pencil_size) && dyna_area_elements[elem].left >= dyna_area_position.left && dyna_area_elements[elem].left < (dyna_area_position.left + edit_pencil_size)) {
			var edit_position_top = (dyna_area_position.top - (edit_pencil_size/2));
			var edit_position_left = (dyna_area_position.left - (edit_pencil_size/2));
			// Go ahead and move it ;-)
			$("#dynamic_area_" + dyna_area_id).css({
				"top":edit_position_top + "px",
				"left":edit_position_left + "px"
			});
			data.edit_top = edit_position_top;
			data.edit_left = edit_position_left;
			data.edit_bottom = (edit_position_top + edit_pencil_size);
			data.edit_right = (edit_position_left + edit_pencil_size);
		}
	}

	new_dyna_area_elements.push(data);

}

function dyna_area_id_exists(dyna_area_id) {
	for(elem = 0; elem < (dyna_area_elements.length - 1); elem++) {
		if(dyna_area_elements[elem].id == dyna_area_id) {
			return elem;
		}
	}

	return 0;
}

function determine_which_dyna_areas_are_hovered(x,y) {
	
	if(dyna_areas_on == "on") { return; }

	// Special Logic for slider dynamic area
	$(".slider").each(function() {
		var id = $(this).attr("id");
		$("#" + id + " .dynamic_area_content").each(function() {
			var slide_id = $(this).attr("id");
			var active_id = $("#" + id + " .flex-active-slide .dynamic_area_content").attr("id");
			if(active_id != slide_id) {
				$("#dynamic_area_" + slide_id).attr("disabled","disabled");
			} else {
				$("#dynamic_area_" + active_id).show(0).removeAttr("disabled");
			}
		});
	});
	
	for(elem = 0; elem < dyna_area_elements.length; elem++) {
		if(
			// The main box
			y > dyna_area_elements[elem].top &&
			y < dyna_area_elements[elem].bottom &&
			x > dyna_area_elements[elem].left &&
			x < dyna_area_elements[elem].right
			||
			// The edit pencil box
			y > dyna_area_elements[elem].edit_top &&
			y < dyna_area_elements[elem].edit_bottom &&
			x > dyna_area_elements[elem].edit_left &&
			x < dyna_area_elements[elem].edit_right
		) {
			// If the dyna area is disabled, don't show it
			if($("#dynamic_area_" + dyna_area_elements[elem].id).attr("disabled") == "disabled") {
				$("#dynamic_area_" + dyna_area_elements[elem].id).fadeOut(0, function() {
					var dyna = $(this).attr("rel");
					$("#" + dyna).css('outline-color','rgba(255,0,0,0.00)');
				});
			} else {
				if(!$("#dynamic_area_" + dyna_area_elements[elem].id).data('fading') && !$("#dynamic_area_" + dyna_area_elements[elem].id).data('active')) {
					$("#dynamic_area_" + dyna_area_elements[elem].id).data('fading', true).animate({"opacity":1.0}, {
						duration: fade_duration,
						step: function(now) {
							var dyna = $(this).attr("rel");
							$("#" + dyna).css('outline-color','rgba(255,0,0,'+now+')');
						},
						complete: function(now) {
							$(this).data('fading', false);
							$(this).data('active', true);
						}
					});
				}
			}
		} else {
			if(!$("#dynamic_area_" + dyna_area_elements[elem].id).data('fading') && $("#dynamic_area_" + dyna_area_elements[elem].id).data('active')) {
				$("#dynamic_area_" + dyna_area_elements[elem].id).data('fading', true).css({"opacity":1}).animate({"opacity":0}, {
					duration: fade_duration,
					step: function(now) {
						var dyna = $(this).attr("rel");
						$("#" + dyna).css('outline-color','rgba(255,0,0,'+now+')');
					},
					complete: function(now) {
						$(this).data('fading', false);
						$(this).data('active', false);
					}
				});
			}
		}
	}
}

$(document).on('click','.dynamic_area_edit_link', function() {
	var id = $(this).attr("rel");
	var url = $("#" + id).data("href");
	if(url !== undefined) {
		var width = $("#" + id).data("width");
		var height = $("#" + id).data("height");
		var da_w = window.open(url,'ai_popup','location=0,status=0,scrollbars=1,resizable=1,width=' + width + ',height=' + height);
		if(!da_w){
			alert('Please, turn pop-ups on for this site.');
		} else {
			da_w.focus();
		}
	} else {
		var onclick = $("#" + id).data("onclick");
		var onclick_param_1 = $("#" + id).data("param1");
		if(onclick !== undefined) {
			window[onclick](onclick_param_1);
		}
	}
});

function init_style_mouseovers(element,element_type,id)
{

	$(element_type + element).css({"position":"relative"}).append('<div class="dynamic_styles_edit_link ai_edit_toggle" id="dynamic_styles_edit_' + id + '"></div>');
	if($('.dynamic_styles_edit_controls').length == 0) {
		$("HTML").append('<div class="dynamic_styles_edit_controls"></div>');
	}
	$(".dynamic_styles_edit_link").show(0);
	$(".status_saved_message").delay("2000").fadeOut("slow");
}

function close_dynamic_styles_popup()
{
	$(".dynamic_styles_edit_controls").empty();
	$(".dynamic_styles_edit_link").show(0);
	$(".status_saved_message").delay("2000").fadeOut("slow");
}

function init_history_jeditable(anchor_point,id)
{
	direction_class = "history_dropdown";
	direction_class_indentifier = "." + direction_class;

	// Add History icon, and click event
	var history_drop_point = $("<div />");

	var html = "";
	html += "<div id=\"view_history_" + id + "\" class=\"history_drop\">";
	html += "<img class=\"history\" src=\"includes/plugins/dynamic_areas/images/history.png\" />";
	html += "</div>";

	history_drop_point.html(html);
	history_drop_point.addClass('history_drop_point');

	$(anchor_point).append(history_drop_point);

	// Create placeholder for history
	var history_dropdown = $("<div />");
	history_dropdown.addClass(direction_class);
	$("#view_history_" + id).append(history_dropdown);

	var updated = false;
	$("#view_history_" + id + ".history_drop IMG.history").on('click',function(event) {
		if($("#view_history_" + id + " " + direction_class_indentifier).hasClass('dropped_down')) {
			$("#view_history_" + id + " " + direction_class_indentifier).removeClass('dropped_down').slideUp(125);
		} else {
			if($("#view_history_" + id + " " + direction_class_indentifier).hasClass('has_content')) {
				reset_history_page();
				$("#view_history_" + id + " " + direction_class_indentifier).addClass('dropped_down').slideDown(125);
			} else {
				$("#view_history_" + id + " IMG").attr("src","includes/plugins/dynamic_areas/images/loading_white_on_blue.gif");
				$.get("dynamic_area_history?ai_skin=full_page&te_class=dynamic_area_history&te_mode=ajax&ajax_cmd=lookup_history&hide_style=true&id=" + id, function(data) {
					$("#view_history_" + id + " " + direction_class_indentifier).html(data).addClass('dropped_down has_content').slideDown(125, function() {
						$("#view_history_" + id + " IMG").attr("src","includes/plugins/dynamic_areas/images/history.png");
					});

					$("#view_history_" + id + " " + direction_class_indentifier + " DIV").on('mouseover',function(event) {
						$(".history_content").hide(0);
						$(this).children('SPAN').show(0).on('mouseout',function(event) {
							$(this).hide(0);
						});
						$(this).children('SPAN').on('click','BUTTON',function(event) {
							event.preventDefault();
							var id = $(this).attr('rel');
							if(id > 0 && !updated) {
								var updated = true; // Causing issues with repeating, hence the flag
								var dynamic_id = $(".history_content_content_" + id).attr('rel');

								// Set the content
								$(".dynamic_area_" + dynamic_id + " FORM.jeditable_input INPUT").val( $('.history_content_content_' + id).html() );
								$(".dynamic_area_" + dynamic_id + " FORM.jeditable_input TEXTAREA").val( $('.history_content_content_' + id).html() );

								$("#view_history_" + dynamic_id + " " + direction_class_indentifier).removeClass('dropped_down').slideUp(125);
							}
						});
					});
				});
			}
		}
	});
}

function init_history(anchor_point,id)
{
	direction_class = "history_dropup";
	direction_class_indentifier = "." + direction_class;

	$(anchor_point).addClass('history_drop wysiwyg_history_drop_point').html("<img class=\"history\" src=\"includes/plugins/dynamic_areas/images/history.png\" />").attr("id","view_history_" + id);

	$('body').click( function(){$(".history_content").hide(0);} )
		.keyup( function(e){if(e.keyCode === 27)$(".history_content").hide(0);} );

	// Create placeholder for history
	var history_dropdown = $("<div />");
	history_dropdown.addClass(direction_class);
	$("#view_history_" + id).append(history_dropdown);

	var updated = false;
	$("#view_history_" + id + ".history_drop IMG.history").on('click',function(event) {
		if($("#view_history_" + id + " " + direction_class_indentifier).hasClass('dropped_down')) {
			$("#view_history_" + id + " " + direction_class_indentifier).removeClass('dropped_down').slideDown(125);
		} else {
			if($("#view_history_" + id + " " + direction_class_indentifier).hasClass('has_content')) {
				reset_history_page();
				$("#view_history_" + id + " " + direction_class_indentifier).addClass('dropped_down').slideUp(125);
			} else {
				$("#view_history_" + id + " IMG.history").attr("src","includes/plugins/dynamic_areas/images/loading_white_on_blue.gif");
				$.get("dynamic_area_history?ai_skin=full_page&te_class=dynamic_area_history&te_mode=ajax&ajax_cmd=lookup_history&hide_style=true&id=" + id, function(data) {
					$("#view_history_" + id + " " + direction_class_indentifier).html(data).slideDown(125, function() {
						//$("#view_history_" + id + " " + direction_class_indentifier).addClass('dropped_down');
						$("#view_history_" + id + " " + direction_class_indentifier).addClass('has_content');
						$("#view_history_" + id + " IMG.history").attr("src","includes/plugins/dynamic_areas/images/history.png");
					});

					$("#view_history_" + id + " " + direction_class_indentifier + " DIV").on('mouseover',function(event) {
						$(".history_content").hide(0);
						var $this = $(this);
						$this.children('SPAN').show(0);
						if($this.data('drawn') != 'true')
						{
							/* iframe = $("<iframe width=\"100%\" height=\"126\" frameborder=\"0\" src=\""
								 + "dynamic_area_history?ai_skin=full_page&te_class=dynamic_area_history&te_mode=ajax&ajax_cmd=reload_content&id=" + id + "&mode="
								 + "\"></iframe>").on('mouseout',function(event) {
								 $(this).hide(0);
								 });*/
							$(this).children('SPAN').on('click','BUTTON',function(event) {
								event.preventDefault();
								var id = $(this).attr('rel');
								if(id > 0 && !updated) {
									var updated = true; // Causing issues with repeating, hence the flag
									var dynamic_id = $(".history_content_content_" + id).attr('rel');

									o_content.value = $('.history_content_content_' + id).html();
									wysiwyg_doc_write( $('.history_content_content_' + id).html() );

									$("#view_history_" + dynamic_id + " " + direction_class_indentifier).removeClass('dropped_down').slideDown(125);
								}
							});
							//$this.find('.da_history_content_content').after(iframe);
							$this.data('drawn','true');
						}//else $(this).data('drawn') == true
					});//on mouseover
				});//get
			}//else $("#view_history_" + id + " " + direction_class_indentifier).hasClass('has_content')
		}//else $("#view_history_" + id + " " + direction_class_indentifier).hasClass('dropped_down')
	});// on(click)
}//init history

$(document).on("click","#history_next_page", function(event) {
	$("#history_next_page, #history_prev_page").show(0);

	var page = parseInt($("#history_page_indicator").text());
	var max_page = parseInt($("#history_page_total").text());

	$(".history_content").hide(0);
	$("#history_page_indicator").text(page + 1);
	$("#history_page_" + page).slideUp(125);
	$("#history_page_" + (page + 1)).slideDown(125);

	if((page + 1) == max_page) {
		$("#history_next_page").hide(0);
	}

});
$(document).on("click","#history_prev_page", function(event) {
	$("#history_next_page, #history_prev_page").show(0);

	var page = parseInt($("#history_page_indicator").text());
	var max_page = parseInt($("#history_page_total").text());

	$(".history_content").hide(0);
	$("#history_page_indicator").text(page - 1);
	$("#history_page_" + page).slideUp(125);
	$("#history_page_" + (page - 1)).slideDown(125);

	if((page - 1) == 1) {
		$("#history_prev_page").hide(0);
	}

});

function reset_history_page()
{
	$("#history_prev_page").hide(0);
	$(".history_content").hide(0);
	$("#history_page_indicator").text("1");
	$(".history_page").slideUp(125);
	$("#history_page_1").slideDown(125);
}

function display_link_table(id)
{
	$("#link_table_content_" + id).slideUp(125);
	$("#link_table_empty_" + id).slideUp(125);
	$("#link_table_" + id).slideDown(125);
	$("#upload_file_container_" + id).slideDown(125);
}

$('.wysiwyg_link_table BUTTON[type="submit"]').click(function(event) {
	event.preventDefault();
	var id = $(this).closest("div").attr("rel");
	$("#link_table_" + id + " IMG").show(0);

	var mode = $("#link_table_" + id + " #mode").val();
	var saved_url = $("#link_table_" + id + " #url").val();
	var text = $("#link_table_" + id + " #text").val();
	var target = $("#link_table_" + id + " #target").val();
	var original_content = $("#link_table_" + id + " #original_content").val();

	var url = "dynamic_areas?ai_skin=full_page&te_class=dynamic_areas&te_mode=ajax&ajax_cmd=inline_post_save";
	var data = {id: id, mode: mode, original_content: original_content, url: encodeURIComponent(saved_url), text: encodeURIComponent(text), target: encodeURIComponent(target)};

	$.post(url, data, function( response ) {
		$("#link_table_content_" + id).html(response).slideDown(125);
		$("#link_table_" + id + " IMG").hide(0);
		$("#link_table_" + id).slideUp(125);
		$("#upload_file_container_" + id).slideUp(125);
		enable_all_dynamic_areas();
	});
});

function close_table(id) {
	$("#link_table_" + id + " IMG").hide(0);
	$("#link_table_content_" + id).slideDown(125);
	$("#link_table_" + id + " IMG").hide(0);
	$("#link_table_" + id).slideUp(125);
	$("#upload_file_container_" + id).slideUp(125);
	enable_all_dynamic_areas();
}

/****** end css file: dynamic_areas.js ******/

/****** js file: prettify.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/core/js/prettify.js ******/
/****** last modified: 1360217436 (2013-02-07 00:10:36) ******/
var q=null;window.PR_SHOULD_USE_CONTINUATION=!0;
(function(){function L(a){function m(a){var f=a.charCodeAt(0);if(f!==92)return f;var b=a.charAt(1);return(f=r[b])?f:"0"<=b&&b<="7"?parseInt(a.substring(1),8):b==="u"||b==="x"?parseInt(a.substring(2),16):a.charCodeAt(1)}function e(a){if(a<32)return(a<16?"\\x0":"\\x")+a.toString(16);a=String.fromCharCode(a);if(a==="\\"||a==="-"||a==="["||a==="]")a="\\"+a;return a}function h(a){for(var f=a.substring(1,a.length-1).match(/\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\[0-3][0-7]{0,2}|\\[0-7]{1,2}|\\[\S\s]|[^\\]/g),a=
[],b=[],o=f[0]==="^",c=o?1:0,i=f.length;c<i;++c){var j=f[c];if(/\\[bdsw]/i.test(j))a.push(j);else{var j=m(j),d;c+2<i&&"-"===f[c+1]?(d=m(f[c+2]),c+=2):d=j;b.push([j,d]);d<65||j>122||(d<65||j>90||b.push([Math.max(65,j)|32,Math.min(d,90)|32]),d<97||j>122||b.push([Math.max(97,j)&-33,Math.min(d,122)&-33]))}}b.sort(function(a,f){return a[0]-f[0]||f[1]-a[1]});f=[];j=[NaN,NaN];for(c=0;c<b.length;++c)i=b[c],i[0]<=j[1]+1?j[1]=Math.max(j[1],i[1]):f.push(j=i);b=["["];o&&b.push("^");b.push.apply(b,a);for(c=0;c<
f.length;++c)i=f[c],b.push(e(i[0])),i[1]>i[0]&&(i[1]+1>i[0]&&b.push("-"),b.push(e(i[1])));b.push("]");return b.join("")}function y(a){for(var f=a.source.match(/\[(?:[^\\\]]|\\[\S\s])*]|\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\\d+|\\[^\dux]|\(\?[!:=]|[()^]|[^()[\\^]+/g),b=f.length,d=[],c=0,i=0;c<b;++c){var j=f[c];j==="("?++i:"\\"===j.charAt(0)&&(j=+j.substring(1))&&j<=i&&(d[j]=-1)}for(c=1;c<d.length;++c)-1===d[c]&&(d[c]=++t);for(i=c=0;c<b;++c)j=f[c],j==="("?(++i,d[i]===void 0&&(f[c]="(?:")):"\\"===j.charAt(0)&&
(j=+j.substring(1))&&j<=i&&(f[c]="\\"+d[i]);for(i=c=0;c<b;++c)"^"===f[c]&&"^"!==f[c+1]&&(f[c]="");if(a.ignoreCase&&s)for(c=0;c<b;++c)j=f[c],a=j.charAt(0),j.length>=2&&a==="["?f[c]=h(j):a!=="\\"&&(f[c]=j.replace(/[A-Za-z]/g,function(a){a=a.charCodeAt(0);return"["+String.fromCharCode(a&-33,a|32)+"]"}));return f.join("")}for(var t=0,s=!1,l=!1,p=0,d=a.length;p<d;++p){var g=a[p];if(g.ignoreCase)l=!0;else if(/[a-z]/i.test(g.source.replace(/\\u[\da-f]{4}|\\x[\da-f]{2}|\\[^UXux]/gi,""))){s=!0;l=!1;break}}for(var r=
{b:8,t:9,n:10,v:11,f:12,r:13},n=[],p=0,d=a.length;p<d;++p){g=a[p];if(g.global||g.multiline)throw Error(""+g);n.push("(?:"+y(g)+")")}return RegExp(n.join("|"),l?"gi":"g")}function M(a){function m(a){switch(a.nodeType){case 1:if(e.test(a.className))break;for(var g=a.firstChild;g;g=g.nextSibling)m(g);g=a.nodeName;if("BR"===g||"LI"===g)h[s]="\n",t[s<<1]=y++,t[s++<<1|1]=a;break;case 3:case 4:g=a.nodeValue,g.length&&(g=p?g.replace(/\r\n?/g,"\n"):g.replace(/[\t\n\r ]+/g," "),h[s]=g,t[s<<1]=y,y+=g.length,
t[s++<<1|1]=a)}}var e=/(?:^|\s)nocode(?:\s|$)/,h=[],y=0,t=[],s=0,l;a.currentStyle?l=a.currentStyle.whiteSpace:window.getComputedStyle&&(l=document.defaultView.getComputedStyle(a,q).getPropertyValue("white-space"));var p=l&&"pre"===l.substring(0,3);m(a);return{a:h.join("").replace(/\n$/,""),c:t}}function B(a,m,e,h){m&&(a={a:m,d:a},e(a),h.push.apply(h,a.e))}function x(a,m){function e(a){for(var l=a.d,p=[l,"pln"],d=0,g=a.a.match(y)||[],r={},n=0,z=g.length;n<z;++n){var f=g[n],b=r[f],o=void 0,c;if(typeof b===
"string")c=!1;else{var i=h[f.charAt(0)];if(i)o=f.match(i[1]),b=i[0];else{for(c=0;c<t;++c)if(i=m[c],o=f.match(i[1])){b=i[0];break}o||(b="pln")}if((c=b.length>=5&&"lang-"===b.substring(0,5))&&!(o&&typeof o[1]==="string"))c=!1,b="src";c||(r[f]=b)}i=d;d+=f.length;if(c){c=o[1];var j=f.indexOf(c),k=j+c.length;o[2]&&(k=f.length-o[2].length,j=k-c.length);b=b.substring(5);B(l+i,f.substring(0,j),e,p);B(l+i+j,c,C(b,c),p);B(l+i+k,f.substring(k),e,p)}else p.push(l+i,b)}a.e=p}var h={},y;(function(){for(var e=a.concat(m),
l=[],p={},d=0,g=e.length;d<g;++d){var r=e[d],n=r[3];if(n)for(var k=n.length;--k>=0;)h[n.charAt(k)]=r;r=r[1];n=""+r;p.hasOwnProperty(n)||(l.push(r),p[n]=q)}l.push(/[\S\s]/);y=L(l)})();var t=m.length;return e}function u(a){var m=[],e=[];a.tripleQuotedStrings?m.push(["str",/^(?:'''(?:[^'\\]|\\[\S\s]|''?(?=[^']))*(?:'''|$)|"""(?:[^"\\]|\\[\S\s]|""?(?=[^"]))*(?:"""|$)|'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$))/,q,"'\""]):a.multiLineStrings?m.push(["str",/^(?:'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$)|`(?:[^\\`]|\\[\S\s])*(?:`|$))/,
q,"'\"`"]):m.push(["str",/^(?:'(?:[^\n\r'\\]|\\.)*(?:'|$)|"(?:[^\n\r"\\]|\\.)*(?:"|$))/,q,"\"'"]);a.verbatimStrings&&e.push(["str",/^@"(?:[^"]|"")*(?:"|$)/,q]);var h=a.hashComments;h&&(a.cStyleComments?(h>1?m.push(["com",/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,q,"#"]):m.push(["com",/^#(?:(?:define|elif|else|endif|error|ifdef|include|ifndef|line|pragma|undef|warning)\b|[^\n\r]*)/,q,"#"]),e.push(["str",/^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h|[a-z]\w*)>/,q])):m.push(["com",/^#[^\n\r]*/,
q,"#"]));a.cStyleComments&&(e.push(["com",/^\/\/[^\n\r]*/,q]),e.push(["com",/^\/\*[\S\s]*?(?:\*\/|$)/,q]));a.regexLiterals&&e.push(["lang-regex",/^(?:^^\.?|[!+-]|!=|!==|#|%|%=|&|&&|&&=|&=|\(|\*|\*=|\+=|,|-=|->|\/|\/=|:|::|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|[?@[^]|\^=|\^\^|\^\^=|{|\||\|=|\|\||\|\|=|~|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\s*(\/(?=[^*/])(?:[^/[\\]|\\[\S\s]|\[(?:[^\\\]]|\\[\S\s])*(?:]|$))+\/)/]);(h=a.types)&&e.push(["typ",h]);a=(""+a.keywords).replace(/^ | $/g,
"");a.length&&e.push(["kwd",RegExp("^(?:"+a.replace(/[\s,]+/g,"|")+")\\b"),q]);m.push(["pln",/^\s+/,q," \r\n\t\xa0"]);e.push(["lit",/^@[$_a-z][\w$@]*/i,q],["typ",/^(?:[@_]?[A-Z]+[a-z][\w$@]*|\w+_t\b)/,q],["pln",/^[$_a-z][\w$@]*/i,q],["lit",/^(?:0x[\da-f]+|(?:\d(?:_\d+)*\d*(?:\.\d*)?|\.\d\+)(?:e[+-]?\d+)?)[a-z]*/i,q,"0123456789"],["pln",/^\\[\S\s]?/,q],["pun",/^.[^\s\w"-$'./@\\`]*/,q]);return x(m,e)}function D(a,m){function e(a){switch(a.nodeType){case 1:if(k.test(a.className))break;if("BR"===a.nodeName)h(a),
a.parentNode&&a.parentNode.removeChild(a);else for(a=a.firstChild;a;a=a.nextSibling)e(a);break;case 3:case 4:if(p){var b=a.nodeValue,d=b.match(t);if(d){var c=b.substring(0,d.index);a.nodeValue=c;(b=b.substring(d.index+d[0].length))&&a.parentNode.insertBefore(s.createTextNode(b),a.nextSibling);h(a);c||a.parentNode.removeChild(a)}}}}function h(a){function b(a,d){var e=d?a.cloneNode(!1):a,f=a.parentNode;if(f){var f=b(f,1),g=a.nextSibling;f.appendChild(e);for(var h=g;h;h=g)g=h.nextSibling,f.appendChild(h)}return e}
for(;!a.nextSibling;)if(a=a.parentNode,!a)return;for(var a=b(a.nextSibling,0),e;(e=a.parentNode)&&e.nodeType===1;)a=e;d.push(a)}var k=/(?:^|\s)nocode(?:\s|$)/,t=/\r\n?|\n/,s=a.ownerDocument,l;a.currentStyle?l=a.currentStyle.whiteSpace:window.getComputedStyle&&(l=s.defaultView.getComputedStyle(a,q).getPropertyValue("white-space"));var p=l&&"pre"===l.substring(0,3);for(l=s.createElement("LI");a.firstChild;)l.appendChild(a.firstChild);for(var d=[l],g=0;g<d.length;++g)e(d[g]);m===(m|0)&&d[0].setAttribute("value",
m);var r=s.createElement("OL");r.className="linenums";for(var n=Math.max(0,m-1|0)||0,g=0,z=d.length;g<z;++g)l=d[g],l.className="L"+(g+n)%10,l.firstChild||l.appendChild(s.createTextNode("\xa0")),r.appendChild(l);a.appendChild(r)}function k(a,m){for(var e=m.length;--e>=0;){var h=m[e];A.hasOwnProperty(h)?window.console&&console.warn("cannot override language handler %s",h):A[h]=a}}function C(a,m){if(!a||!A.hasOwnProperty(a))a=/^\s*</.test(m)?"default-markup":"default-code";return A[a]}function E(a){var m=
a.g;try{var e=M(a.h),h=e.a;a.a=h;a.c=e.c;a.d=0;C(m,h)(a);var k=/\bMSIE\b/.test(navigator.userAgent),m=/\n/g,t=a.a,s=t.length,e=0,l=a.c,p=l.length,h=0,d=a.e,g=d.length,a=0;d[g]=s;var r,n;for(n=r=0;n<g;)d[n]!==d[n+2]?(d[r++]=d[n++],d[r++]=d[n++]):n+=2;g=r;for(n=r=0;n<g;){for(var z=d[n],f=d[n+1],b=n+2;b+2<=g&&d[b+1]===f;)b+=2;d[r++]=z;d[r++]=f;n=b}for(d.length=r;h<p;){var o=l[h+2]||s,c=d[a+2]||s,b=Math.min(o,c),i=l[h+1],j;if(i.nodeType!==1&&(j=t.substring(e,b))){k&&(j=j.replace(m,"\r"));i.nodeValue=
j;var u=i.ownerDocument,v=u.createElement("SPAN");v.className=d[a+1];var x=i.parentNode;x.replaceChild(v,i);v.appendChild(i);e<o&&(l[h+1]=i=u.createTextNode(t.substring(b,o)),x.insertBefore(i,v.nextSibling))}e=b;e>=o&&(h+=2);e>=c&&(a+=2)}}catch(w){"console"in window&&console.log(w&&w.stack?w.stack:w)}}var v=["break,continue,do,else,for,if,return,while"],w=[[v,"auto,case,char,const,default,double,enum,extern,float,goto,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"],
"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"],F=[w,"alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,dynamic_cast,explicit,export,friend,inline,late_check,mutable,namespace,nullptr,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"],G=[w,"abstract,boolean,byte,extends,final,finally,implements,import,instanceof,null,native,package,strictfp,super,synchronized,throws,transient"],
H=[G,"as,base,by,checked,decimal,delegate,descending,dynamic,event,fixed,foreach,from,group,implicit,in,interface,internal,into,is,lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var"],w=[w,"debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"],I=[v,"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"],
J=[v,"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"],v=[v,"case,done,elif,esac,eval,fi,function,in,local,set,then,until"],K=/^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\d*)/,N=/\S/,O=u({keywords:[F,H,w,"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END"+
I,J,v],hashComments:!0,cStyleComments:!0,multiLineStrings:!0,regexLiterals:!0}),A={};k(O,["default-code"]);k(x([],[["pln",/^[^?<]+/],["dec",/^<!\w[^>]*(?:>|$)/],["com",/^<\!--[\S\s]*?(?:--\>|$)/],["lang-",/^<\?([\S\s]+?)(?:\?>|$)/],["lang-",/^<%([\S\s]+?)(?:%>|$)/],["pun",/^(?:<[%?]|[%?]>)/],["lang-",/^<xmp\b[^>]*>([\S\s]+?)<\/xmp\b[^>]*>/i],["lang-js",/^<script\b[^>]*>([\S\s]*?)(<\/script\b[^>]*>)/i],["lang-css",/^<style\b[^>]*>([\S\s]*?)(<\/style\b[^>]*>)/i],["lang-in.tag",/^(<\/?[a-z][^<>]*>)/i]]),
["default-markup","htm","html","mxml","xhtml","xml","xsl"]);k(x([["pln",/^\s+/,q," \t\r\n"],["atv",/^(?:"[^"]*"?|'[^']*'?)/,q,"\"'"]],[["tag",/^^<\/?[a-z](?:[\w-.:]*\w)?|\/?>$/i],["atn",/^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i],["lang-uq.val",/^=\s*([^\s"'>]*(?:[^\s"'/>]|\/(?=\s)))/],["pun",/^[/<->]+/],["lang-js",/^on\w+\s*=\s*"([^"]+)"/i],["lang-js",/^on\w+\s*=\s*'([^']+)'/i],["lang-js",/^on\w+\s*=\s*([^\s"'>]+)/i],["lang-css",/^style\s*=\s*"([^"]+)"/i],["lang-css",/^style\s*=\s*'([^']+)'/i],["lang-css",
/^style\s*=\s*([^\s"'>]+)/i]]),["in.tag"]);k(x([],[["atv",/^[\S\s]+/]]),["uq.val"]);k(u({keywords:F,hashComments:!0,cStyleComments:!0,types:K}),["c","cc","cpp","cxx","cyc","m"]);k(u({keywords:"null,true,false"}),["json"]);k(u({keywords:H,hashComments:!0,cStyleComments:!0,verbatimStrings:!0,types:K}),["cs"]);k(u({keywords:G,cStyleComments:!0}),["java"]);k(u({keywords:v,hashComments:!0,multiLineStrings:!0}),["bsh","csh","sh"]);k(u({keywords:I,hashComments:!0,multiLineStrings:!0,tripleQuotedStrings:!0}),
["cv","py"]);k(u({keywords:"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["perl","pl","pm"]);k(u({keywords:J,hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["rb"]);k(u({keywords:w,cStyleComments:!0,regexLiterals:!0}),["js"]);k(u({keywords:"all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,true,try,unless,until,when,while,yes",
hashComments:3,cStyleComments:!0,multilineStrings:!0,tripleQuotedStrings:!0,regexLiterals:!0}),["coffee"]);k(x([],[["str",/^[\S\s]+/]]),["regex"]);window.prettyPrintOne=function(a,m,e){var h=document.createElement("PRE");h.innerHTML=a;e&&D(h,e);E({g:m,i:e,h:h});return h.innerHTML};window.prettyPrint=function(a){function m(){for(var e=window.PR_SHOULD_USE_CONTINUATION?l.now()+250:Infinity;p<h.length&&l.now()<e;p++){var n=h[p],k=n.className;if(k.indexOf("prettyprint")>=0){var k=k.match(g),f,b;if(b=
!k){b=n;for(var o=void 0,c=b.firstChild;c;c=c.nextSibling)var i=c.nodeType,o=i===1?o?b:c:i===3?N.test(c.nodeValue)?b:o:o;b=(f=o===b?void 0:o)&&"CODE"===f.tagName}b&&(k=f.className.match(g));k&&(k=k[1]);b=!1;for(o=n.parentNode;o;o=o.parentNode)if((o.tagName==="pre"||o.tagName==="code"||o.tagName==="xmp")&&o.className&&o.className.indexOf("prettyprint")>=0){b=!0;break}b||((b=(b=n.className.match(/\blinenums\b(?::(\d+))?/))?b[1]&&b[1].length?+b[1]:!0:!1)&&D(n,b),d={g:k,h:n,i:b},E(d))}}p<h.length?setTimeout(m,
250):a&&a()}for(var e=[document.getElementsByTagName("pre"),document.getElementsByTagName("code"),document.getElementsByTagName("xmp")],h=[],k=0;k<e.length;++k)for(var t=0,s=e[k].length;t<s;++t)h.push(e[k][t]);var e=q,l=Date;l.now||(l={now:function(){return+new Date}});var p=0,d,g=/\blang(?:uage)?-([\w.]+)(?!\S)/;m()};window.PR={createSimpleLexer:x,registerLangHandler:k,sourceDecorator:u,PR_ATTRIB_NAME:"atn",PR_ATTRIB_VALUE:"atv",PR_COMMENT:"com",PR_DECLARATION:"dec",PR_KEYWORD:"kwd",PR_LITERAL:"lit",
PR_NOCODE:"nocode",PR_PLAIN:"pln",PR_PUNCTUATION:"pun",PR_SOURCE:"src",PR_STRING:"str",PR_TAG:"tag",PR_TYPE:"typ"}})();
/****** end css file: prettify.js ******/

/****** js file: aitips.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/plugins/tips/aitips.js ******/
/****** last modified: 1412887712 (2014-10-09 15:48:32) ******/
var drawn_fail_alert = false;
function get_next_matching_div($from_obj,selector,level){
	if(level==null) level=1;
	$found = $from_obj.next(selector);
	if($found.length>0) return $found;
	$from_obj = $from_obj.parent();
	if(level>4) { 
		if(!drawn_fail_alert) alert('failed to find associated tooltip');
		drawn_fail_alert=true;
		return false;
	}
	else return get_next_matching_div($from_obj,selector,level+1);
}
function set_tip_pos($source,$tipobj) {
	var position = $source.position();
	var xd = ($source.attr('tipx')>0? $source.attr('tipx'):0);
	var yd = ($source.attr('tipy')>0? $source.attr('tipy'):28);
	$tipobj.css({left:position.left+xd, top:position.top+yd});
}
function adjust_tip_pos($tipobj){
	if($tipobj.hasClass('noadjust')) reutrn;
	
	//get positions
	width = $tipobj.outerWidth();
	height = $tipobj.outerHeight();
	var position = $tipobj.position();
	pos_left = position.left;
	pos_right=(pos_left + width);
	pos_top = position.top;
	pos_bott =(pos_top + height);
	win_width = $(window).width();
	win_left = $(window).scrollLeft();
	win_right = $(window).scrollLeft()+$(window).width();
	win_top = $(window).scrollTop();
	win_bott = $(window).scrollTop()+$(window).height();
	//RESIZE IT?
	if(width > win_width) { $tipobj.width( (win_width>600? 600:win_width-20) ); $tipobj.css({"white-space":"normal"}); }
	
	//compute new left
	old_left=pos_left;
	if(pos_right > win_right-10) pos_left = win_right - width - 10;
	if(pos_left < win_left) pos_left = win_left+5;
	//compute new top
	old_top=pos_top;
	if(pos_bott > win_bott-10) { pos_top = win_bott - height - 10; }
	if(pos_top < win_top) { pos_top = win_top+5; }
	//MOVE
	if(pos_left!=old_left) $tipobj.css({left:pos_left});
  
	if(pos_top!=old_top) $tipobj.css({top:pos_top});

}

$(document).ready(function(){
	
	
	
	//AITIPS WORK ON FOCUS 
	$("body").delegate(".has_aitip", "focus", function(){
		var $obj = get_next_matching_div($(this),'div.aitip');
		set_tip_pos($(this),$obj);
		$obj.css({opacity:1, display:"none"}).fadeIn(200);
		//adjust_tip_pos($obj);
  });
	$("body").delegate(".has_aitip", "blur", function(){
		var $obj = get_next_matching_div($(this),'div.aitip');
    $obj.fadeOut(400);
  });
	
	
	
	
	//AIQTIPS WORK ON HOVER
	var $over_has_qtip=false;
	var $over_qtip=false;
	function check_clear_qtip($obj){
		if($over_qtip!==false && $over_qtip[0]==$obj[0]) return;
		if($over_has_qtip!==false && $over_has_qtip[0]==$obj[0]) return;
		$obj.fadeOut(400);
	}
	$("body").delegate(".has_aiqtip", "mouseover", function(){
		var $obj = get_next_matching_div($(this),'div.aiqtip');
		if($over_qtip!=false && $over_has_qtip[0]==$obj[0]) return;
		$over_has_qtip=$obj;
		set_tip_pos($(this),$obj);
		$obj.css({opacity:1, display:"none"}).fadeIn(200);
		adjust_tip_pos($obj);
  });
	$("body").delegate(".has_aiqtip", "mouseout", function(){
		$over_has_qtip = false;
		$obj = get_next_matching_div($(this),'div.aiqtip');
		setTimeout(function() { check_clear_qtip($obj); }, 30);
	});
	$("body").delegate(".aiqtip", "mouseover", function(){ $over_qtip = $(this); });
	$("body").delegate(".aiqtip", "mouseout", function(){
		$over_qtip = false;
		$obj = $(this);
		setTimeout(function() { check_clear_qtip($obj); }, 30);
	});



	//AICTIPS WORK ON CLICK
	var $open_ctip=false;
	var safeclick=0;
	function clear_ctip(){
		$open_ctip.fadeOut(400);
		$open_ctip=false;
	}
	$("body").delegate(".has_aictip", "click", function(){
		var $obj = get_next_matching_div($(this),'div.aictip');
		if($open_ctip!=false && $open_ctip[0]==$obj[0]) {safeclick=1; return; }
		if($open_ctip!=false) clear_ctip();
		set_tip_pos($(this),$obj);
		$obj.css({opacity:1, display:"none"}).fadeIn(200);
		adjust_tip_pos($obj);
		$open_ctip=$obj;
		safeclick = true;
  });
	$("body").delegate(".aictip", "click", function(){
		safeclick = true;
	});
	$("body").click(function(){
		if(!safeclick && $open_ctip!=false) {
			clear_ctip();
		}
		else if(safeclick) safeclick=false;
		return true; 
	});


});


/****** end css file: aitips.js ******/

/****** js file: mediaelement-and-player.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/js/mediaelement/build/mediaelement-and-player.js ******/
/****** last modified: 1468871880 (2016-07-18 14:58:00) ******/
/*!
 *
 * MediaElement.js
 * HTML5 <video> and <audio> shim and player
 * http://mediaelementjs.com/
 *
 * Creates a JavaScript object that mimics HTML5 MediaElement API
 * for browsers that don't understand HTML5 or can't play the provided codec
 * Can play MP4 (H.264), Ogg, WebM, FLV, WMV, WMA, ACC, and MP3
 *
 * Copyright 2010-2014, John Dyer (http://j.hn)
 * License: MIT
 *
 */
// Namespace
var mejs = mejs || {};

// version number
mejs.version = '2.21.2'; 


// player number (for missing, same id attr)
mejs.meIndex = 0;

// media types accepted by plugins
mejs.plugins = {
	silverlight: [
		{version: [3,0], types: ['video/mp4','video/m4v','video/mov','video/wmv','audio/wma','audio/m4a','audio/mp3','audio/wav','audio/mpeg']}
	],
	flash: [
		{version: [9,0,124], types: ['video/mp4','video/m4v','video/mov','video/flv','video/rtmp','video/x-flv','audio/flv','audio/x-flv','audio/mp3','audio/m4a','audio/mpeg', 'video/dailymotion', 'video/x-dailymotion', 'application/x-mpegURL']}
		// 'video/youtube', 'video/x-youtube', 
		// ,{version: [12,0], types: ['video/webm']} // for future reference (hopefully!)
	],
	youtube: [
		{version: null, types: ['video/youtube', 'video/x-youtube', 'audio/youtube', 'audio/x-youtube']}
	],
	vimeo: [
		{version: null, types: ['video/vimeo', 'video/x-vimeo']}
	]
};

/*
Utility methods
*/
mejs.Utility = {
	encodeUrl: function(url) {
		return encodeURIComponent(url); //.replace(/\?/gi,'%3F').replace(/=/gi,'%3D').replace(/&/gi,'%26');
	},
	escapeHTML: function(s) {
		return s.toString().split('&').join('&amp;').split('<').join('&lt;').split('"').join('&quot;');
	},
	absolutizeUrl: function(url) {
		var el = document.createElement('div');
		el.innerHTML = '<a href="' + this.escapeHTML(url) + '">x</a>';
		return el.firstChild.href;
	},
	getScriptPath: function(scriptNames) {
		var
			i = 0,
			j,
			codePath = '',
			testname = '',
			slashPos,
			filenamePos,
			scriptUrl,
			scriptPath,			
			scriptFilename,
			scripts = document.getElementsByTagName('script'),
			il = scripts.length,
			jl = scriptNames.length;
			
		// go through all <script> tags
		for (; i < il; i++) {
			scriptUrl = scripts[i].src;
			slashPos = scriptUrl.lastIndexOf('/');
			if (slashPos > -1) {
				scriptFilename = scriptUrl.substring(slashPos + 1);
				scriptPath = scriptUrl.substring(0, slashPos + 1);
			} else {
				scriptFilename = scriptUrl;
				scriptPath = '';			
			}
			
			// see if any <script> tags have a file name that matches the 
			for (j = 0; j < jl; j++) {
				testname = scriptNames[j];
				filenamePos = scriptFilename.indexOf(testname);
				if (filenamePos > -1) {
					codePath = scriptPath;
					break;
				}
			}
			
			// if we found a path, then break and return it
			if (codePath !== '') {
				break;
			}
		}
		
		// send the best path back
		return codePath;
	},
	/*
	 * Calculate the time format to use. We have a default format set in the
	 * options but it can be imcomplete. We ajust it according to the media
	 * duration.
	 *
	 * We support format like 'hh:mm:ss:ff'.
	 */
	calculateTimeFormat: function(time, options, fps) {
		if (time < 0) {
			time = 0;
		}

		if(typeof fps == 'undefined') {
		    fps = 25;
		}

		var format = options.timeFormat,
			firstChar = format[0],
			firstTwoPlaces = (format[1] == format[0]),
			separatorIndex = firstTwoPlaces? 2: 1,
			separator = ':',
			hours = Math.floor(time / 3600) % 24,
			minutes = Math.floor(time / 60) % 60,
			seconds = Math.floor(time % 60),
			frames = Math.floor(((time % 1)*fps).toFixed(3)),
			lis = [
				[frames, 'f'],
				[seconds, 's'],
				[minutes, 'm'],
				[hours, 'h']
			];

		// Try to get the separator from the format
		if (format.length < separatorIndex) {
			separator = format[separatorIndex];
		}

		var required = false;

		for (var i=0, len=lis.length; i < len; i++) {
			if (format.indexOf(lis[i][1]) !== -1) {
				required=true;
			}
			else if (required) {
				var hasNextValue = false;
				for (var j=i; j < len; j++) {
					if (lis[j][0] > 0) {
						hasNextValue = true;
						break;
					}
				}

				if (! hasNextValue) {
					break;
				}

				if (!firstTwoPlaces) {
					format = firstChar + format;
				}
				format = lis[i][1] + separator + format;
				if (firstTwoPlaces) {
					format = lis[i][1] + format;
				}
				firstChar = lis[i][1];
			}
		}
		options.currentTimeFormat = format;
	},
	/*
	 * Prefix the given number by zero if it is lower than 10.
	 */
	twoDigitsString: function(n) {
		if (n < 10) {
			return '0' + n;
		}
		return String(n);
	},
	secondsToTimeCode: function(time, options) {
		if (time < 0) {
			time = 0;
		}

		// Maintain backward compatibility with method signature before v2.18.
		if (typeof options !== 'object') {
			var format = 'm:ss';
			format = arguments[1] ? 'hh:mm:ss' : format; // forceHours
			format = arguments[2] ? format + ':ff' : format; // showFrameCount

			options = {
				currentTimeFormat: format,
				framesPerSecond: arguments[3] || 25
			};
		}

		var fps = options.framesPerSecond;
		if(typeof fps === 'undefined') {
			fps = 25;
		}

		var format = options.currentTimeFormat,
			hours = Math.floor(time / 3600) % 24,
			minutes = Math.floor(time / 60) % 60,
			seconds = Math.floor(time % 60),
			frames = Math.floor(((time % 1)*fps).toFixed(3));
			lis = [
				[frames, 'f'],
				[seconds, 's'],
				[minutes, 'm'],
				[hours, 'h']
			];

		var res = format;
		for (i=0,len=lis.length; i < len; i++) {
			res = res.replace(lis[i][1]+lis[i][1], this.twoDigitsString(lis[i][0]));
			res = res.replace(lis[i][1], lis[i][0]);
		}
		return res;
	},
	
	timeCodeToSeconds: function(hh_mm_ss_ff, forceHours, showFrameCount, fps){
		if (typeof showFrameCount == 'undefined') {
		    showFrameCount=false;
		} else if(typeof fps == 'undefined') {
		    fps = 25;
		}
	
		var tc_array = hh_mm_ss_ff.split(":"),
			tc_hh = parseInt(tc_array[0], 10),
			tc_mm = parseInt(tc_array[1], 10),
			tc_ss = parseInt(tc_array[2], 10),
			tc_ff = 0,
			tc_in_seconds = 0;
		
		if (showFrameCount) {
		    tc_ff = parseInt(tc_array[3])/fps;
		}
		
		tc_in_seconds = ( tc_hh * 3600 ) + ( tc_mm * 60 ) + tc_ss + tc_ff;
		
		return tc_in_seconds;
	},
	

	convertSMPTEtoSeconds: function (SMPTE) {
		if (typeof SMPTE != 'string') 
			return false;

		SMPTE = SMPTE.replace(',', '.');
		
		var secs = 0,
			decimalLen = (SMPTE.indexOf('.') != -1) ? SMPTE.split('.')[1].length : 0,
			multiplier = 1;
		
		SMPTE = SMPTE.split(':').reverse();
		
		for (var i = 0; i < SMPTE.length; i++) {
			multiplier = 1;
			if (i > 0) {
				multiplier = Math.pow(60, i); 
			}
			secs += Number(SMPTE[i]) * multiplier;
		}
		return Number(secs.toFixed(decimalLen));
	},	
	
	/* borrowed from SWFObject: http://code.google.com/p/swfobject/source/browse/trunk/swfobject/src/swfobject.js#474 */
	removeSwf: function(id) {
		var obj = document.getElementById(id);
		if (obj && /object|embed/i.test(obj.nodeName)) {
			if (mejs.MediaFeatures.isIE) {
				obj.style.display = "none";
				(function(){
					if (obj.readyState == 4) {
						mejs.Utility.removeObjectInIE(id);
					} else {
						setTimeout(arguments.callee, 10);
					}
				})();
			} else {
				obj.parentNode.removeChild(obj);
			}
		}
	},
	removeObjectInIE: function(id) {
		var obj = document.getElementById(id);
		if (obj) {
			for (var i in obj) {
				if (typeof obj[i] == "function") {
					obj[i] = null;
				}
			}
			obj.parentNode.removeChild(obj);
		}		
	},
    determineScheme: function(url) {
        if (url && url.indexOf("://") != -1) {
            return url.substr(0, url.indexOf("://")+3);
        }
        return "//"; // let user agent figure this out
    }
};


// Core detector, plugins are added below
mejs.PluginDetector = {

	// main public function to test a plug version number PluginDetector.hasPluginVersion('flash',[9,0,125]);
	hasPluginVersion: function(plugin, v) {
		var pv = this.plugins[plugin];
		v[1] = v[1] || 0;
		v[2] = v[2] || 0;
		return (pv[0] > v[0] || (pv[0] == v[0] && pv[1] > v[1]) || (pv[0] == v[0] && pv[1] == v[1] && pv[2] >= v[2])) ? true : false;
	},

	// cached values
	nav: window.navigator,
	ua: window.navigator.userAgent.toLowerCase(),

	// stored version numbers
	plugins: [],

	// runs detectPlugin() and stores the version number
	addPlugin: function(p, pluginName, mimeType, activeX, axDetect) {
		this.plugins[p] = this.detectPlugin(pluginName, mimeType, activeX, axDetect);
	},

	// get the version number from the mimetype (all but IE) or ActiveX (IE)
	detectPlugin: function(pluginName, mimeType, activeX, axDetect) {

		var version = [0,0,0],
			description,
			i,
			ax;

		// Firefox, Webkit, Opera
		if (typeof(this.nav.plugins) != 'undefined' && typeof this.nav.plugins[pluginName] == 'object') {
			description = this.nav.plugins[pluginName].description;
			if (description && !(typeof this.nav.mimeTypes != 'undefined' && this.nav.mimeTypes[mimeType] && !this.nav.mimeTypes[mimeType].enabledPlugin)) {
				version = description.replace(pluginName, '').replace(/^\s+/,'').replace(/\sr/gi,'.').split('.');
				for (i=0; i<version.length; i++) {
					version[i] = parseInt(version[i].match(/\d+/), 10);
				}
			}
		// Internet Explorer / ActiveX
		} else if (typeof(window.ActiveXObject) != 'undefined') {
			try {
				ax = new ActiveXObject(activeX);
				if (ax) {
					version = axDetect(ax);
				}
			}
			catch (e) { }
		}
		return version;
	}
};

// Add Flash detection
mejs.PluginDetector.addPlugin('flash','Shockwave Flash','application/x-shockwave-flash','ShockwaveFlash.ShockwaveFlash', function(ax) {
	// adapted from SWFObject
	var version = [],
		d = ax.GetVariable("$version");
	if (d) {
		d = d.split(" ")[1].split(",");
		version = [parseInt(d[0], 10), parseInt(d[1], 10), parseInt(d[2], 10)];
	}
	return version;
});

// Add Silverlight detection
mejs.PluginDetector.addPlugin('silverlight','Silverlight Plug-In','application/x-silverlight-2','AgControl.AgControl', function (ax) {
	// Silverlight cannot report its version number to IE
	// but it does have a isVersionSupported function, so we have to loop through it to get a version number.
	// adapted from http://www.silverlightversion.com/
	var v = [0,0,0,0],
		loopMatch = function(ax, v, i, n) {
			while(ax.isVersionSupported(v[0]+ "."+ v[1] + "." + v[2] + "." + v[3])){
				v[i]+=n;
			}
			v[i] -= n;
		};
	loopMatch(ax, v, 0, 1);
	loopMatch(ax, v, 1, 1);
	loopMatch(ax, v, 2, 10000); // the third place in the version number is usually 5 digits (4.0.xxxxx)
	loopMatch(ax, v, 2, 1000);
	loopMatch(ax, v, 2, 100);
	loopMatch(ax, v, 2, 10);
	loopMatch(ax, v, 2, 1);
	loopMatch(ax, v, 3, 1);

	return v;
});
// add adobe acrobat
/*
PluginDetector.addPlugin('acrobat','Adobe Acrobat','application/pdf','AcroPDF.PDF', function (ax) {
	var version = [],
		d = ax.GetVersions().split(',')[0].split('=')[1].split('.');

	if (d) {
		version = [parseInt(d[0], 10), parseInt(d[1], 10), parseInt(d[2], 10)];
	}
	return version;
});
*/
// necessary detection (fixes for <IE9)
mejs.MediaFeatures = {
	init: function() {
		var
			t = this,
			d = document,
			nav = mejs.PluginDetector.nav,
			ua = mejs.PluginDetector.ua.toLowerCase(),
			i,
			v,
			html5Elements = ['source','track','audio','video'];

		// detect browsers (only the ones that have some kind of quirk we need to work around)
		t.isiPad = (ua.match(/ipad/i) !== null);
		t.isiPhone = (ua.match(/iphone/i) !== null);
		t.isiOS = t.isiPhone || t.isiPad;
		t.isAndroid = (ua.match(/android/i) !== null);
		t.isBustedAndroid = (ua.match(/android 2\.[12]/) !== null);
		t.isBustedNativeHTTPS = (location.protocol === 'https:' && (ua.match(/android [12]\./) !== null || ua.match(/macintosh.* version.* safari/) !== null));
		t.isIE = (nav.appName.toLowerCase().indexOf("microsoft") != -1 || nav.appName.toLowerCase().match(/trident/gi) !== null);
		t.isChrome = (ua.match(/chrome/gi) !== null);
		t.isChromium = (ua.match(/chromium/gi) !== null);
		t.isFirefox = (ua.match(/firefox/gi) !== null);
		t.isWebkit = (ua.match(/webkit/gi) !== null);
		t.isGecko = (ua.match(/gecko/gi) !== null) && !t.isWebkit && !t.isIE;
		t.isOpera = (ua.match(/opera/gi) !== null);
		t.hasTouch = ('ontouchstart' in window); //  && window.ontouchstart != null); // this breaks iOS 7

		// Borrowed from `Modernizr.svgasimg`, sources:
		// - https://github.com/Modernizr/Modernizr/issues/687
		// - https://github.com/Modernizr/Modernizr/pull/1209/files
		t.svgAsImg = !!document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#Image', '1.1');

		// create HTML5 media elements for IE before 9, get a <video> element for fullscreen detection
		for (i=0; i<html5Elements.length; i++) {
			v = document.createElement(html5Elements[i]);
		}

		t.supportsMediaTag = (typeof v.canPlayType !== 'undefined' || t.isBustedAndroid);

		// Fix for IE9 on Windows 7N / Windows 7KN (Media Player not installer)
		try{
			v.canPlayType("video/mp4");
		}catch(e){
			t.supportsMediaTag = false;
		}

		t.supportsPointerEvents = (function() {
			// TAKEN FROM MODERNIZR
			var element = document.createElement('x'),
				documentElement = document.documentElement,
				getComputedStyle = window.getComputedStyle,
				supports;
			if(!('pointerEvents' in element.style)){
				return false;
			}
			element.style.pointerEvents = 'auto';
			element.style.pointerEvents = 'x';
			documentElement.appendChild(element);
			supports = getComputedStyle &&
				getComputedStyle(element, '').pointerEvents === 'auto';
			documentElement.removeChild(element);
			return !!supports;
		})();


		 // Older versions of Firefox can't move plugins around without it resetting,
		t.hasFirefoxPluginMovingProblem = false;

		// detect native JavaScript fullscreen (Safari/Firefox only, Chrome still fails)

		// iOS
		t.hasiOSFullScreen = (typeof v.webkitEnterFullscreen !== 'undefined');

		// W3C
		t.hasNativeFullscreen = (typeof v.requestFullscreen !== 'undefined');

		// webkit/firefox/IE11+
		t.hasWebkitNativeFullScreen = (typeof v.webkitRequestFullScreen !== 'undefined');
		t.hasMozNativeFullScreen = (typeof v.mozRequestFullScreen !== 'undefined');
		t.hasMsNativeFullScreen = (typeof v.msRequestFullscreen !== 'undefined');

		t.hasTrueNativeFullScreen = (t.hasWebkitNativeFullScreen || t.hasMozNativeFullScreen || t.hasMsNativeFullScreen);
		t.nativeFullScreenEnabled = t.hasTrueNativeFullScreen;

		// Enabled?
		if (t.hasMozNativeFullScreen) {
			t.nativeFullScreenEnabled = document.mozFullScreenEnabled;
		} else if (t.hasMsNativeFullScreen) {
			t.nativeFullScreenEnabled = document.msFullscreenEnabled;
		}

		if (t.isChrome) {
			t.hasiOSFullScreen = false;
		}

		if (t.hasTrueNativeFullScreen) {

			t.fullScreenEventName = '';
			if (t.hasWebkitNativeFullScreen) {
				t.fullScreenEventName = 'webkitfullscreenchange';

			} else if (t.hasMozNativeFullScreen) {
				t.fullScreenEventName = 'mozfullscreenchange';

			} else if (t.hasMsNativeFullScreen) {
				t.fullScreenEventName = 'MSFullscreenChange';
			}

			t.isFullScreen = function() {
				if (t.hasMozNativeFullScreen) {
					return d.mozFullScreen;

				} else if (t.hasWebkitNativeFullScreen) {
					return d.webkitIsFullScreen;

				} else if (t.hasMsNativeFullScreen) {
					return d.msFullscreenElement !== null;
				}
			}

			t.requestFullScreen = function(el) {

				if (t.hasWebkitNativeFullScreen) {
					el.webkitRequestFullScreen();

				} else if (t.hasMozNativeFullScreen) {
					el.mozRequestFullScreen();

				} else if (t.hasMsNativeFullScreen) {
					el.msRequestFullscreen();

				}
			}

			t.cancelFullScreen = function() {
				if (t.hasWebkitNativeFullScreen) {
					document.webkitCancelFullScreen();

				} else if (t.hasMozNativeFullScreen) {
					document.mozCancelFullScreen();

				} else if (t.hasMsNativeFullScreen) {
					document.msExitFullscreen();

				}
			}

		}


		// OS X 10.5 can't do this even if it says it can :(
		if (t.hasiOSFullScreen && ua.match(/mac os x 10_5/i)) {
			t.hasNativeFullScreen = false;
			t.hasiOSFullScreen = false;
		}

	}
};
mejs.MediaFeatures.init();

/*
extension methods to <video> or <audio> object to bring it into parity with PluginMediaElement (see below)
*/
mejs.HtmlMediaElement = {
	pluginType: 'native',
	isFullScreen: false,

	setCurrentTime: function (time) {
		this.currentTime = time;
	},

	setMuted: function (muted) {
		this.muted = muted;
	},

	setVolume: function (volume) {
		this.volume = volume;
	},

	// for parity with the plugin versions
	stop: function () {
		this.pause();
	},

	// This can be a url string
	// or an array [{src:'file.mp4',type:'video/mp4'},{src:'file.webm',type:'video/webm'}]
	setSrc: function (url) {
		
		// Fix for IE9 which can't set .src when there are <source> elements. Awesome, right?
		var 
			existingSources = this.getElementsByTagName('source');
		while (existingSources.length > 0){
			this.removeChild(existingSources[0]);
		}
	
		if (typeof url == 'string') {
			this.src = url;
		} else {
			var i, media;

			for (i=0; i<url.length; i++) {
				media = url[i];
				if (this.canPlayType(media.type)) {
					this.src = media.src;
					break;
				}
			}
		}
	},

	setVideoSize: function (width, height) {
		this.width = width;
		this.height = height;
	}
};

/*
Mimics the <video/audio> element by calling Flash's External Interface or Silverlights [ScriptableMember]
*/
mejs.PluginMediaElement = function (pluginid, pluginType, mediaUrl) {
	this.id = pluginid;
	this.pluginType = pluginType;
	this.src = mediaUrl;
	this.events = {};
	this.attributes = {};
};

// JavaScript values and ExternalInterface methods that match HTML5 video properties methods
// http://www.adobe.com/livedocs/flash/9.0/ActionScriptLangRefV3/fl/video/FLVPlayback.html
// http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html
mejs.PluginMediaElement.prototype = {

	// special
	pluginElement: null,
	pluginType: '',
	isFullScreen: false,

	// not implemented :(
	playbackRate: -1,
	defaultPlaybackRate: -1,
	seekable: [],
	played: [],

	// HTML5 read-only properties
	paused: true,
	ended: false,
	seeking: false,
	duration: 0,
	error: null,
	tagName: '',

	// HTML5 get/set properties, but only set (updated by event handlers)
	muted: false,
	volume: 1,
	currentTime: 0,

	// HTML5 methods
	play: function () {
		if (this.pluginApi != null) {
			if (this.pluginType == 'youtube' || this.pluginType == 'vimeo') {
				this.pluginApi.playVideo();
			} else {
				this.pluginApi.playMedia();
			}
			this.paused = false;
		}
	},
	load: function () {
		if (this.pluginApi != null) {
			if (this.pluginType == 'youtube' || this.pluginType == 'vimeo') {
			} else {
				this.pluginApi.loadMedia();
			}
			
			this.paused = false;
		}
	},
	pause: function () {
		if (this.pluginApi != null) {
			if (this.pluginType == 'youtube' || this.pluginType == 'vimeo') {
		        if( this.pluginApi.getPlayerState() == 1 ) {
				    this.pluginApi.pauseVideo();
                }
			} else {
				this.pluginApi.pauseMedia();
			}			
			
			
			this.paused = true;
		}
	},
	stop: function () {
		if (this.pluginApi != null) {
			if (this.pluginType == 'youtube' || this.pluginType == 'vimeo') {
				this.pluginApi.stopVideo();
			} else {
				this.pluginApi.stopMedia();
			}	
			this.paused = true;
		}
	},
	canPlayType: function(type) {
		var i,
			j,
			pluginInfo,
			pluginVersions = mejs.plugins[this.pluginType];

		for (i=0; i<pluginVersions.length; i++) {
			pluginInfo = pluginVersions[i];

			// test if user has the correct plugin version
			if (mejs.PluginDetector.hasPluginVersion(this.pluginType, pluginInfo.version)) {

				// test for plugin playback types
				for (j=0; j<pluginInfo.types.length; j++) {
					// find plugin that can play the type
					if (type == pluginInfo.types[j]) {
						return 'probably';
					}
				}
			}
		}

		return '';
	},
	
	positionFullscreenButton: function(x,y,visibleAndAbove) {
		if (this.pluginApi != null && this.pluginApi.positionFullscreenButton) {
			this.pluginApi.positionFullscreenButton(Math.floor(x),Math.floor(y),visibleAndAbove);
		}
	},
	
	hideFullscreenButton: function() {
		if (this.pluginApi != null && this.pluginApi.hideFullscreenButton) {
			this.pluginApi.hideFullscreenButton();
		}		
	},	
	

	// custom methods since not all JavaScript implementations support get/set

	// This can be a url string
	// or an array [{src:'file.mp4',type:'video/mp4'},{src:'file.webm',type:'video/webm'}]
	setSrc: function (url) {
		if (typeof url == 'string') {
			this.pluginApi.setSrc(mejs.Utility.absolutizeUrl(url));
			this.src = mejs.Utility.absolutizeUrl(url);
		} else {
			var i, media;

			for (i=0; i<url.length; i++) {
				media = url[i];
				if (this.canPlayType(media.type)) {
					this.pluginApi.setSrc(mejs.Utility.absolutizeUrl(media.src));
					this.src = mejs.Utility.absolutizeUrl(media.src);
					break;
				}
			}
		}

	},
	setCurrentTime: function (time) {
		if (this.pluginApi != null) {
			if (this.pluginType == 'youtube' || this.pluginType == 'vimeo') {
				this.pluginApi.seekTo(time);
			} else {
				this.pluginApi.setCurrentTime(time);
			}				
			
			
			
			this.currentTime = time;
		}
	},
	setVolume: function (volume) {
		if (this.pluginApi != null) {
			// same on YouTube and MEjs
			if (this.pluginType == 'youtube') {
				this.pluginApi.setVolume(volume * 100);
			} else {
				this.pluginApi.setVolume(volume);
			}
			this.volume = volume;
		}
	},
	setMuted: function (muted) {
		if (this.pluginApi != null) {
			if (this.pluginType == 'youtube') {
				if (muted) {
					this.pluginApi.mute();
				} else {
					this.pluginApi.unMute();
				}
				this.muted = muted;
				this.dispatchEvent({type:'volumechange'});
			} else {
				this.pluginApi.setMuted(muted);
			}
			this.muted = muted;
		}
	},

	// additional non-HTML5 methods
	setVideoSize: function (width, height) {
		
		//if (this.pluginType == 'flash' || this.pluginType == 'silverlight') {
			if (this.pluginElement && this.pluginElement.style) {
				this.pluginElement.style.width = width + 'px';
				this.pluginElement.style.height = height + 'px';
			}
			if (this.pluginApi != null && this.pluginApi.setVideoSize) {
				this.pluginApi.setVideoSize(width, height);
			}
		//}
	},

	setFullscreen: function (fullscreen) {
		if (this.pluginApi != null && this.pluginApi.setFullscreen) {
			this.pluginApi.setFullscreen(fullscreen);
		}
	},
	
	enterFullScreen: function() {
		if (this.pluginApi != null && this.pluginApi.setFullscreen) {
			this.setFullscreen(true);
		}		
		
	},
	
	exitFullScreen: function() {
		if (this.pluginApi != null && this.pluginApi.setFullscreen) {
			this.setFullscreen(false);
		}
	},	

	// start: fake events
	addEventListener: function (eventName, callback, bubble) {
		this.events[eventName] = this.events[eventName] || [];
		this.events[eventName].push(callback);
	},
	removeEventListener: function (eventName, callback) {
		if (!eventName) { this.events = {}; return true; }
		var callbacks = this.events[eventName];
		if (!callbacks) return true;
		if (!callback) { this.events[eventName] = []; return true; }
		for (var i = 0; i < callbacks.length; i++) {
			if (callbacks[i] === callback) {
				this.events[eventName].splice(i, 1);
				return true;
			}
		}
		return false;
	},	
	dispatchEvent: function (event) {
		var i,
			args,
			callbacks = this.events[event.type];

		if (callbacks) {
			for (i = 0; i < callbacks.length; i++) {
				callbacks[i].apply(this, [event]);
			}
		}
	},
	// end: fake events
	
	// fake DOM attribute methods
	hasAttribute: function(name){
		return (name in this.attributes);  
	},
	removeAttribute: function(name){
		delete this.attributes[name];
	},
	getAttribute: function(name){
		if (this.hasAttribute(name)) {
			return this.attributes[name];
		}
		return '';
	},
	setAttribute: function(name, value){
		this.attributes[name] = value;
	},

	remove: function() {
		mejs.Utility.removeSwf(this.pluginElement.id);
		mejs.MediaPluginBridge.unregisterPluginElement(this.pluginElement.id);
	}
};

/*
Default options
*/
mejs.MediaElementDefaults = {
	// allows testing on HTML5, flash, silverlight
	// auto: attempts to detect what the browser can do
	// auto_plugin: prefer plugins and then attempt native HTML5
	// native: forces HTML5 playback
	// shim: disallows HTML5, will attempt either Flash or Silverlight
	// none: forces fallback view
	mode: 'auto',
	// remove or reorder to change plugin priority and availability
	plugins: ['flash','silverlight','youtube','vimeo'],
	// shows debug errors on screen
	enablePluginDebug: false,
	// use plugin for browsers that have trouble with Basic Authentication on HTTPS sites
	httpsBasicAuthSite: false,
	// overrides the type specified, useful for dynamic instantiation
	type: '',
	// path to Flash and Silverlight plugins
	pluginPath: mejs.Utility.getScriptPath(['mediaelement.js','mediaelement.min.js','mediaelement-and-player.js','mediaelement-and-player.min.js']),
	// name of flash file
	flashName: 'flashmediaelement.swf',
	// streamer for RTMP streaming
	flashStreamer: '',
	// set to 'always' for CDN version
	flashScriptAccess: 'sameDomain',	
	// turns on the smoothing filter in Flash
	enablePluginSmoothing: false,
	// enabled pseudo-streaming (seek) on .mp4 files
	enablePseudoStreaming: false,
	// start query parameter sent to server for pseudo-streaming
	pseudoStreamingStartQueryParam: 'start',
	// name of silverlight file
	silverlightName: 'silverlightmediaelement.xap',
	// default if the <video width> is not specified
	defaultVideoWidth: 480,
	// default if the <video height> is not specified
	defaultVideoHeight: 270,
	// overrides <video width>
	pluginWidth: -1,
	// overrides <video height>
	pluginHeight: -1,
	// additional plugin variables in 'key=value' form
	pluginVars: [],	
	// rate in milliseconds for Flash and Silverlight to fire the timeupdate event
	// larger number is less accurate, but less strain on plugin->JavaScript bridge
	timerRate: 250,
	// initial volume for player
	startVolume: 0.8,
	success: function () { },
	error: function () { }
};

/*
Determines if a browser supports the <video> or <audio> element
and returns either the native element or a Flash/Silverlight version that
mimics HTML5 MediaElement
*/
mejs.MediaElement = function (el, o) {
	return mejs.HtmlMediaElementShim.create(el,o);
};

mejs.HtmlMediaElementShim = {

	create: function(el, o) {
		var
			options = {},
			htmlMediaElement = (typeof(el) == 'string') ? document.getElementById(el) : el,
			tagName = htmlMediaElement.tagName.toLowerCase(),
			isMediaTag = (tagName === 'audio' || tagName === 'video'),
			src = (isMediaTag) ? htmlMediaElement.getAttribute('src') : htmlMediaElement.getAttribute('href'),
			poster = htmlMediaElement.getAttribute('poster'),
			autoplay =  htmlMediaElement.getAttribute('autoplay'),
			preload =  htmlMediaElement.getAttribute('preload'),
			controls =  htmlMediaElement.getAttribute('controls'),
			playback,
			prop;

		// extend options
		for (prop in mejs.MediaElementDefaults) {
			options[prop] = mejs.MediaElementDefaults[prop];
		}
		for (prop in o) {
			options[prop] = o[prop];
		}		
		

		// clean up attributes
		src = 		(typeof src == 'undefined' 	|| src === null || src == '') ? null : src;		
		poster =	(typeof poster == 'undefined' 	|| poster === null) ? '' : poster;
		preload = 	(typeof preload == 'undefined' 	|| preload === null || preload === 'false') ? 'none' : preload;
		autoplay = 	!(typeof autoplay == 'undefined' || autoplay === null || autoplay === 'false');
		controls = 	!(typeof controls == 'undefined' || controls === null || controls === 'false');

		// test for HTML5 and plugin capabilities
		playback = this.determinePlayback(htmlMediaElement, options, mejs.MediaFeatures.supportsMediaTag, isMediaTag, src);
		playback.url = (playback.url !== null) ? mejs.Utility.absolutizeUrl(playback.url) : '';
        playback.scheme = mejs.Utility.determineScheme(playback.url);

		if (playback.method == 'native') {
			// second fix for android
			if (mejs.MediaFeatures.isBustedAndroid) {
				htmlMediaElement.src = playback.url;
				htmlMediaElement.addEventListener('click', function() {
					htmlMediaElement.play();
				}, false);
			}
		
			// add methods to native HTMLMediaElement
			return this.updateNative(playback, options, autoplay, preload);
		} else if (playback.method !== '') {
			// create plugin to mimic HTMLMediaElement
			
			return this.createPlugin( playback,  options, poster, autoplay, preload, controls);
		} else {
			// boo, no HTML5, no Flash, no Silverlight.
			this.createErrorMessage( playback, options, poster );
			
			return this;
		}
	},
	
	determinePlayback: function(htmlMediaElement, options, supportsMediaTag, isMediaTag, src) {
		var
			mediaFiles = [],
			i,
			j,
			k,
			l,
			n,
			type,
			result = { method: '', url: '', htmlMediaElement: htmlMediaElement, isVideo: (htmlMediaElement.tagName.toLowerCase() != 'audio'), scheme: ''},
			pluginName,
			pluginVersions,
			pluginInfo,
			dummy,
			media;
			
		// STEP 1: Get URL and type from <video src> or <source src>

		// supplied type overrides <video type> and <source type>
		if (typeof options.type != 'undefined' && options.type !== '') {
			
			// accept either string or array of types
			if (typeof options.type == 'string') {
				mediaFiles.push({type:options.type, url:src});
			} else {
				
				for (i=0; i<options.type.length; i++) {
					mediaFiles.push({type:options.type[i], url:src});
				}
			}

		// test for src attribute first
		} else if (src !== null) {
			type = this.formatType(src, htmlMediaElement.getAttribute('type'));
			mediaFiles.push({type:type, url:src});

		// then test for <source> elements
		} else {
			// test <source> types to see if they are usable
			for (i = 0; i < htmlMediaElement.childNodes.length; i++) {
				n = htmlMediaElement.childNodes[i];
				if (n.nodeType == 1 && n.tagName.toLowerCase() == 'source') {
					src = n.getAttribute('src');
					type = this.formatType(src, n.getAttribute('type'));
					media = n.getAttribute('media');

					if (!media || !window.matchMedia || (window.matchMedia && window.matchMedia(media).matches)) {
						mediaFiles.push({type:type, url:src});
					}
				}
			}
		}
		
		// in the case of dynamicly created players
		// check for audio types
		if (!isMediaTag && mediaFiles.length > 0 && mediaFiles[0].url !== null && this.getTypeFromFile(mediaFiles[0].url).indexOf('audio') > -1) {
			result.isVideo = false;
		}
		

		// STEP 2: Test for playback method
		
		// special case for Android which sadly doesn't implement the canPlayType function (always returns '')
		if (mejs.MediaFeatures.isBustedAndroid) {
			htmlMediaElement.canPlayType = function(type) {
				return (type.match(/video\/(mp4|m4v)/gi) !== null) ? 'maybe' : '';
			};
		}		
		
		// special case for Chromium to specify natively supported video codecs (i.e. WebM and Theora) 
		if (mejs.MediaFeatures.isChromium) { 
			htmlMediaElement.canPlayType = function(type) { 
				return (type.match(/video\/(webm|ogv|ogg)/gi) !== null) ? 'maybe' : ''; 
			}; 
		}

		// test for native playback first
		if (supportsMediaTag && (options.mode === 'auto' || options.mode === 'auto_plugin' || options.mode === 'native')  && !(mejs.MediaFeatures.isBustedNativeHTTPS && options.httpsBasicAuthSite === true)) {
						
			if (!isMediaTag) {

				// create a real HTML5 Media Element 
				dummy = document.createElement( result.isVideo ? 'video' : 'audio');			
				htmlMediaElement.parentNode.insertBefore(dummy, htmlMediaElement);
				htmlMediaElement.style.display = 'none';
				
				// use this one from now on
				result.htmlMediaElement = htmlMediaElement = dummy;
			}
				
			for (i=0; i<mediaFiles.length; i++) {
				// normal check
				if (mediaFiles[i].type == "video/m3u8" || htmlMediaElement.canPlayType(mediaFiles[i].type).replace(/no/, '') !== ''
					// special case for Mac/Safari 5.0.3 which answers '' to canPlayType('audio/mp3') but 'maybe' to canPlayType('audio/mpeg')
					|| htmlMediaElement.canPlayType(mediaFiles[i].type.replace(/mp3/,'mpeg')).replace(/no/, '') !== ''
					// special case for m4a supported by detecting mp4 support
					|| htmlMediaElement.canPlayType(mediaFiles[i].type.replace(/m4a/,'mp4')).replace(/no/, '') !== '') {
					result.method = 'native';
					result.url = mediaFiles[i].url;
					break;
				}
			}			
			
			if (result.method === 'native') {
				if (result.url !== null) {
					htmlMediaElement.src = result.url;
				}
			
				// if `auto_plugin` mode, then cache the native result but try plugins.
				if (options.mode !== 'auto_plugin') {
					return result;
				}
			}
		}

		// if native playback didn't work, then test plugins
		if (options.mode === 'auto' || options.mode === 'auto_plugin' || options.mode === 'shim') {
			for (i=0; i<mediaFiles.length; i++) {
				type = mediaFiles[i].type;

				// test all plugins in order of preference [silverlight, flash]
				for (j=0; j<options.plugins.length; j++) {

					pluginName = options.plugins[j];
			
					// test version of plugin (for future features)
					pluginVersions = mejs.plugins[pluginName];				
					
					for (k=0; k<pluginVersions.length; k++) {
						pluginInfo = pluginVersions[k];
					
						// test if user has the correct plugin version
						
						// for youtube/vimeo
						if (pluginInfo.version == null || 
							
							mejs.PluginDetector.hasPluginVersion(pluginName, pluginInfo.version)) {

							// test for plugin playback types
							for (l=0; l<pluginInfo.types.length; l++) {
								// find plugin that can play the type
								if (type.toLowerCase() == pluginInfo.types[l].toLowerCase()) {
									result.method = pluginName;
									result.url = mediaFiles[i].url;
									return result;
								}
							}
						}
					}
				}
			}
		}
		
		// at this point, being in 'auto_plugin' mode implies that we tried plugins but failed.
		// if we have native support then return that.
		if (options.mode === 'auto_plugin' && result.method === 'native') {
			return result;
		}

		// what if there's nothing to play? just grab the first available
		if (result.method === '' && mediaFiles.length > 0) {
			result.url = mediaFiles[0].url;
		}

		return result;
	},

	formatType: function(url, type) {
		// if no type is supplied, fake it with the extension
		if (url && !type) {		
			return this.getTypeFromFile(url);
		} else {
			// only return the mime part of the type in case the attribute contains the codec
			// see http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#the-source-element
			// `video/mp4; codecs="avc1.42E01E, mp4a.40.2"` becomes `video/mp4`
			
			if (type && ~type.indexOf(';')) {
				return type.substr(0, type.indexOf(';')); 
			} else {
				return type;
			}
		}
	},
	
	getTypeFromFile: function(url) {
		url = url.split('?')[0];
		var
			ext = url.substring(url.lastIndexOf('.') + 1).toLowerCase(),
			av = /(mp4|m4v|ogg|ogv|m3u8|webm|webmv|flv|wmv|mpeg|mov)/gi.test(ext) ? 'video/' : 'audio/';
		return this.getTypeFromExtension(ext, av);
	},
	
	getTypeFromExtension: function(ext, av) {
		av = av || '';
		
		switch (ext) {
			case 'mp4':
			case 'm4v':
			case 'm4a':
			case 'f4v':
			case 'f4a':
				return av + 'mp4';
			case 'flv':
				return av + 'x-flv';
			case 'webm':
			case 'webma':
			case 'webmv':	
				return av + 'webm';
			case 'ogg':
			case 'oga':
			case 'ogv':	
				return av + 'ogg';
			case 'm3u8':
				return 'application/x-mpegurl';
			case 'ts':
				return av + 'mp2t';
			default:
				return av + ext;
		}
	},

	createErrorMessage: function(playback, options, poster) {
		var 
			htmlMediaElement = playback.htmlMediaElement,
			errorContainer = document.createElement('div'),
			errorContent = options.customError;
			
		errorContainer.className = 'me-cannotplay';

		try {
			errorContainer.style.width = htmlMediaElement.width + 'px';
			errorContainer.style.height = htmlMediaElement.height + 'px';
		} catch (e) {}

		if (!errorContent) {
			errorContent = '<a href="' + playback.url + '">';

			if (poster !== '') {
				errorContent += '<img src="' + poster + '" width="100%" height="100%" alt="" />';
			}

			errorContent += '<span>' + mejs.i18n.t('Download File') + '</span></a>';
		}

		errorContainer.innerHTML = errorContent;

		htmlMediaElement.parentNode.insertBefore(errorContainer, htmlMediaElement);
		htmlMediaElement.style.display = 'none';

		options.error(htmlMediaElement);
	},

	createPlugin:function(playback, options, poster, autoplay, preload, controls) {
		var 
			htmlMediaElement = playback.htmlMediaElement,
			width = 1,
			height = 1,
			pluginid = 'me_' + playback.method + '_' + (mejs.meIndex++),
			pluginMediaElement = new mejs.PluginMediaElement(pluginid, playback.method, playback.url),
			container = document.createElement('div'),
			specialIEContainer,
			node,
			initVars;

		// copy tagName from html media element
		pluginMediaElement.tagName = htmlMediaElement.tagName

		// copy attributes from html media element to plugin media element
		for (var i = 0; i < htmlMediaElement.attributes.length; i++) {
			var attribute = htmlMediaElement.attributes[i];
			if (attribute.specified) {
				pluginMediaElement.setAttribute(attribute.name, attribute.value);
			}
		}

		// check for placement inside a <p> tag (sometimes WYSIWYG editors do this)
		node = htmlMediaElement.parentNode;

		while (node !== null && node.tagName != null && node.tagName.toLowerCase() !== 'body' && 
				node.parentNode != null && node.parentNode.tagName != null && node.parentNode.constructor != null && node.parentNode.constructor.name === "ShadowRoot") {
			if (node.parentNode.tagName.toLowerCase() === 'p') {
				node.parentNode.parentNode.insertBefore(node, node.parentNode);
				break;
			}
			node = node.parentNode;
		}

		if (playback.isVideo) {
			width = (options.pluginWidth > 0) ? options.pluginWidth : (options.videoWidth > 0) ? options.videoWidth : (htmlMediaElement.getAttribute('width') !== null) ? htmlMediaElement.getAttribute('width') : options.defaultVideoWidth;
			height = (options.pluginHeight > 0) ? options.pluginHeight : (options.videoHeight > 0) ? options.videoHeight : (htmlMediaElement.getAttribute('height') !== null) ? htmlMediaElement.getAttribute('height') : options.defaultVideoHeight;
		
			// in case of '%' make sure it's encoded
			width = mejs.Utility.encodeUrl(width);
			height = mejs.Utility.encodeUrl(height);
		
		} else {
			if (options.enablePluginDebug) {
				width = 320;
				height = 240;
			}
		}

		// register plugin
		pluginMediaElement.success = options.success;
		
		// add container (must be added to DOM before inserting HTML for IE)
		container.className = 'me-plugin';
		container.id = pluginid + '_container';
		
		if (playback.isVideo) {
				htmlMediaElement.parentNode.insertBefore(container, htmlMediaElement);
		} else {
				document.body.insertBefore(container, document.body.childNodes[0]);
		}
		
		if (playback.method === 'flash' || playback.method === 'silverlight') {

			// flash/silverlight vars
			initVars = [
				'id=' + pluginid,
				'isvideo=' + ((playback.isVideo) ? "true" : "false"),
				'autoplay=' + ((autoplay) ? "true" : "false"),
				'preload=' + preload,
				'width=' + width,
				'startvolume=' + options.startVolume,
				'timerrate=' + options.timerRate,
				'flashstreamer=' + options.flashStreamer,
				'height=' + height,
				'pseudostreamstart=' + options.pseudoStreamingStartQueryParam];
	
			if (playback.url !== null) {
				if (playback.method == 'flash') {
					initVars.push('file=' + mejs.Utility.encodeUrl(playback.url));
				} else {
					initVars.push('file=' + playback.url);
				}
			}
			if (options.enablePluginDebug) {
				initVars.push('debug=true');
			}
			if (options.enablePluginSmoothing) {
				initVars.push('smoothing=true');
			}
			if (options.enablePseudoStreaming) {
				initVars.push('pseudostreaming=true');
			}
			if (controls) {
				initVars.push('controls=true'); // shows controls in the plugin if desired
			}
			if (options.pluginVars) {
				initVars = initVars.concat(options.pluginVars);
			}		
			
			// call from plugin
			window[pluginid + '_init'] = function() {
				switch (pluginMediaElement.pluginType) {
					case 'flash':
						pluginMediaElement.pluginElement = pluginMediaElement.pluginApi = document.getElementById(pluginid);
						break;
					case 'silverlight':
						pluginMediaElement.pluginElement = document.getElementById(pluginMediaElement.id);
						pluginMediaElement.pluginApi = pluginMediaElement.pluginElement.Content.MediaElementJS;
						break;
				}
	
				if (pluginMediaElement.pluginApi != null && pluginMediaElement.success) {
					pluginMediaElement.success(pluginMediaElement, htmlMediaElement);
				}
			}
			
			// event call from plugin
			window[pluginid + '_event'] = function(eventName, values) {
		
				var
					e,
					i,
					bufferedTime;
		        
				// fake event object to mimic real HTML media event.
				e = {
					type: eventName,
					target: pluginMediaElement
				};
		
				// attach all values to element and event object
				for (i in values) {
					pluginMediaElement[i] = values[i];
					e[i] = values[i];
				}
		
				// fake the newer W3C buffered TimeRange (loaded and total have been removed)
				bufferedTime = values.bufferedTime || 0;
		
				e.target.buffered = e.buffered = {
					start: function(index) {
						return 0;
					},
					end: function (index) {
						return bufferedTime;
					},
					length: 1
				};
		
				pluginMediaElement.dispatchEvent(e);
			}			
			
			
		}

		switch (playback.method) {
			case 'silverlight':
				container.innerHTML =
'<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" id="' + pluginid + '" name="' + pluginid + '" width="' + width + '" height="' + height + '" class="mejs-shim">' +
'<param name="initParams" value="' + initVars.join(',') + '" />' +
'<param name="windowless" value="true" />' +
'<param name="background" value="black" />' +
'<param name="minRuntimeVersion" value="3.0.0.0" />' +
'<param name="autoUpgrade" value="true" />' +
'<param name="source" value="' + options.pluginPath + options.silverlightName + '" />' +
'</object>';
					break;

			case 'flash':

				if (mejs.MediaFeatures.isIE) {
					specialIEContainer = document.createElement('div');
					container.appendChild(specialIEContainer);
					specialIEContainer.outerHTML =
'<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="//download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab" ' +
'id="' + pluginid + '" width="' + width + '" height="' + height + '" class="mejs-shim">' +
'<param name="movie" value="' + options.pluginPath + options.flashName + '?' + (new Date().getTime()) + '" />' +
'<param name="flashvars" value="' + initVars.join('&amp;') + '" />' +
'<param name="quality" value="high" />' +
'<param name="bgcolor" value="#000000" />' +
'<param name="wmode" value="transparent" />' +
'<param name="allowScriptAccess" value="' + options.flashScriptAccess + '" />' +
'<param name="allowFullScreen" value="true" />' +
'<param name="scale" value="default" />' + 
'</object>';

				} else {

					container.innerHTML =
'<embed id="' + pluginid + '" name="' + pluginid + '" ' +
'play="true" ' +
'loop="false" ' +
'quality="high" ' +
'bgcolor="#000000" ' +
'wmode="transparent" ' +
'allowScriptAccess="' + options.flashScriptAccess + '" ' +
'allowFullScreen="true" ' +
'type="application/x-shockwave-flash" pluginspage="//www.macromedia.com/go/getflashplayer" ' +
'src="' + options.pluginPath + options.flashName + '" ' +
'flashvars="' + initVars.join('&') + '" ' +
'width="' + width + '" ' +
'height="' + height + '" ' +
'scale="default"' + 
'class="mejs-shim"></embed>';
				}
				break;
			
			case 'youtube':
			
				
				var videoId;
				// youtu.be url from share button
				if (playback.url.lastIndexOf("youtu.be") != -1) {
					videoId = playback.url.substr(playback.url.lastIndexOf('/')+1);
					if (videoId.indexOf('?') != -1) {
						videoId = videoId.substr(0, videoId.indexOf('?'));
					}
				}
				else {
					videoId = playback.url.substr(playback.url.lastIndexOf('=')+1);
				}
				youtubeSettings = {
						container: container,
						containerId: container.id,
						pluginMediaElement: pluginMediaElement,
						pluginId: pluginid,
						videoId: videoId,
						height: height,
						width: width,
                        scheme: playback.scheme
					};				
				
				// favor iframe version of YouTube
				if (window.postMessage) {
					mejs.YouTubeApi.enqueueIframe(youtubeSettings);		
				} else if (mejs.PluginDetector.hasPluginVersion('flash', [10,0,0]) ) {
					mejs.YouTubeApi.createFlash(youtubeSettings, options);
				}
				
				break;
			
			// DEMO Code. Does NOT work.
			case 'vimeo':
				var player_id = pluginid + "_player";
				pluginMediaElement.vimeoid = playback.url.substr(playback.url.lastIndexOf('/')+1);
				
				container.innerHTML ='<iframe src="' + playback.scheme + 'player.vimeo.com/video/' + pluginMediaElement.vimeoid + '?api=1&portrait=0&byline=0&title=0&player_id=' + player_id + '" width="' + width +'" height="' + height +'" frameborder="0" class="mejs-shim" id="' + player_id + '" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>';
				if (typeof($f) == 'function') { // froogaloop available
					var player = $f(container.childNodes[0]),
						playerState = -1;
					
					player.addEvent('ready', function() {
		
						player.playVideo = function() {
							player.api( 'play' );
						} 
						player.stopVideo = function() {
							player.api( 'unload' );
						} 
						player.pauseVideo = function() {
							player.api( 'pause' );
						} 
						player.seekTo = function( seconds ) {
							player.api( 'seekTo', seconds );
						}
						player.setVolume = function( volume ) {
							player.api( 'setVolume', volume );
						}
						player.setMuted = function( muted ) {
							if( muted ) {
								player.lastVolume = player.api( 'getVolume' );
								player.api( 'setVolume', 0 );
							} else {
								player.api( 'setVolume', player.lastVolume );
								delete player.lastVolume;
							}
						}
						// parity with YT player
						player.getPlayerState = function() {
							return playerState;
						}			

						function createEvent(player, pluginMediaElement, eventName, e) {
							var event = {
								type: eventName,
								target: pluginMediaElement
							};
							if (eventName == 'timeupdate') {
								pluginMediaElement.currentTime = event.currentTime = e.seconds;
								pluginMediaElement.duration = event.duration = e.duration;
							}
							pluginMediaElement.dispatchEvent(event);
						}

						player.addEvent('play', function() {
							playerState = 1;
							createEvent(player, pluginMediaElement, 'play');
							createEvent(player, pluginMediaElement, 'playing');
						});

						player.addEvent('pause', function() {
							playerState = 2;							
							createEvent(player, pluginMediaElement, 'pause');
						});

						player.addEvent('finish', function() {
							playerState = 0;							
							createEvent(player, pluginMediaElement, 'ended');
						});

						player.addEvent('playProgress', function(e) {
							createEvent(player, pluginMediaElement, 'timeupdate', e);
						});
						
						player.addEvent('seek', function(e) {
							playerState = 3;
							createEvent(player, pluginMediaElement, 'seeked', e);
						});	
						
						player.addEvent('loadProgress', function(e) {
							playerState = 3;
							createEvent(player, pluginMediaElement, 'progress', e);
						});												

						pluginMediaElement.pluginElement = container;
						pluginMediaElement.pluginApi = player;

						pluginMediaElement.success(pluginMediaElement, pluginMediaElement.pluginElement);						
					});
				}
				else {
					console.warn("You need to include froogaloop for vimeo to work");
				}
				break;			
		}
		// hide original element
		htmlMediaElement.style.display = 'none';
		// prevent browser from autoplaying when using a plugin
		htmlMediaElement.removeAttribute('autoplay');
		
		return pluginMediaElement;
	},

	updateNative: function(playback, options, autoplay, preload) {
		
		var htmlMediaElement = playback.htmlMediaElement,
			m;
		
		
		// add methods to video object to bring it into parity with Flash Object
		for (m in mejs.HtmlMediaElement) {
			htmlMediaElement[m] = mejs.HtmlMediaElement[m];
		}

		/*
		Chrome now supports preload="none"
		if (mejs.MediaFeatures.isChrome) {
		
			// special case to enforce preload attribute (Chrome doesn't respect this)
			if (preload === 'none' && !autoplay) {
			
				// forces the browser to stop loading (note: fails in IE9)
				htmlMediaElement.src = '';
				htmlMediaElement.load();
				htmlMediaElement.canceledPreload = true;

				htmlMediaElement.addEventListener('play',function() {
					if (htmlMediaElement.canceledPreload) {
						htmlMediaElement.src = playback.url;
						htmlMediaElement.load();
						htmlMediaElement.play();
						htmlMediaElement.canceledPreload = false;
					}
				}, false);
			// for some reason Chrome forgets how to autoplay sometimes.
			} else if (autoplay) {
				htmlMediaElement.load();
				htmlMediaElement.play();
			}
		}
		*/

		// fire success code
		options.success(htmlMediaElement, htmlMediaElement);
		
		return htmlMediaElement;
	}
};

/*
 - test on IE (object vs. embed)
 - determine when to use iframe (Firefox, Safari, Mobile) vs. Flash (Chrome, IE)
 - fullscreen?
*/

// YouTube Flash and Iframe API
mejs.YouTubeApi = {
	isIframeStarted: false,
	isIframeLoaded: false,
	loadIframeApi: function(yt) {
		if (!this.isIframeStarted) {
			var tag = document.createElement('script');
			tag.src = yt.scheme + "www.youtube.com/player_api";
			var firstScriptTag = document.getElementsByTagName('script')[0];
			firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
			this.isIframeStarted = true;
		}
	},
	iframeQueue: [],
	enqueueIframe: function(yt) {
		
		if (this.isLoaded) {
			this.createIframe(yt);
		} else {
			this.loadIframeApi(yt);
			this.iframeQueue.push(yt);
		}
	},
	createIframe: function(settings) {
		
		var
		pluginMediaElement = settings.pluginMediaElement,	
		player = new YT.Player(settings.containerId, {
			height: settings.height,
			width: settings.width,
			videoId: settings.videoId,
			playerVars: {controls:0,wmode:'transparent'},
			events: {
				'onReady': function() {
					
					// wrapper to match
					player.setVideoSize = function(width, height) {
						player.setSize(width, height);
					}
					
					// hook up iframe object to MEjs
					settings.pluginMediaElement.pluginApi = player;
					settings.pluginMediaElement.pluginElement = document.getElementById(settings.containerId);
					
					// init mejs
					pluginMediaElement.success(pluginMediaElement, pluginMediaElement.pluginElement);
					
					// create timer
					setInterval(function() {
						mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'timeupdate');
					}, 250);					
				},
				'onStateChange': function(e) {
					
					mejs.YouTubeApi.handleStateChange(e.data, player, pluginMediaElement);
					
				}
			}
		});
	},
	
	createEvent: function (player, pluginMediaElement, eventName) {
		var event = {
			type: eventName,
			target: pluginMediaElement
		};

		if (player && player.getDuration) {
			
			// time 
			pluginMediaElement.currentTime = event.currentTime = player.getCurrentTime();
			pluginMediaElement.duration = event.duration = player.getDuration();
			
			// state
			event.paused = pluginMediaElement.paused;
			event.ended = pluginMediaElement.ended;			
			
			// sound
			event.muted = player.isMuted();
			event.volume = player.getVolume() / 100;
			
			// progress
			event.bytesTotal = player.getVideoBytesTotal();
			event.bufferedBytes = player.getVideoBytesLoaded();
			
			// fake the W3C buffered TimeRange
			var bufferedTime = event.bufferedBytes / event.bytesTotal * event.duration;
			
			event.target.buffered = event.buffered = {
				start: function(index) {
					return 0;
				},
				end: function (index) {
					return bufferedTime;
				},
				length: 1
			};

		}
		
		// send event up the chain
		pluginMediaElement.dispatchEvent(event);
	},	
	
	iFrameReady: function() {
		
		this.isLoaded = true;
		this.isIframeLoaded = true;
		
		while (this.iframeQueue.length > 0) {
			var settings = this.iframeQueue.pop();
			this.createIframe(settings);
		}	
	},
	
	// FLASH!
	flashPlayers: {},
	createFlash: function(settings) {
		
		this.flashPlayers[settings.pluginId] = settings;
		
		/*
		settings.container.innerHTML =
			'<object type="application/x-shockwave-flash" id="' + settings.pluginId + '" data="' + settings.scheme + 'www.youtube.com/apiplayer?enablejsapi=1&amp;playerapiid=' + settings.pluginId  + '&amp;version=3&amp;autoplay=0&amp;controls=0&amp;modestbranding=1&loop=0" ' +
				'width="' + settings.width + '" height="' + settings.height + '" style="visibility: visible; " class="mejs-shim">' +
				'<param name="allowScriptAccess" value="sameDomain">' +
				'<param name="wmode" value="transparent">' +
			'</object>';
		*/

		var specialIEContainer,
			youtubeUrl = settings.scheme + 'www.youtube.com/apiplayer?enablejsapi=1&amp;playerapiid=' + settings.pluginId  + '&amp;version=3&amp;autoplay=0&amp;controls=0&amp;modestbranding=1&loop=0';
			
		if (mejs.MediaFeatures.isIE) {
			
			specialIEContainer = document.createElement('div');
			settings.container.appendChild(specialIEContainer);
			specialIEContainer.outerHTML = '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="' + settings.scheme + 'download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab" ' +
'id="' + settings.pluginId + '" width="' + settings.width + '" height="' + settings.height + '" class="mejs-shim">' +
	'<param name="movie" value="' + youtubeUrl + '" />' +
	'<param name="wmode" value="transparent" />' +
	'<param name="allowScriptAccess" value="' + options.flashScriptAccess + '" />' +
	'<param name="allowFullScreen" value="true" />' +
'</object>';
		} else {
		settings.container.innerHTML =
			'<object type="application/x-shockwave-flash" id="' + settings.pluginId + '" data="' + youtubeUrl + '" ' +
				'width="' + settings.width + '" height="' + settings.height + '" style="visibility: visible; " class="mejs-shim">' +
				'<param name="allowScriptAccess" value="' + options.flashScriptAccess + '">' +
				'<param name="wmode" value="transparent">' +
			'</object>';
		}		
		
	},
	
	flashReady: function(id) {
		var
			settings = this.flashPlayers[id],
			player = document.getElementById(id),
			pluginMediaElement = settings.pluginMediaElement;
		
		// hook up and return to MediaELementPlayer.success	
		pluginMediaElement.pluginApi = 
		pluginMediaElement.pluginElement = player;
		
		settings.success(pluginMediaElement, pluginMediaElement.pluginElement);
		
		// load the youtube video
		player.cueVideoById(settings.videoId);
		
		var callbackName = settings.containerId + '_callback';
		
		window[callbackName] = function(e) {
			mejs.YouTubeApi.handleStateChange(e, player, pluginMediaElement);
		}
		
		player.addEventListener('onStateChange', callbackName);
		
		setInterval(function() {
			mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'timeupdate');
		}, 250);
		
		mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'canplay');
	},
	
	handleStateChange: function(youTubeState, player, pluginMediaElement) {
		switch (youTubeState) {
			case -1: // not started
				pluginMediaElement.paused = true;
				pluginMediaElement.ended = true;
				mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'loadedmetadata');
				//createYouTubeEvent(player, pluginMediaElement, 'loadeddata');
				break;
			case 0:
				pluginMediaElement.paused = false;
				pluginMediaElement.ended = true;
				mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'ended');
				break;
			case 1:
				pluginMediaElement.paused = false;
				pluginMediaElement.ended = false;				
				mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'play');
				mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'playing');
				break;
			case 2:
				pluginMediaElement.paused = true;
				pluginMediaElement.ended = false;				
				mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'pause');
				break;
			case 3: // buffering
				mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'progress');
				break;
			case 5:
				// cued?
				break;						
			
		}			
		
	}
}
// IFRAME
window.onYouTubePlayerAPIReady = function() {
	mejs.YouTubeApi.iFrameReady();
};
// FLASH
window.onYouTubePlayerReady = function(id) {
	mejs.YouTubeApi.flashReady(id);
};

window.mejs = mejs;
window.MediaElement = mejs.MediaElement;

/*
 * Adds Internationalization and localization to mediaelement.
 *
 * This file does not contain translations, you have to add them manually.
 * The schema is always the same: me-i18n-locale-[IETF-language-tag].js
 *
 * Examples are provided both for german and chinese translation.
 *
 *
 * What is the concept beyond i18n?
 *   http://en.wikipedia.org/wiki/Internationalization_and_localization
 *
 * What langcode should i use?
 *   http://en.wikipedia.org/wiki/IETF_language_tag
 *   https://tools.ietf.org/html/rfc5646
 *
 *
 * License?
 *
 *   The i18n file uses methods from the Drupal project (drupal.js):
 *     - i18n.methods.t() (modified)
 *     - i18n.methods.checkPlain() (full copy)
 *
 *   The Drupal project is (like mediaelementjs) licensed under GPLv2.
 *    - http://drupal.org/licensing/faq/#q1
 *    - https://github.com/johndyer/mediaelement
 *    - http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 *
 *
 * @author
 *   Tim Latz (latz.tim@gmail.com)
 *
 *
 * @params
 *  - context - document, iframe ..
 *  - exports - CommonJS, window ..
 *
 */
;(function(context, exports, undefined) {
    "use strict";

    var i18n = {
        "locale": {
            // Ensure previous values aren't overwritten.
            "language" : (exports.i18n && exports.i18n.locale.language) || '',
            "strings" : (exports.i18n && exports.i18n.locale.strings) || {}
        },
        "ietf_lang_regex" : /^(x\-)?[a-z]{2,}(\-\w{2,})?(\-\w{2,})?$/,
        "methods" : {}
    };
// start i18n


    /**
     * Get language, fallback to browser's language if empty
     *
     * IETF: RFC 5646, https://tools.ietf.org/html/rfc5646
     * Examples: en, zh-CN, cmn-Hans-CN, sr-Latn-RS, es-419, x-private
     */
    i18n.getLanguage = function () {
        var language = i18n.locale.language || window.navigator.userLanguage || window.navigator.language;
        return i18n.ietf_lang_regex.exec(language) ? language : null;

        //(WAS: convert to iso 639-1 (2-letters, lower case))
        //return language.substr(0, 2).toLowerCase();
    };

    // i18n fixes for compatibility with WordPress
    if ( typeof mejsL10n != 'undefined' ) {
        i18n.locale.language = mejsL10n.language;
    }



    /**
     * Encode special characters in a plain-text string for display as HTML.
     */
    i18n.methods.checkPlain = function (str) {
        var character, regex,
        replace = {
            '&': '&amp;',
            '"': '&quot;',
            '<': '&lt;',
            '>': '&gt;'
        };
        str = String(str);
        for (character in replace) {
            if (replace.hasOwnProperty(character)) {
                regex = new RegExp(character, 'g');
                str = str.replace(regex, replace[character]);
            }
        }
        return str;
    };

    /**
     * Translate strings to the page language or a given language.
     *
     *
     * @param str
     *   A string containing the English string to translate.
     *
     * @param options
     *   - 'context' (defaults to the default context): The context the source string
     *     belongs to.
     *
     * @return
     *   The translated string, escaped via i18n.methods.checkPlain()
     */
    i18n.methods.t = function (str, options) {

        // Fetch the localized version of the string.
        if (i18n.locale.strings && i18n.locale.strings[options.context] && i18n.locale.strings[options.context][str]) {
            str = i18n.locale.strings[options.context][str];
        }

        return i18n.methods.checkPlain(str);
    };


    /**
     * Wrapper for i18n.methods.t()
     *
     * @see i18n.methods.t()
     * @throws InvalidArgumentException
     */
    i18n.t = function(str, options) {

        if (typeof str === 'string' && str.length > 0) {

            // check every time due language can change for
            // different reasons (translation, lang switcher ..)
            var language = i18n.getLanguage();

            options = options || {
                "context" : language
            };

            return i18n.methods.t(str, options);
        }
        else {
            throw {
                "name" : 'InvalidArgumentException',
                "message" : 'First argument is either not a string or empty.'
            };
        }
    };

// end i18n
    exports.i18n = i18n;
}(document, mejs));

// i18n fixes for compatibility with WordPress
;(function(exports, undefined) {

    "use strict";

    if ( typeof mejsL10n != 'undefined' ) {
        exports[mejsL10n.language] = mejsL10n.strings;
    }

}(mejs.i18n.locale.strings));

/*!
 *
 * MediaElementPlayer
 * http://mediaelementjs.com/
 *
 * Creates a controller bar for HTML5 <video> add <audio> tags
 * using jQuery and MediaElement.js (HTML5 Flash/Silverlight wrapper)
 *
 * Copyright 2010-2013, John Dyer (http://j.hn/)
 * License: MIT
 *
 */
if (typeof jQuery != 'undefined') {
	mejs.$ = jQuery;
} else if (typeof Zepto != 'undefined') {
	mejs.$ = Zepto;

	// define `outerWidth` method which has not been realized in Zepto
	Zepto.fn.outerWidth = function(includeMargin) {
		var width = $(this).width();
		if (includeMargin) {
			width += parseInt($(this).css('margin-right'), 10);
			width += parseInt($(this).css('margin-left'), 10);
		}
		return width
	}

} else if (typeof ender != 'undefined') {
	mejs.$ = ender;
}
(function ($) {

	// default player values
	mejs.MepDefaults = {
		// url to poster (to fix iOS 3.x)
		poster: '',
		// When the video is ended, we can show the poster.
		showPosterWhenEnded: false,
		// default if the <video width> is not specified
		defaultVideoWidth: 480,
		// default if the <video height> is not specified
		defaultVideoHeight: 270,
		// if set, overrides <video width>
		videoWidth: -1,
		// if set, overrides <video height>
		videoHeight: -1,
		// default if the user doesn't specify
		defaultAudioWidth: 400,
		// default if the user doesn't specify
		defaultAudioHeight: 30,

		// default amount to move back when back key is pressed
		defaultSeekBackwardInterval: function(media) {
			return (media.duration * 0.05);
		},
		// default amount to move forward when forward key is pressed
		defaultSeekForwardInterval: function(media) {
			return (media.duration * 0.05);
		},

		// set dimensions via JS instead of CSS
		setDimensions: true,

		// width of audio player
		audioWidth: -1,
		// height of audio player
		audioHeight: -1,
		// initial volume when the player starts (overrided by user cookie)
		startVolume: 0.8,
		// useful for <audio> player loops
		loop: false,
		// rewind to beginning when media ends
                autoRewind: true,
		// resize to media dimensions
		enableAutosize: true,

		/*
		 * Time format to use. Default: 'mm:ss'
		 * Supported units:
		 *   h: hour
		 *   m: minute
		 *   s: second
		 *   f: frame count
		 * When using 'hh', 'mm', 'ss' or 'ff' we always display 2 digits.
		 * If you use 'h', 'm', 's' or 'f' we display 1 digit if possible.
		 *
		 * Example to display 75 seconds:
		 * Format 'mm:ss': 01:15
		 * Format 'm:ss': 1:15
		 * Format 'm:s': 1:15
		 */
		timeFormat: '',
		// forces the hour marker (##:00:00)
		alwaysShowHours: false,
		// show framecount in timecode (##:00:00:00)
		showTimecodeFrameCount: false,
		// used when showTimecodeFrameCount is set to true
		framesPerSecond: 25,

		// automatically calculate the width of the progress bar based on the sizes of other elements
		autosizeProgress : true,
		// Hide controls when playing and mouse is not over the video
		alwaysShowControls: false,
		// Display the video control
		hideVideoControlsOnLoad: false,
		// Enable click video element to toggle play/pause
		clickToPlayPause: true,
		// force iPad's native controls
		iPadUseNativeControls: false,
		// force iPhone's native controls
		iPhoneUseNativeControls: false,
		// force Android's native controls
		AndroidUseNativeControls: false,
		// features to show
		features: ['playpause','current','progress','duration','tracks','volume','fullscreen'],
		// only for dynamic
		isVideo: true,

		// turns keyboard support on and off for this instance
		enableKeyboard: true,

		// whenthis player starts, it will pause other players
		pauseOtherPlayers: true,

		// array of keyboard actions such as play pause
		keyActions: [
				{
						keys: [
								32, // SPACE
								179 // GOOGLE play/pause button
							  ],
						action: function(player, media) {
								if (media.paused || media.ended) {
										media.play();
								} else {
										media.pause();
								}
						}
				},
				{
						keys: [38], // UP
						action: function(player, media) {
								player.container.find('.mejs-volume-slider').css('display','block');
								if (player.isVideo) {
										player.showControls();
										player.startControlsTimer();
								}

								var newVolume = Math.min(media.volume + 0.1, 1);
								media.setVolume(newVolume);
						}
				},
				{
						keys: [40], // DOWN
						action: function(player, media) {
								player.container.find('.mejs-volume-slider').css('display','block');
								if (player.isVideo) {
										player.showControls();
										player.startControlsTimer();
								}

								var newVolume = Math.max(media.volume - 0.1, 0);
								media.setVolume(newVolume);
						}
				},
				{
						keys: [
								37, // LEFT
								227 // Google TV rewind
						],
						action: function(player, media) {
								if (!isNaN(media.duration) && media.duration > 0) {
										if (player.isVideo) {
												player.showControls();
												player.startControlsTimer();
										}

										// 5%
										var newTime = Math.max(media.currentTime - player.options.defaultSeekBackwardInterval(media), 0);
										media.setCurrentTime(newTime);
								}
						}
				},
				{
						keys: [
								39, // RIGHT
								228 // Google TV forward
						],
						action: function(player, media) {
								if (!isNaN(media.duration) && media.duration > 0) {
										if (player.isVideo) {
												player.showControls();
												player.startControlsTimer();
										}

										// 5%
										var newTime = Math.min(media.currentTime + player.options.defaultSeekForwardInterval(media), media.duration);
										media.setCurrentTime(newTime);
								}
						}
				},
				{
						keys: [70], // F
						action: function(player, media) {
								if (typeof player.enterFullScreen != 'undefined') {
										if (player.isFullScreen) {
												player.exitFullScreen();
										} else {
												player.enterFullScreen();
										}
								}
						}
				},
				{
						keys: [77], // M
						action: function(player, media) {
								player.container.find('.mejs-volume-slider').css('display','block');
								if (player.isVideo) {
										player.showControls();
										player.startControlsTimer();
								}
								if (player.media.muted) {
										player.setMuted(false);
								} else {
										player.setMuted(true);
								}
						}
				}
		]
	};

	mejs.mepIndex = 0;

	mejs.players = {};

	// wraps a MediaElement object in player controls
	mejs.MediaElementPlayer = function(node, o) {
		// enforce object, even without "new" (via John Resig)
		if ( !(this instanceof mejs.MediaElementPlayer) ) {
			return new mejs.MediaElementPlayer(node, o);
		}

		var t = this;

		// these will be reset after the MediaElement.success fires
		t.$media = t.$node = $(node);
		t.node = t.media = t.$media[0];

		if(!t.node) {
			return
		}

		// check for existing player
		if (typeof t.node.player != 'undefined') {
			return t.node.player;
		}


		// try to get options from data-mejsoptions
		if (typeof o == 'undefined') {
			o = t.$node.data('mejsoptions');
		}

		// extend default options
		t.options = $.extend({},mejs.MepDefaults,o);

		if (!t.options.timeFormat) {
			// Generate the time format according to options
			t.options.timeFormat = 'mm:ss';
			if (t.options.alwaysShowHours) {
				t.options.timeFormat = 'hh:mm:ss';
			}
			if (t.options.showTimecodeFrameCount) {
				t.options.timeFormat += ':ff';
			}
		}

		mejs.Utility.calculateTimeFormat(0, t.options, t.options.framesPerSecond || 25);

		// unique ID
		t.id = 'mep_' + mejs.mepIndex++;

		// add to player array (for focus events)
		mejs.players[t.id] = t;

		// start up
		t.init();

		return t;
	};

	// actual player
	mejs.MediaElementPlayer.prototype = {

		hasFocus: false,

		controlsAreVisible: true,

		init: function() {

			var
				t = this,
				mf = mejs.MediaFeatures,
				// options for MediaElement (shim)
				meOptions = $.extend(true, {}, t.options, {
					success: function(media, domNode) { t.meReady(media, domNode); },
					error: function(e) { t.handleError(e);}
				}),
				tagName = t.media.tagName.toLowerCase();

			t.isDynamic = (tagName !== 'audio' && tagName !== 'video');

			if (t.isDynamic) {
				// get video from src or href?
				t.isVideo = t.options.isVideo;
			} else {
				t.isVideo = (tagName !== 'audio' && t.options.isVideo);
			}

			// use native controls in iPad, iPhone, and Android
			if ((mf.isiPad && t.options.iPadUseNativeControls) || (mf.isiPhone && t.options.iPhoneUseNativeControls)) {

				// add controls and stop
				t.$media.attr('controls', 'controls');

				// attempt to fix iOS 3 bug
				//t.$media.removeAttr('poster');
                                // no Issue found on iOS3 -ttroxell

				// override Apple's autoplay override for iPads
				if (mf.isiPad && t.media.getAttribute('autoplay') !== null) {
					t.play();
				}

			} else if (mf.isAndroid && t.options.AndroidUseNativeControls) {

				// leave default player

			} else {

				// DESKTOP: use MediaElementPlayer controls

				// remove native controls
				t.$media.removeAttr('controls');
				var videoPlayerTitle = t.isVideo ?
					mejs.i18n.t('Video Player') : mejs.i18n.t('Audio Player');
				// insert description for screen readers
				$('<span class="mejs-offscreen">' + videoPlayerTitle + '</span>').insertBefore(t.$media);
				// build container
				t.container =
					$('<div id="' + t.id + '" class="mejs-container ' + (mejs.MediaFeatures.svgAsImg ? 'svg' : 'no-svg') +
					  '" tabindex="0" role="application" aria-label="' + videoPlayerTitle + '">'+
						'<div class="mejs-inner">'+
							'<div class="mejs-mediaelement"></div>'+
							'<div class="mejs-layers"></div>'+
							'<div class="mejs-controls"></div>'+
							'<div class="mejs-clear"></div>'+
						'</div>' +
					'</div>')
					.addClass(t.$media[0].className)
					.insertBefore(t.$media)
					.focus(function ( e ) {
						if( !t.controlsAreVisible ) {
							t.showControls(true);
							var playButton = t.container.find('.mejs-playpause-button > button');
							playButton.focus();
						}
					});

				// add classes for user and content
				t.container.addClass(
					(mf.isAndroid ? 'mejs-android ' : '') +
					(mf.isiOS ? 'mejs-ios ' : '') +
					(mf.isiPad ? 'mejs-ipad ' : '') +
					(mf.isiPhone ? 'mejs-iphone ' : '') +
					(t.isVideo ? 'mejs-video ' : 'mejs-audio ')
				);


				// move the <video/video> tag into the right spot
				t.container.find('.mejs-mediaelement').append(t.$media);

				// needs to be assigned here, after iOS remap
				t.node.player = t;

				// find parts
				t.controls = t.container.find('.mejs-controls');
				t.layers = t.container.find('.mejs-layers');

				// determine the size

				/* size priority:
					(1) videoWidth (forced),
					(2) style="width;height;"
					(3) width attribute,
					(4) defaultVideoWidth (for unspecified cases)
				*/

				var tagType = (t.isVideo ? 'video' : 'audio'),
					capsTagName = tagType.substring(0,1).toUpperCase() + tagType.substring(1);



				if (t.options[tagType + 'Width'] > 0 || t.options[tagType + 'Width'].toString().indexOf('%') > -1) {
					t.width = t.options[tagType + 'Width'];
				} else if (t.media.style.width !== '' && t.media.style.width !== null) {
					t.width = t.media.style.width;
				} else if (t.media.getAttribute('width') !== null) {
					t.width = t.$media.attr('width');
				} else {
					t.width = t.options['default' + capsTagName + 'Width'];
				}

				if (t.options[tagType + 'Height'] > 0 || t.options[tagType + 'Height'].toString().indexOf('%') > -1) {
					t.height = t.options[tagType + 'Height'];
				} else if (t.media.style.height !== '' && t.media.style.height !== null) {
					t.height = t.media.style.height;
				} else if (t.$media[0].getAttribute('height') !== null) {
					t.height = t.$media.attr('height');
				} else {
					t.height = t.options['default' + capsTagName + 'Height'];
				}

				// set the size, while we wait for the plugins to load below
				t.setPlayerSize(t.width, t.height);

				// create MediaElementShim
				meOptions.pluginWidth = t.width;
				meOptions.pluginHeight = t.height;
			}

			// create MediaElement shim
			mejs.MediaElement(t.$media[0], meOptions);

			if (typeof(t.container) != 'undefined' && t.controlsAreVisible){
				// controls are shown when loaded
				t.container.trigger('controlsshown');
			}
		},

		showControls: function(doAnimation) {
			var t = this;

			doAnimation = typeof doAnimation == 'undefined' || doAnimation;

			if (t.controlsAreVisible)
				return;

			if (doAnimation) {
				t.controls
					.removeClass('mejs-offscreen')
					.stop(true, true).fadeIn(200, function() {
						t.controlsAreVisible = true;
						t.container.trigger('controlsshown');
					});

				// any additional controls people might add and want to hide
				t.container.find('.mejs-control')
					.removeClass('mejs-offscreen')
					.stop(true, true).fadeIn(200, function() {t.controlsAreVisible = true;});

			} else {
				t.controls
					.removeClass('mejs-offscreen')
					.css('display','block');

				// any additional controls people might add and want to hide
				t.container.find('.mejs-control')
					.removeClass('mejs-offscreen')
					.css('display','block');

				t.controlsAreVisible = true;
				t.container.trigger('controlsshown');
			}

			t.setControlsSize();

		},

		hideControls: function(doAnimation) {
			var t = this;

			doAnimation = typeof doAnimation == 'undefined' || doAnimation;

			if (!t.controlsAreVisible || t.options.alwaysShowControls || t.keyboardAction)
				return;

			if (doAnimation) {
				// fade out main controls
				t.controls.stop(true, true).fadeOut(200, function() {
					$(this)
						.addClass('mejs-offscreen')
						.css('display','block');

					t.controlsAreVisible = false;
					t.container.trigger('controlshidden');
				});

				// any additional controls people might add and want to hide
				t.container.find('.mejs-control').stop(true, true).fadeOut(200, function() {
					$(this)
						.addClass('mejs-offscreen')
						.css('display','block');
				});
			} else {

				// hide main controls
				t.controls
					.addClass('mejs-offscreen')
					.css('display','block');

				// hide others
				t.container.find('.mejs-control')
					.addClass('mejs-offscreen')
					.css('display','block');

				t.controlsAreVisible = false;
				t.container.trigger('controlshidden');
			}
		},

		controlsTimer: null,

		startControlsTimer: function(timeout) {

			var t = this;

			timeout = typeof timeout != 'undefined' ? timeout : 1500;

			t.killControlsTimer('start');

			t.controlsTimer = setTimeout(function() {
				//
				t.hideControls();
				t.killControlsTimer('hide');
			}, timeout);
		},

		killControlsTimer: function(src) {

			var t = this;

			if (t.controlsTimer !== null) {
				clearTimeout(t.controlsTimer);
				delete t.controlsTimer;
				t.controlsTimer = null;
			}
		},

		controlsEnabled: true,

		disableControls: function() {
			var t= this;

			t.killControlsTimer();
			t.hideControls(false);
			this.controlsEnabled = false;
		},

		enableControls: function() {
			var t= this;

			t.showControls(false);

			t.controlsEnabled = true;
		},


		// Sets up all controls and events
		meReady: function(media, domNode) {


			var t = this,
				mf = mejs.MediaFeatures,
				autoplayAttr = domNode.getAttribute('autoplay'),
				autoplay = !(typeof autoplayAttr == 'undefined' || autoplayAttr === null || autoplayAttr === 'false'),
				featureIndex,
				feature;

			// make sure it can't create itself again if a plugin reloads
			if (t.created) {
				return;
			} else {
				t.created = true;
			}

			t.media = media;
			t.domNode = domNode;

			if (!(mf.isAndroid && t.options.AndroidUseNativeControls) && !(mf.isiPad && t.options.iPadUseNativeControls) && !(mf.isiPhone && t.options.iPhoneUseNativeControls)) {

				// two built in features
				t.buildposter(t, t.controls, t.layers, t.media);
				t.buildkeyboard(t, t.controls, t.layers, t.media);
				t.buildoverlays(t, t.controls, t.layers, t.media);

				// grab for use by features
				t.findTracks();

				// add user-defined features/controls
				for (featureIndex in t.options.features) {
					feature = t.options.features[featureIndex];
					if (t['build' + feature]) {
						try {
							t['build' + feature](t, t.controls, t.layers, t.media);
						} catch (e) {
							// TODO: report control error
							//throw e;
							
							
						}
					}
				}

				t.container.trigger('controlsready');

				// reset all layers and controls
				t.setPlayerSize(t.width, t.height);
				t.setControlsSize();


				// controls fade
				if (t.isVideo) {

					if (mejs.MediaFeatures.hasTouch) {

						// for touch devices (iOS, Android)
						// show/hide without animation on touch

						t.$media.bind('touchstart', function() {


							// toggle controls
							if (t.controlsAreVisible) {
								t.hideControls(false);
							} else {
								if (t.controlsEnabled) {
									t.showControls(false);
								}
							}
						});

					} else {

						// create callback here since it needs access to current
						// MediaElement object
						t.clickToPlayPauseCallback = function() {
							//

							if (t.options.clickToPlayPause) {
								if (t.media.paused) {
									t.play();
								} else {
									t.pause();
								}
							}
						};

						// click to play/pause
						t.media.addEventListener('click', t.clickToPlayPauseCallback, false);

						// show/hide controls
						t.container
							.bind('mouseenter', function () {
								if (t.controlsEnabled) {
									if (!t.options.alwaysShowControls ) {
										t.killControlsTimer('enter');
										t.showControls();
										t.startControlsTimer(2500);
									}
								}
							})
							.bind('mousemove', function() {
								if (t.controlsEnabled) {
									if (!t.controlsAreVisible) {
										t.showControls();
									}
									if (!t.options.alwaysShowControls) {
										t.startControlsTimer(2500);
									}
								}
							})
							.bind('mouseleave', function () {
								if (t.controlsEnabled) {
									if (!t.media.paused && !t.options.alwaysShowControls) {
										t.startControlsTimer(1000);
									}
								}
							});
					}

					if(t.options.hideVideoControlsOnLoad) {
						t.hideControls(false);
					}

					// check for autoplay
					if (autoplay && !t.options.alwaysShowControls) {
						t.hideControls();
					}

					// resizer
					if (t.options.enableAutosize) {
						t.media.addEventListener('loadedmetadata', function(e) {
							// if the <video height> was not set and the options.videoHeight was not set
							// then resize to the real dimensions
							if (t.options.videoHeight <= 0 && t.domNode.getAttribute('height') === null && !isNaN(e.target.videoHeight)) {
								t.setPlayerSize(e.target.videoWidth, e.target.videoHeight);
								t.setControlsSize();
								t.media.setVideoSize(e.target.videoWidth, e.target.videoHeight);
							}
						}, false);
					}
				}

				// EVENTS

				// FOCUS: when a video starts playing, it takes focus from other players (possibily pausing them)
				media.addEventListener('play', function() {
					var playerIndex;

					// go through all other players
					for (playerIndex in mejs.players) {
						var p = mejs.players[playerIndex];
						if (p.id != t.id && t.options.pauseOtherPlayers && !p.paused && !p.ended) {
							p.pause();
						}
						p.hasFocus = false;
					}

					t.hasFocus = true;
				},false);


				// ended for all
				t.media.addEventListener('ended', function (e) {
					if(t.options.autoRewind) {
						try{
							t.media.setCurrentTime(0);
                            // Fixing an Android stock browser bug, where "seeked" isn't fired correctly after ending the video and jumping to the beginning
                            window.setTimeout(function(){
                                $(t.container).find('.mejs-overlay-loading').parent().hide();
                            }, 20);
						} catch (exp) {

						}
					}
					t.media.pause();

					if (t.setProgressRail) {
						t.setProgressRail();
					}
					if (t.setCurrentRail) {
						t.setCurrentRail();
					}

					if (t.options.loop) {
						t.play();
					} else if (!t.options.alwaysShowControls && t.controlsEnabled) {
						t.showControls();
					}
				}, false);

				// resize on the first play
				t.media.addEventListener('loadedmetadata', function(e) {
					if (t.updateDuration) {
						t.updateDuration();
					}
					if (t.updateCurrent) {
						t.updateCurrent();
					}

					if (!t.isFullScreen) {
						t.setPlayerSize(t.width, t.height);
						t.setControlsSize();
					}
				}, false);

				// Only change the time format when necessary
				var duration = null;
				t.media.addEventListener('timeupdate',function() {
					if (duration !== this.duration) {
						duration = this.duration;
						mejs.Utility.calculateTimeFormat(duration, t.options, t.options.framesPerSecond || 25);
						
						// make sure to fill in and resize the controls (e.g., 00:00 => 01:13:15
						if (t.updateDuration) {
							t.updateDuration();
						}
						if (t.updateCurrent) {
							t.updateCurrent();
						}
						t.setControlsSize();
						
					}
				}, false);

				t.container.focusout(function (e) {
					if( e.relatedTarget ) { //FF is working on supporting focusout https://bugzilla.mozilla.org/show_bug.cgi?id=687787
						var $target = $(e.relatedTarget);
						if (t.keyboardAction && $target.parents('.mejs-container').length === 0) {
							t.keyboardAction = false;
							t.hideControls(true);
						}
					}
				});

				// webkit has trouble doing this without a delay
				setTimeout(function () {
					t.setPlayerSize(t.width, t.height);
					t.setControlsSize();
				}, 50);

				// adjust controls whenever window sizes (used to be in fullscreen only)
				t.globalBind('resize', function() {

					// don't resize for fullscreen mode
					if ( !(t.isFullScreen || (mejs.MediaFeatures.hasTrueNativeFullScreen && document.webkitIsFullScreen)) ) {
						t.setPlayerSize(t.width, t.height);
					}

					// always adjust controls
					t.setControlsSize();
				});

				// This is a work-around for a bug in the YouTube iFrame player, which means
				//  we can't use the play() API for the initial playback on iOS or Android;
				//  user has to start playback directly by tapping on the iFrame.
				if (t.media.pluginType == 'youtube' && ( mf.isiOS || mf.isAndroid ) ) {
					t.container.find('.mejs-overlay-play').hide();
                    t.container.find('.mejs-poster').hide();
				}
			}

			// force autoplay for HTML5
			if (autoplay && media.pluginType == 'native') {
				t.play();
			}


			if (t.options.success) {

				if (typeof t.options.success == 'string') {
					window[t.options.success](t.media, t.domNode, t);
				} else {
					t.options.success(t.media, t.domNode, t);
				}
			}
		},

		handleError: function(e) {
			var t = this;

			if (t.controls) {
				t.controls.hide();
			}

			// Tell user that the file cannot be played
			if (t.options.error) {
				t.options.error(e);
			}
		},

		setPlayerSize: function(width,height) {
			var t = this;

			if( !t.options.setDimensions ) {
				return false;
			}

			if (typeof width != 'undefined') {
				t.width = width;
			}

			if (typeof height != 'undefined') {
				t.height = height;
			}

			// detect 100% mode - use currentStyle for IE since css() doesn't return percentages
			if (t.height.toString().indexOf('%') > 0 || (t.$node.css('max-width') !== 'none' && t.$node.css('max-width') !== 't.width') || (t.$node[0].currentStyle && t.$node[0].currentStyle.maxWidth === '100%')) {

				// do we have the native dimensions yet?
				var nativeWidth = (function() {
					if (t.isVideo) {
						if (t.media.videoWidth && t.media.videoWidth > 0) {
							return t.media.videoWidth;
						} else if (t.media.getAttribute('width') !== null) {
							return t.media.getAttribute('width');
						} else {
							return t.options.defaultVideoWidth;
						}
					} else {
						return t.options.defaultAudioWidth;
					}
				})();

				var nativeHeight = (function() {
					if (t.isVideo) {
						if (t.media.videoHeight && t.media.videoHeight > 0) {
							return t.media.videoHeight;
						} else if (t.media.getAttribute('height') !== null) {
							return t.media.getAttribute('height');
						} else {
							return t.options.defaultVideoHeight;
						}
					} else {
						return t.options.defaultAudioHeight;
					}
				})();

				var
					parentWidth = t.container.parent().closest(':visible').width(),
					parentHeight = t.container.parent().closest(':visible').height(),
					newHeight = t.isVideo || !t.options.autosizeProgress ? parseInt(parentWidth * nativeHeight/nativeWidth, 10) : nativeHeight;

				// When we use percent, the newHeight can't be calculated so we get the container height
				if (isNaN(newHeight)) {
					newHeight = parentHeight;
				}

				if (t.container.parent().length > 0 && t.container.parent()[0].tagName.toLowerCase() === 'body') { // && t.container.siblings().count == 0) {
					parentWidth = $(window).width();
					newHeight = $(window).height();
				}

				if ( newHeight && parentWidth ) {

					// set outer container size
					t.container
						.width(parentWidth)
						.height(newHeight);

					// set native <video> or <audio> and shims
					t.$media.add(t.container.find('.mejs-shim'))
						.width('100%')
						.height('100%');

					// if shim is ready, send the size to the embeded plugin
					if (t.isVideo) {
						if (t.media.setVideoSize) {
							t.media.setVideoSize(parentWidth, newHeight);
						}
					}

					// set the layers
					t.layers.children('.mejs-layer')
						.width('100%')
						.height('100%');
				}


			} else {

				t.container
					.width(t.width)
					.height(t.height);

				t.layers.children('.mejs-layer')
					.width(t.width)
					.height(t.height);

			}

		},

		setControlsSize: function() {
			var t = this,
				usedWidth = 0,
				railWidth = 0,
				rail = t.controls.find('.mejs-time-rail'),
				total = t.controls.find('.mejs-time-total'),
				others = rail.siblings(),
				lastControl = others.last(),
				lastControlPosition = null;

			// skip calculation if hidden
			if (!t.container.is(':visible') || !rail.length || !rail.is(':visible')) {
				return;
			}


			// allow the size to come from custom CSS
			if (t.options && !t.options.autosizeProgress) {
				// Also, frontends devs can be more flexible
				// due the opportunity of absolute positioning.
				railWidth = parseInt(rail.css('width'), 10);
			}

			// attempt to autosize
			if (railWidth === 0 || !railWidth) {

				// find the size of all the other controls besides the rail
				others.each(function() {
					var $this = $(this);
					if ($this.css('position') != 'absolute' && $this.is(':visible')) {
						usedWidth += $(this).outerWidth(true);
					}
				});

				// fit the rail into the remaining space
				railWidth = t.controls.width() - usedWidth - (rail.outerWidth(true) - rail.width());
			}

			// resize the rail,
			// but then check if the last control (say, the fullscreen button) got pushed down
			// this often happens when zoomed
			do {
				// outer area
				rail.width(railWidth);
				// dark space
				total.width(railWidth - (total.outerWidth(true) - total.width()));

				if (lastControl.css('position') != 'absolute') {
					lastControlPosition = lastControl.length ? lastControl.position() : null;
					railWidth--;
				}
			} while (lastControlPosition !== null && lastControlPosition.top.toFixed(2) > 0 && railWidth > 0);

			t.container.trigger('controlsresize');
		},


		buildposter: function(player, controls, layers, media) {
			var t = this,
				poster =
				$('<div class="mejs-poster mejs-layer">' +
				'</div>')
					.appendTo(layers),
				posterUrl = player.$media.attr('poster');

			// prioriy goes to option (this is useful if you need to support iOS 3.x (iOS completely fails with poster)
			if (player.options.poster !== '') {
				posterUrl = player.options.poster;
			}

			// second, try the real poster
			if ( posterUrl ) {
				t.setPoster(posterUrl);
			} else {
				poster.hide();
			}

			media.addEventListener('play',function() {
				poster.hide();
			}, false);

			if(player.options.showPosterWhenEnded && player.options.autoRewind){
				media.addEventListener('ended',function() {
					poster.show();
				}, false);
			}
		},

		setPoster: function(url) {
			var t = this,
				posterDiv = t.container.find('.mejs-poster'),
				posterImg = posterDiv.find('img');

			if (posterImg.length === 0) {
				posterImg = $('<img width="100%" height="100%" alt="" />').appendTo(posterDiv);
			}

			posterImg.attr('src', url);
			posterDiv.css({'background-image' : 'url(' + url + ')'});
		},

		buildoverlays: function(player, controls, layers, media) {
            var t = this;
			if (!player.isVideo)
				return;

			var
			loading =
				$('<div class="mejs-overlay mejs-layer">'+
					'<div class="mejs-overlay-loading"><span></span></div>'+
				'</div>')
				.hide() // start out hidden
				.appendTo(layers),
			error =
				$('<div class="mejs-overlay mejs-layer">'+
					'<div class="mejs-overlay-error"></div>'+
				'</div>')
				.hide() // start out hidden
				.appendTo(layers),
			// this needs to come last so it's on top
			bigPlay =
				$('<div class="mejs-overlay mejs-layer mejs-overlay-play">'+
					'<div class="mejs-overlay-button"></div>'+
				'</div>')
				.appendTo(layers)
				.bind('click', function() {  // Removed 'touchstart' due issues on Samsung Android devices where a tap on bigPlay started and immediately stopped the video
					if (t.options.clickToPlayPause) {
						if (media.paused) {
							media.play();
						}
					}
				});

			/*
			if (mejs.MediaFeatures.isiOS || mejs.MediaFeatures.isAndroid) {
				bigPlay.remove();
				loading.remove();
			}
			*/


			// show/hide big play button
			media.addEventListener('play',function() {
				bigPlay.hide();
				loading.hide();
				controls.find('.mejs-time-buffering').hide();
				error.hide();
			}, false);

			media.addEventListener('playing', function() {
				bigPlay.hide();
				loading.hide();
				controls.find('.mejs-time-buffering').hide();
				error.hide();
			}, false);

			media.addEventListener('seeking', function() {
				loading.show();
				controls.find('.mejs-time-buffering').show();
			}, false);

			media.addEventListener('seeked', function() {
				loading.hide();
				controls.find('.mejs-time-buffering').hide();
			}, false);

			media.addEventListener('pause',function() {
				if (!mejs.MediaFeatures.isiPhone) {
					bigPlay.show();
				}
			}, false);

			media.addEventListener('waiting', function() {
				loading.show();
				controls.find('.mejs-time-buffering').show();
			}, false);


			// show/hide loading
			media.addEventListener('loadeddata',function() {
				// for some reason Chrome is firing this event
				//if (mejs.MediaFeatures.isChrome && media.getAttribute && media.getAttribute('preload') === 'none')
				//	return;

				loading.show();
				controls.find('.mejs-time-buffering').show();
                // Firing the 'canplay' event after a timeout which isn't getting fired on some Android 4.1 devices (https://github.com/johndyer/mediaelement/issues/1305)
                if (mejs.MediaFeatures.isAndroid) {
                    media.canplayTimeout = window.setTimeout(
                        function() {
                            if (document.createEvent) {
                                var evt = document.createEvent('HTMLEvents');
                                evt.initEvent('canplay', true, true);
                                return media.dispatchEvent(evt);
                            }
                        }, 300
                    );
                }
			}, false);
			media.addEventListener('canplay',function() {
				loading.hide();
				controls.find('.mejs-time-buffering').hide();
                clearTimeout(media.canplayTimeout); // Clear timeout inside 'loadeddata' to prevent 'canplay' to fire twice
			}, false);

			// error handling
			media.addEventListener('error',function(e) {
				t.handleError(e);
				loading.hide();
				bigPlay.hide();
				error.show();
				error.find('.mejs-overlay-error').html("Error loading this resource");
			}, false);

			media.addEventListener('keydown', function(e) {
				t.onkeydown(player, media, e);
			}, false);
		},

		buildkeyboard: function(player, controls, layers, media) {

				var t = this;

				t.container.keydown(function () {
					t.keyboardAction = true;
				});

				// listen for key presses
				t.globalBind('keydown', function(event) {
					player.hasFocus = $(event.target).closest('.mejs-container').length !== 0
						&& $(event.target).closest('.mejs-container').attr('id') === player.$media.closest('.mejs-container').attr('id');
					return t.onkeydown(player, media, event);
				});


				// check if someone clicked outside a player region, then kill its focus
				t.globalBind('click', function(event) {
					player.hasFocus = $(event.target).closest('.mejs-container').length !== 0;
				});

		},
		onkeydown: function(player, media, e) {
			if (player.hasFocus && player.options.enableKeyboard) {
				// find a matching key
				for (var i = 0, il = player.options.keyActions.length; i < il; i++) {
					var keyAction = player.options.keyActions[i];

					for (var j = 0, jl = keyAction.keys.length; j < jl; j++) {
						if (e.keyCode == keyAction.keys[j]) {
							if (typeof(e.preventDefault) == "function") e.preventDefault();
							keyAction.action(player, media, e.keyCode, e);
							return false;
						}
					}
				}
			}

			return true;
		},

		findTracks: function() {
			var t = this,
				tracktags = t.$media.find('track');

			// store for use by plugins
			t.tracks = [];
			tracktags.each(function(index, track) {

				track = $(track);

				t.tracks.push({
					srclang: (track.attr('srclang')) ? track.attr('srclang').toLowerCase() : '',
					src: track.attr('src'),
					kind: track.attr('kind'),
					label: track.attr('label') || '',
					entries: [],
					isLoaded: false
				});
			});
		},
		changeSkin: function(className) {
			this.container[0].className = 'mejs-container ' + className;
			this.setPlayerSize(this.width, this.height);
			this.setControlsSize();
		},
		play: function() {
			this.load();
			this.media.play();
		},
		pause: function() {
			try {
				this.media.pause();
			} catch (e) {}
		},
		load: function() {
			if (!this.isLoaded) {
				this.media.load();
			}

			this.isLoaded = true;
		},
		setMuted: function(muted) {
			this.media.setMuted(muted);
		},
		setCurrentTime: function(time) {
			this.media.setCurrentTime(time);
		},
		getCurrentTime: function() {
			return this.media.currentTime;
		},
		setVolume: function(volume) {
			this.media.setVolume(volume);
		},
		getVolume: function() {
			return this.media.volume;
		},
		setSrc: function(src) {
			this.media.setSrc(src);
		},
		remove: function() {
			var t = this, featureIndex, feature;

			t.container.prev('.mejs-offscreen').remove();

			// invoke features cleanup
			for (featureIndex in t.options.features) {
				feature = t.options.features[featureIndex];
				if (t['clean' + feature]) {
					try {
						t['clean' + feature](t);
					} catch (e) {
						// TODO: report control error
						//throw e;
						//
						//
					}
				}
			}

			// grab video and put it back in place
			if (!t.isDynamic) {
				t.$media.prop('controls', true);
				// detach events from the video
				// TODO: detach event listeners better than this;
				//       also detach ONLY the events attached by this plugin!
				t.$node.clone().insertBefore(t.container).show();
				t.$node.remove();
			} else {
				t.$node.insertBefore(t.container);
			}

			if (t.media.pluginType !== 'native') {
				t.media.remove();
			}

			// Remove the player from the mejs.players object so that pauseOtherPlayers doesn't blow up when trying to pause a non existance flash api.
			delete mejs.players[t.id];

			if (typeof t.container == 'object') {
				t.container.remove();
			}
			t.globalUnbind();
			delete t.node.player;
		},
		rebuildtracks: function(){
			var t = this;
			t.findTracks();
			t.buildtracks(t, t.controls, t.layers, t.media);
		},
		resetSize: function(){
			var t = this;
			// webkit has trouble doing this without a delay
			setTimeout(function () {
				//
				t.setPlayerSize(t.width, t.height);
				t.setControlsSize();
			}, 50);
		}
	};

	(function(){
		var rwindow = /^((after|before)print|(before)?unload|hashchange|message|o(ff|n)line|page(hide|show)|popstate|resize|storage)\b/;

		function splitEvents(events, id) {
			// add player ID as an event namespace so it's easier to unbind them all later
			var ret = {d: [], w: []};
			$.each((events || '').split(' '), function(k, v){
				var eventname = v + '.' + id;
				if (eventname.indexOf('.') === 0) {
					ret.d.push(eventname);
					ret.w.push(eventname);
				}
				else {
					ret[rwindow.test(v) ? 'w' : 'd'].push(eventname);
				}
			});
			ret.d = ret.d.join(' ');
			ret.w = ret.w.join(' ');
			return ret;
		}

		mejs.MediaElementPlayer.prototype.globalBind = function(events, data, callback) {
    		var t = this;
			var doc = t.node ? t.node.ownerDocument : document;

			events = splitEvents(events, t.id);
			if (events.d) $(doc).bind(events.d, data, callback);
			if (events.w) $(window).bind(events.w, data, callback);
		};

		mejs.MediaElementPlayer.prototype.globalUnbind = function(events, callback) {
			var t = this;
			var doc = t.node ? t.node.ownerDocument : document;

			events = splitEvents(events, t.id);
			if (events.d) $(doc).unbind(events.d, callback);
			if (events.w) $(window).unbind(events.w, callback);
		};
	})();

	// turn into jQuery plugin
	if (typeof $ != 'undefined') {
		$.fn.mediaelementplayer = function (options) {
			if (options === false) {
				this.each(function () {
					var player = $(this).data('mediaelementplayer');
					if (player) {
						player.remove();
					}
					$(this).removeData('mediaelementplayer');
				});
			}
			else {
				this.each(function () {
					$(this).data('mediaelementplayer', new mejs.MediaElementPlayer(this, options));
				});
			}
			return this;
		};


		$(document).ready(function() {
			// auto enable using JSON attribute
			$('.mejs-player').mediaelementplayer();
		});
	}

	// push out to window
	window.MediaElementPlayer = mejs.MediaElementPlayer;

})(mejs.$);

(function($) {

	$.extend(mejs.MepDefaults, {
		playText: mejs.i18n.t('Play'),
		pauseText: mejs.i18n.t('Pause')
	});

	// PLAY/pause BUTTON
	$.extend(MediaElementPlayer.prototype, {
		buildplaypause: function(player, controls, layers, media) {
			var 
				t = this,
				op = t.options,
				play = 
				$('<div class="mejs-button mejs-playpause-button mejs-play" >' +
					'<button type="button" aria-controls="' + t.id + '" title="' + op.playText + '" aria-label="' + op.playText + '"></button>' +
				'</div>')
				.appendTo(controls)
				.click(function(e) {
					e.preventDefault();
				
					if (media.paused) {
						media.play();
					} else {
						media.pause();
					}
					
					return false;
				}),
				play_btn = play.find('button');


			function togglePlayPause(which) {
				if ('play' === which) {
					play.removeClass('mejs-play').addClass('mejs-pause');
					play_btn.attr({
						'title': op.pauseText,
						'aria-label': op.pauseText
					});
				} else {
					play.removeClass('mejs-pause').addClass('mejs-play');
					play_btn.attr({
						'title': op.playText,
						'aria-label': op.playText
					});
				}
			};
			togglePlayPause('pse');


			media.addEventListener('play',function() {
				togglePlayPause('play');
			}, false);
			media.addEventListener('playing',function() {
				togglePlayPause('play');
			}, false);


			media.addEventListener('pause',function() {
				togglePlayPause('pse');
			}, false);
			media.addEventListener('paused',function() {
				togglePlayPause('pse');
			}, false);
		}
	});
	
})(mejs.$);

(function($) {

	$.extend(mejs.MepDefaults, {
		stopText: 'Stop'
	});

	// STOP BUTTON
	$.extend(MediaElementPlayer.prototype, {
		buildstop: function(player, controls, layers, media) {
			var t = this;

			$('<div class="mejs-button mejs-stop-button mejs-stop">' +
					'<button type="button" aria-controls="' + t.id + '" title="' + t.options.stopText + '" aria-label="' + t.options.stopText + '"></button>' +
				'</div>')
				.appendTo(controls)
				.click(function() {
					if (!media.paused) {
						media.pause();
					}
					if (media.currentTime > 0) {
						media.setCurrentTime(0);
                        media.pause();
						controls.find('.mejs-time-current').width('0px');
						controls.find('.mejs-time-handle').css('left', '0px');
						controls.find('.mejs-time-float-current').html( mejs.Utility.secondsToTimeCode(0, player.options));
						controls.find('.mejs-currenttime').html( mejs.Utility.secondsToTimeCode(0, player.options));
						layers.find('.mejs-poster').show();
					}
				});
		}
	});
	
})(mejs.$);

(function($) {

	$.extend(mejs.MepDefaults, {
		progessHelpText: mejs.i18n.t(
		'Use Left/Right Arrow keys to advance one second, Up/Down arrows to advance ten seconds.')
	});

	// progress/loaded bar
	$.extend(MediaElementPlayer.prototype, {
		buildprogress: function(player, controls, layers, media) {

			$('<div class="mejs-time-rail">' +
				'<span  class="mejs-time-total mejs-time-slider">' +
				//'<span class="mejs-offscreen">' + this.options.progessHelpText + '</span>' +
					'<span class="mejs-time-buffering"></span>' +
					'<span class="mejs-time-loaded"></span>' +
					'<span class="mejs-time-current"></span>' +
					'<span class="mejs-time-handle"></span>' +
					'<span class="mejs-time-float">' +
						'<span class="mejs-time-float-current">00:00</span>' +
						'<span class="mejs-time-float-corner"></span>' +
					'</span>' +
				'</span>' +
			'</div>')
				.appendTo(controls);
			controls.find('.mejs-time-buffering').hide();

			var 
				t = this,
				total = controls.find('.mejs-time-total'),
				loaded  = controls.find('.mejs-time-loaded'),
				current  = controls.find('.mejs-time-current'),
				handle  = controls.find('.mejs-time-handle'),
				timefloat  = controls.find('.mejs-time-float'),
				timefloatcurrent  = controls.find('.mejs-time-float-current'),
                slider = controls.find('.mejs-time-slider'),
				handleMouseMove = function (e) {
					
                    var offset = total.offset(),
						width = total.width(),
						percentage = 0,
						newTime = 0,
						pos = 0,
                        x;
                    
                    // mouse or touch position relative to the object
					if (e.originalEvent && e.originalEvent.changedTouches) {
						x = e.originalEvent.changedTouches[0].pageX;
					} else if (e.changedTouches) { // for Zepto
						x = e.changedTouches[0].pageX;
					} else {
						x = e.pageX;
					}

					if (media.duration) {
						if (x < offset.left) {
							x = offset.left;
						} else if (x > width + offset.left) {
							x = width + offset.left;
						}
						
						pos = x - offset.left;
						percentage = (pos / width);
						newTime = (percentage <= 0.02) ? 0 : percentage * media.duration;

						// seek to where the mouse is
						if (mouseIsDown && newTime !== media.currentTime) {
							media.setCurrentTime(newTime);
						}

						// position floating time box
						if (!mejs.MediaFeatures.hasTouch) {
								timefloat.css('left', pos);
								timefloatcurrent.html( mejs.Utility.secondsToTimeCode(newTime, player.options) );
								timefloat.show();
						}
					}
				},
				mouseIsDown = false,
				mouseIsOver = false,
				lastKeyPressTime = 0,
				startedPaused = false,
				autoRewindInitial = player.options.autoRewind;
            // Accessibility for slider
            var updateSlider = function (e) {

				var seconds = media.currentTime,
					timeSliderText = mejs.i18n.t('Time Slider'),
					time = mejs.Utility.secondsToTimeCode(seconds, player.options),
					duration = media.duration;

				slider.attr({
					'aria-label': timeSliderText,
					'aria-valuemin': 0,
					'aria-valuemax': duration,
					'aria-valuenow': seconds,
					'aria-valuetext': time,
					'role': 'slider',
					'tabindex': 0
				});

			};

				var restartPlayer = function () {
				var now = new Date();
				if (now - lastKeyPressTime >= 1000) {
					media.play();
				}
			};

			slider.bind('focus', function (e) {
				player.options.autoRewind = false;
			});

			slider.bind('blur', function (e) {
				player.options.autoRewind = autoRewindInitial;
			});

			slider.bind('keydown', function (e) {

				if ((new Date() - lastKeyPressTime) >= 1000) {
					startedPaused = media.paused;
				}

				var keyCode = e.keyCode,
					duration = media.duration,
					seekTime = media.currentTime,
					seekForward  = player.options.defaultSeekForwardInterval(duration),
					seekBackward = player.options.defaultSeekBackwardInterval(duration);

				switch (keyCode) {
				case 37: // left
				case 40: // Down
					seekTime -= seekBackward;
					break;
				case 39: // Right
				case 38: // Up
					seekTime += seekForward;
					break;
				case 36: // Home
					seekTime = 0;
					break;
				case 35: // end
					seekTime = duration;
					break;
				case 32: // space
				case 13: // enter
					media.paused ? media.play() : media.pause();
					return;
				default:
					return;
				}

				seekTime = seekTime < 0 ? 0 : (seekTime >= duration ? duration : Math.floor(seekTime));
				lastKeyPressTime = new Date();
				if (!startedPaused) {
					media.pause();
				}

				if (seekTime < media.duration && !startedPaused) {
					setTimeout(restartPlayer, 1100);
				}

				media.setCurrentTime(seekTime);

				e.preventDefault();
				e.stopPropagation();
				return false;
			});


			// handle clicks
			//controls.find('.mejs-time-rail').delegate('span', 'click', handleMouseMove);
			total
				.bind('mousedown touchstart', function (e) {
					// only handle left clicks or touch
					if (e.which === 1 || e.which === 0) {
						mouseIsDown = true;
						handleMouseMove(e);
						t.globalBind('mousemove.dur touchmove.dur', function(e) {
							handleMouseMove(e);
						});
						t.globalBind('mouseup.dur touchend.dur', function (e) {
							mouseIsDown = false;
							timefloat.hide();
							t.globalUnbind('.dur');
						});
					}
				})
				.bind('mouseenter', function(e) {
					mouseIsOver = true;
					t.globalBind('mousemove.dur', function(e) {
						handleMouseMove(e);
					});
					if (!mejs.MediaFeatures.hasTouch) {
						timefloat.show();
					}
				})
				.bind('mouseleave',function(e) {
					mouseIsOver = false;
					if (!mouseIsDown) {
						t.globalUnbind('.dur');
						timefloat.hide();
					}
				});

			// loading
			media.addEventListener('progress', function (e) {
				player.setProgressRail(e);
				player.setCurrentRail(e);
			}, false);

			// current time
			media.addEventListener('timeupdate', function(e) {
				player.setProgressRail(e);
				player.setCurrentRail(e);
				updateSlider(e);
			}, false);
			
			t.container.on('controlsresize', function() {
				player.setProgressRail();
				player.setCurrentRail();
			});
			
			// store for later use
			t.loaded = loaded;
			t.total = total;
			t.current = current;
			t.handle = handle;
		},
		setProgressRail: function(e) {

			var
				t = this,
				target = (e !== undefined) ? e.target : t.media,
				percent = null;

			// newest HTML5 spec has buffered array (FF4, Webkit)
			if (target && target.buffered && target.buffered.length > 0 && target.buffered.end && target.duration) {
				// account for a real array with multiple values - always read the end of the last buffer
				percent = target.buffered.end(target.buffered.length - 1) / target.duration;
			} 
			// Some browsers (e.g., FF3.6 and Safari 5) cannot calculate target.bufferered.end()
			// to be anything other than 0. If the byte count is available we use this instead.
			// Browsers that support the else if do not seem to have the bufferedBytes value and
			// should skip to there. Tested in Safari 5, Webkit head, FF3.6, Chrome 6, IE 7/8.
			else if (target && target.bytesTotal !== undefined && target.bytesTotal > 0 && target.bufferedBytes !== undefined) {
				percent = target.bufferedBytes / target.bytesTotal;
			}
			// Firefox 3 with an Ogg file seems to go this way
			else if (e && e.lengthComputable && e.total !== 0) {
				percent = e.loaded / e.total;
			}

			// finally update the progress bar
			if (percent !== null) {
				percent = Math.min(1, Math.max(0, percent));
				// update loaded bar
				if (t.loaded && t.total) {
					t.loaded.width(t.total.width() * percent);
				}
			}
		},
		setCurrentRail: function() {

			var t = this;
		
			if (t.media.currentTime !== undefined && t.media.duration) {

				// update bar and handle
				if (t.total && t.handle) {
					var 
						newWidth = Math.round(t.total.width() * t.media.currentTime / t.media.duration),
						handlePos = newWidth - Math.round(t.handle.outerWidth(true) / 2);

					t.current.width(newWidth);
					t.handle.css('left', handlePos);
				}
			}

		}
	});
})(mejs.$);

(function($) {
	
	// options
	$.extend(mejs.MepDefaults, {
		duration: -1,
		timeAndDurationSeparator: '<span> | </span>'
	});


	// current and duration 00:00 / 00:00
	$.extend(MediaElementPlayer.prototype, {
		buildcurrent: function(player, controls, layers, media) {
			var t = this;
			
			$('<div class="mejs-time" role="timer" aria-live="off">' +
					'<span class="mejs-currenttime">' + 
						mejs.Utility.secondsToTimeCode(0, player.options) +
                    '</span>'+
				'</div>')
			.appendTo(controls);
			
			t.currenttime = t.controls.find('.mejs-currenttime');

			media.addEventListener('timeupdate',function() {
				player.updateCurrent();
			}, false);
		},


		buildduration: function(player, controls, layers, media) {
			var t = this;
			
			if (controls.children().last().find('.mejs-currenttime').length > 0) {
				$(t.options.timeAndDurationSeparator +
					'<span class="mejs-duration">' + 
						mejs.Utility.secondsToTimeCode(t.options.duration, t.options) +
					'</span>')
					.appendTo(controls.find('.mejs-time'));
			} else {

				// add class to current time
				controls.find('.mejs-currenttime').parent().addClass('mejs-currenttime-container');
				
				$('<div class="mejs-time mejs-duration-container">'+
					'<span class="mejs-duration">' + 
						mejs.Utility.secondsToTimeCode(t.options.duration, t.options) +
					'</span>' +
				'</div>')
				.appendTo(controls);
			}
			
			t.durationD = t.controls.find('.mejs-duration');

			media.addEventListener('timeupdate',function() {
				player.updateDuration();
			}, false);
		},
		
		updateCurrent:  function() {
			var t = this;
			
			var currentTime = t.media.currentTime;
			
			if (isNaN(currentTime)) {
				currentTime = 0;
			}

			if (t.currenttime) {
				t.currenttime.html(mejs.Utility.secondsToTimeCode(currentTime, t.options));
			}
		},
		
		updateDuration: function() {
			var t = this;
			
			var duration = t.media.duration;
			if (t.options.duration > 0) {
				duration = t.options.duration;
			}
			
			if (isNaN(duration)) {
				duration = 0;
			}

			//Toggle the long video class if the video is longer than an hour.
			t.container.toggleClass("mejs-long-video", duration > 3600);
			
			if (t.durationD && duration > 0) {
				t.durationD.html(mejs.Utility.secondsToTimeCode(duration, t.options));
			}		
		}
	});

})(mejs.$);

(function($) {

	$.extend(mejs.MepDefaults, {
		muteText: mejs.i18n.t('Mute Toggle'),
        allyVolumeControlText: mejs.i18n.t('Use Up/Down Arrow keys to increase or decrease volume.'),
		hideVolumeOnTouchDevices: true,
		
		audioVolume: 'horizontal',
		videoVolume: 'vertical'
	});

	$.extend(MediaElementPlayer.prototype, {
		buildvolume: function(player, controls, layers, media) {
				
			// Android and iOS don't support volume controls
			if ((mejs.MediaFeatures.isAndroid || mejs.MediaFeatures.isiOS) && this.options.hideVolumeOnTouchDevices)
				return;
			
			var t = this,
				mode = (t.isVideo) ? t.options.videoVolume : t.options.audioVolume,
				mute = (mode == 'horizontal') ?
				
				// horizontal version
				$('<div class="mejs-button mejs-volume-button mejs-mute">' +
					'<button type="button" aria-controls="' + t.id + 
						'" title="' + t.options.muteText + 
						'" aria-label="' + t.options.muteText +
					'"></button>'+
				'</div>' +
                  '<a href="javascript:void(0);" class="mejs-horizontal-volume-slider">' + // outer background
					'<span class="mejs-offscreen">' + t.options.allyVolumeControlText + '</span>' +
					'<div class="mejs-horizontal-volume-total"></div>'+ // line background
					'<div class="mejs-horizontal-volume-current"></div>'+ // current volume
					'<div class="mejs-horizontal-volume-handle"></div>'+ // handle
				'</a>'
				)
					.appendTo(controls) :
				
				// vertical version
				$('<div class="mejs-button mejs-volume-button mejs-mute">'+
					'<button type="button" aria-controls="' + t.id + 
						'" title="' + t.options.muteText + 
						'" aria-label="' + t.options.muteText + 
					'"></button>'+
					'<a href="javascript:void(0);" class="mejs-volume-slider">'+ // outer background
						'<span class="mejs-offscreen">' + t.options.allyVolumeControlText + '</span>' +                  
						'<div class="mejs-volume-total"></div>'+ // line background
						'<div class="mejs-volume-current"></div>'+ // current volume
						'<div class="mejs-volume-handle"></div>'+ // handle
					'</a>'+
				'</div>')
					.appendTo(controls),
			volumeSlider = t.container.find('.mejs-volume-slider, .mejs-horizontal-volume-slider'),
			volumeTotal = t.container.find('.mejs-volume-total, .mejs-horizontal-volume-total'),
			volumeCurrent = t.container.find('.mejs-volume-current, .mejs-horizontal-volume-current'),
			volumeHandle = t.container.find('.mejs-volume-handle, .mejs-horizontal-volume-handle'),

			positionVolumeHandle = function(volume, secondTry) {

				if (!volumeSlider.is(':visible') && typeof secondTry == 'undefined') {
					volumeSlider.show();
					positionVolumeHandle(volume, true);
					volumeSlider.hide();
					return;
				}

				// correct to 0-1
				volume = Math.max(0,volume);
				volume = Math.min(volume,1);

				// ajust mute button style
				if (volume === 0) {
					mute.removeClass('mejs-mute').addClass('mejs-unmute');
					mute.children('button').attr('title', mejs.i18n.t('Unmute')).attr('aria-label', mejs.i18n.t('Unmute'));
				} else {
					mute.removeClass('mejs-unmute').addClass('mejs-mute');
					mute.children('button').attr('title', mejs.i18n.t('Mute')).attr('aria-label', mejs.i18n.t('Mute'));
				}

                // top/left of full size volume slider background
                var totalPosition = volumeTotal.position();
				// position slider 
				if (mode == 'vertical') {
					var
                    // height of the full size volume slider background
						totalHeight = volumeTotal.height(),

                        // the new top position based on the current volume
						// 70% volume on 100px height == top:30px
						newTop = totalHeight - (totalHeight * volume);
	
					// handle
					volumeHandle.css('top', Math.round(totalPosition.top + newTop - (volumeHandle.height() / 2)));
	
					// show the current visibility
					volumeCurrent.height(totalHeight - newTop );
					volumeCurrent.css('top', totalPosition.top + newTop);
				} else {
                    var
						// height of the full size volume slider background
						totalWidth = volumeTotal.width(),
						
						// the new left position based on the current volume
						newLeft = totalWidth * volume;
	
					// handle
					volumeHandle.css('left', Math.round(totalPosition.left + newLeft - (volumeHandle.width() / 2)));
	
					// rezize the current part of the volume bar
					volumeCurrent.width( Math.round(newLeft) );
				}
			},
			handleVolumeMove = function(e) {
				
				var volume = null,
					totalOffset = volumeTotal.offset();
				
				// calculate the new volume based on the moust position
				if (mode === 'vertical') {
				
					var
						railHeight = volumeTotal.height(),
						newY = e.pageY - totalOffset.top;
						
					volume = (railHeight - newY) / railHeight;
						
					// the controls just hide themselves (usually when mouse moves too far up)
					if (totalOffset.top === 0 || totalOffset.left === 0) {
						return;
                    }
					
				} else {
					var
						railWidth = volumeTotal.width(),
						newX = e.pageX - totalOffset.left;
						
					volume = newX / railWidth;
				}
				
				// ensure the volume isn't outside 0-1
				volume = Math.max(0,volume);
				volume = Math.min(volume,1);
				
				// position the slider and handle
				positionVolumeHandle(volume);
				
				// set the media object (this will trigger the volumechanged event)
				if (volume === 0) {
					media.setMuted(true);
				} else {
					media.setMuted(false);
				}
				media.setVolume(volume);
			},
			mouseIsDown = false,
			mouseIsOver = false;

			// SLIDER
			
			mute
				.hover(function() {
					volumeSlider.show();
					mouseIsOver = true;
				}, function() {
					mouseIsOver = false;
						
					if (!mouseIsDown && mode == 'vertical')	{
						volumeSlider.hide();
					}
				});
            
            var updateVolumeSlider = function (e) {

                var volume = Math.floor(media.volume*100);

				volumeSlider.attr({
					'aria-label': mejs.i18n.t('Volume Slider'),
					'aria-valuemin': 0,
					'aria-valuemax': 100,
					'aria-valuenow': volume,
					'aria-valuetext': volume+'%',
					'role': 'slider',
					'tabindex': 0
				});

			};
			
			volumeSlider
				.bind('mouseover', function() {
					mouseIsOver = true;	
				})
				.bind('mousedown', function (e) {
					handleVolumeMove(e);
					t.globalBind('mousemove.vol', function(e) {
						handleVolumeMove(e);
					});
					t.globalBind('mouseup.vol', function () {
						mouseIsDown = false;
						t.globalUnbind('.vol');

						if (!mouseIsOver && mode == 'vertical') {
							volumeSlider.hide();
						}
					});
					mouseIsDown = true;
						
					return false;
				})
				.bind('keydown', function (e) {
					var keyCode = e.keyCode;
					var volume = media.volume;
					switch (keyCode) {
                        case 38: // Up
                            volume = Math.min(volume + 0.1, 1);
                            break;
                        case 40: // Down
                            volume = Math.max(0, volume - 0.1);
                            break;
                        default:
                            return true;
                    }

					mouseIsDown = false;
					positionVolumeHandle(volume);
					media.setVolume(volume);
					return false;
				});

			// MUTE button
			mute.find('button').click(function() {
				media.setMuted( !media.muted );
			});
            
            //Keyboard input
            mute.find('button').bind('focus', function () {
				volumeSlider.show();
			});

			// listen for volume change events from other sources
			media.addEventListener('volumechange', function(e) {
				if (!mouseIsDown) {
					if (media.muted) {
						positionVolumeHandle(0);
						mute.removeClass('mejs-mute').addClass('mejs-unmute');
					} else {
						positionVolumeHandle(media.volume);
						mute.removeClass('mejs-unmute').addClass('mejs-mute');
					}
				}
				updateVolumeSlider(e);
			}, false);
			
			// mutes the media and sets the volume icon muted if the initial volume is set to 0
			if (player.options.startVolume === 0) {
				media.setMuted(true);
			}
			
			// shim gets the startvolume as a parameter, but we have to set it on the native <video> and <audio> elements
			if (media.pluginType === 'native') {
				media.setVolume(player.options.startVolume);
			}
			
			t.container.on('controlsresize', function() {
				positionVolumeHandle(media.volume);
			});
		}
	});
	
})(mejs.$);

(function($) {

	$.extend(mejs.MepDefaults, {
		usePluginFullScreen: true,
		newWindowCallback: function() { return '';},
		fullscreenText: mejs.i18n.t('Fullscreen')
	});

	$.extend(MediaElementPlayer.prototype, {

		isFullScreen: false,

		isNativeFullScreen: false,

		isInIframe: false,
							
		// Possible modes
		// (1) 'native-native' 	HTML5 video  + browser fullscreen (IE10+, etc.)
		// (2) 'plugin-native' 	plugin video + browser fullscreen (fails in some versions of Firefox)
		// (3) 'fullwindow' 	Full window (retains all UI)
		// usePluginFullScreen = true
		// (4) 'plugin-click' 	Flash 1 - click through with pointer events
		// (5) 'plugin-hover' 	Flash 2 - hover popup in flash (IE6-8)		
		fullscreenMode: '',

		buildfullscreen: function(player, controls, layers, media) {

			if (!player.isVideo)
				return;
				
			player.isInIframe = (window.location != window.parent.location);	
		
			// detect on start
			media.addEventListener('play', function() { player.detectFullscreenMode(); });
				
			// build button
			var t = this,
				hideTimeout = null,
				fullscreenBtn =
					$('<div class="mejs-button mejs-fullscreen-button">' +
						'<button type="button" aria-controls="' + t.id + '" title="' + t.options.fullscreenText + '" aria-label="' + t.options.fullscreenText + '"></button>' +
					'</div>')
					.appendTo(controls)
					.on('click', function() {
						
						// toggle fullscreen
						var isFullScreen = (mejs.MediaFeatures.hasTrueNativeFullScreen && mejs.MediaFeatures.isFullScreen()) || player.isFullScreen;
	
						if (isFullScreen) {
							player.exitFullScreen();
						} else {
							player.enterFullScreen();
						}
					})										
					.on('mouseover', function() {
						
						// very old browsers with a plugin
						if (t.fullscreenMode == 'plugin-hover') {						
							if (hideTimeout !== null) {
								clearTimeout(hideTimeout);
								delete hideTimeout;
							}
	
							var buttonPos = fullscreenBtn.offset(),
								containerPos = player.container.offset();
	
							media.positionFullscreenButton(buttonPos.left - containerPos.left, buttonPos.top - containerPos.top, true);
						}

					})
					.on('mouseout', function() {

						if (t.fullscreenMode == 'plugin-hover') {						
							if (hideTimeout !== null) {
								clearTimeout(hideTimeout);
								delete hideTimeout;
							}
	
							hideTimeout = setTimeout(function() {
								media.hideFullscreenButton();
							}, 1500);
						}

					});

					

			player.fullscreenBtn = fullscreenBtn;

			t.globalBind('keydown',function (e) {
				if (e.keyCode == 27 && ((mejs.MediaFeatures.hasTrueNativeFullScreen && mejs.MediaFeatures.isFullScreen()) || t.isFullScreen)) {
					player.exitFullScreen();
				}
			});
			
			t.normalHeight = 0;
			t.normalWidth = 0;					
					
			// setup native fullscreen event
			if (mejs.MediaFeatures.hasTrueNativeFullScreen) {

				// chrome doesn't alays fire this in an iframe
				var fullscreenChanged = function(e) {
					if (player.isFullScreen) {
						if (mejs.MediaFeatures.isFullScreen()) {
							player.isNativeFullScreen = true;
							// reset the controls once we are fully in full screen
							player.setControlsSize();
						} else {
							player.isNativeFullScreen = false;
							// when a user presses ESC
							// make sure to put the player back into place
							player.exitFullScreen();
						}
					}
				};

				player.globalBind(mejs.MediaFeatures.fullScreenEventName, fullscreenChanged);
			}

		},
		
		detectFullscreenMode: function() {
			
			var t = this,
				mode = '',
				features = mejs.MediaFeatures;
			
			if (features.hasTrueNativeFullScreen && t.media.pluginType === 'native') {
				mode = 'native-native';
			} else if (features.hasTrueNativeFullScreen && t.media.pluginType !== 'native' && !features.hasFirefoxPluginMovingProblem) {
				mode = 'plugin-native';					
			} else if (t.usePluginFullScreen) { 
				if (mejs.MediaFeatures.supportsPointerEvents) {
					mode = 'plugin-click';
					// this needs some special setup
					t.createPluginClickThrough();				
				} else { 
					mode = 'plugin-hover';
				}
				
			} else {
				mode = 'fullwindow';
			}
			
			
			t.fullscreenMode = mode;		
			return mode;
		},
		
		isPluginClickThroughCreated: false,
		
		createPluginClickThrough: function() {
				
			var t = this;
			
			// don't build twice
			if (t.isPluginClickThroughCreated) {
				return;
			}	

			// allows clicking through the fullscreen button and controls down directly to Flash

			/*
			 When a user puts his mouse over the fullscreen button, we disable the controls so that mouse events can go down to flash (pointer-events)
			 We then put a divs over the video and on either side of the fullscreen button
			 to capture mouse movement and restore the controls once the mouse moves outside of the fullscreen button
			*/

			var fullscreenIsDisabled = false,
				restoreControls = function() {
					if (fullscreenIsDisabled) {
						// hide the hovers
						for (var i in hoverDivs) {
							hoverDivs[i].hide();
						}

						// restore the control bar
						t.fullscreenBtn.css('pointer-events', '');
						t.controls.css('pointer-events', '');

						// prevent clicks from pausing video
						t.media.removeEventListener('click', t.clickToPlayPauseCallback);

						// store for later
						fullscreenIsDisabled = false;
					}
				},
				hoverDivs = {},
				hoverDivNames = ['top', 'left', 'right', 'bottom'],
				i, len,
				positionHoverDivs = function() {
					var fullScreenBtnOffsetLeft = fullscreenBtn.offset().left - t.container.offset().left,
						fullScreenBtnOffsetTop = fullscreenBtn.offset().top - t.container.offset().top,
						fullScreenBtnWidth = fullscreenBtn.outerWidth(true),
						fullScreenBtnHeight = fullscreenBtn.outerHeight(true),
						containerWidth = t.container.width(),
						containerHeight = t.container.height();

					for (i in hoverDivs) {
						hoverDivs[i].css({position: 'absolute', top: 0, left: 0}); //, backgroundColor: '#f00'});
					}

					// over video, but not controls
					hoverDivs['top']
						.width( containerWidth )
						.height( fullScreenBtnOffsetTop );

					// over controls, but not the fullscreen button
					hoverDivs['left']
						.width( fullScreenBtnOffsetLeft )
						.height( fullScreenBtnHeight )
						.css({top: fullScreenBtnOffsetTop});

					// after the fullscreen button
					hoverDivs['right']
						.width( containerWidth - fullScreenBtnOffsetLeft - fullScreenBtnWidth )
						.height( fullScreenBtnHeight )
						.css({top: fullScreenBtnOffsetTop,
							 left: fullScreenBtnOffsetLeft + fullScreenBtnWidth});

					// under the fullscreen button
					hoverDivs['bottom']
						.width( containerWidth )
						.height( containerHeight - fullScreenBtnHeight - fullScreenBtnOffsetTop )
						.css({top: fullScreenBtnOffsetTop + fullScreenBtnHeight});
				};

			t.globalBind('resize', function() {
				positionHoverDivs();
			});

			for (i = 0, len = hoverDivNames.length; i < len; i++) {
				hoverDivs[hoverDivNames[i]] = $('<div class="mejs-fullscreen-hover" />').appendTo(t.container).mouseover(restoreControls).hide();
			}

			// on hover, kill the fullscreen button's HTML handling, allowing clicks down to Flash
			fullscreenBtn.on('mouseover',function() {

				if (!t.isFullScreen) {

					var buttonPos = fullscreenBtn.offset(),
						containerPos = player.container.offset();

					// move the button in Flash into place
					media.positionFullscreenButton(buttonPos.left - containerPos.left, buttonPos.top - containerPos.top, false);

					// allows click through
					t.fullscreenBtn.css('pointer-events', 'none');
					t.controls.css('pointer-events', 'none');

					// restore click-to-play
					t.media.addEventListener('click', t.clickToPlayPauseCallback);

					// show the divs that will restore things
					for (i in hoverDivs) {
						hoverDivs[i].show();
					}

					positionHoverDivs();

					fullscreenIsDisabled = true;
				}

			});

			// restore controls anytime the user enters or leaves fullscreen
			media.addEventListener('fullscreenchange', function(e) {
				t.isFullScreen = !t.isFullScreen;
				// don't allow plugin click to pause video - messes with
				// plugin's controls
				if (t.isFullScreen) {
					t.media.removeEventListener('click', t.clickToPlayPauseCallback);
				} else {
					t.media.addEventListener('click', t.clickToPlayPauseCallback);
				}
				restoreControls();
			});


			// the mouseout event doesn't work on the fullscren button, because we already killed the pointer-events
			// so we use the document.mousemove event to restore controls when the mouse moves outside the fullscreen button

			t.globalBind('mousemove', function(e) {

				// if the mouse is anywhere but the fullsceen button, then restore it all
				if (fullscreenIsDisabled) {

					var fullscreenBtnPos = fullscreenBtn.offset();


					if (e.pageY < fullscreenBtnPos.top || e.pageY > fullscreenBtnPos.top + fullscreenBtn.outerHeight(true) ||
						e.pageX < fullscreenBtnPos.left || e.pageX > fullscreenBtnPos.left + fullscreenBtn.outerWidth(true)
						) {

						fullscreenBtn.css('pointer-events', '');
						t.controls.css('pointer-events', '');

						fullscreenIsDisabled = false;
					}
				}
			});


			t.isPluginClickThroughCreated = true;
		},		

		cleanfullscreen: function(player) {
			player.exitFullScreen();
		},

        containerSizeTimeout: null,

		enterFullScreen: function() {

			var t = this;

			if (mejs.MediaFeatures.hasiOSFullScreen) {
				t.media.webkitEnterFullscreen();
				return;
			}

			// set it to not show scroll bars so 100% will work
            $(document.documentElement).addClass('mejs-fullscreen');

			// store sizing
			t.normalHeight = t.container.height();
			t.normalWidth = t.container.width();



			// attempt to do true fullscreen
			if (t.fullscreenMode === 'native-native' || t.fullscreenMode === 'plugin-native') {

				mejs.MediaFeatures.requestFullScreen(t.container[0]);
				//return;

				if (t.isInIframe) {
					// sometimes exiting from fullscreen doesn't work
					// notably in Chrome <iframe>. Fixed in version 17
					setTimeout(function checkFullscreen() {

						if (t.isNativeFullScreen) {
							var percentErrorMargin = 0.002, // 0.2%
								windowWidth = $(window).width(),
								screenWidth = screen.width,
								absDiff = Math.abs(screenWidth - windowWidth),
								marginError = screenWidth * percentErrorMargin;

							// check if the video is suddenly not really fullscreen
							if (absDiff > marginError) {
								// manually exit
								t.exitFullScreen();
							} else {
								// test again
								setTimeout(checkFullscreen, 500);
							}
						}
						
					}, 1000);
				}
				
			} else if (t.fullscreeMode == 'fullwindow') {				
				// move into position
				
			}			
			
			// make full size
			t.container
				.addClass('mejs-container-fullscreen')
				.width('100%')
				.height('100%');
				//.css({position: 'fixed', left: 0, top: 0, right: 0, bottom: 0, overflow: 'hidden', width: '100%', height: '100%', 'z-index': 1000});

			// Only needed for safari 5.1 native full screen, can cause display issues elsewhere
			// Actually, it seems to be needed for IE8, too
			//if (mejs.MediaFeatures.hasTrueNativeFullScreen) {
				t.containerSizeTimeout = setTimeout(function() {
					t.container.css({width: '100%', height: '100%'});
					t.setControlsSize();
				}, 500);
			//}

			if (t.media.pluginType === 'native') {
				t.$media
					.width('100%')
					.height('100%');
			} else {
				t.container.find('.mejs-shim')
					.width('100%')
					.height('100%');	
				
				setTimeout(function() {
					var win = $(window),
						winW = win.width(),
						winH = win.height();
							
					t.media.setVideoSize(winW,winH);			
				}, 500);
			}

			t.layers.children('div')
				.width('100%')
				.height('100%');

			if (t.fullscreenBtn) {
				t.fullscreenBtn
					.removeClass('mejs-fullscreen')
					.addClass('mejs-unfullscreen');
			}

			t.setControlsSize();
			t.isFullScreen = true;

			t.container.find('.mejs-captions-text').css('font-size', screen.width / t.width * 1.00 * 100 + '%');
			t.container.find('.mejs-captions-position').css('bottom', '45px');

			t.container.trigger('enteredfullscreen');
		},

		exitFullScreen: function() {

			var t = this;

            // Prevent container from attempting to stretch a second time
            clearTimeout(t.containerSizeTimeout);

			// firefox can't adjust plugins
			/*
			if (t.media.pluginType !== 'native' && mejs.MediaFeatures.isFirefox) {
				t.media.setFullscreen(false);
				//player.isFullScreen = false;
				return;
			}
			*/

			// come out of native fullscreen
			if (mejs.MediaFeatures.hasTrueNativeFullScreen && (mejs.MediaFeatures.isFullScreen() || t.isFullScreen)) {
				mejs.MediaFeatures.cancelFullScreen();
			}

			// restore scroll bars to document
            $(document.documentElement).removeClass('mejs-fullscreen');

			t.container
				.removeClass('mejs-container-fullscreen')
				.width(t.normalWidth)
				.height(t.normalHeight);

			if (t.media.pluginType === 'native') {
				t.$media
					.width(t.normalWidth)
					.height(t.normalHeight);
			} else {
				t.container.find('.mejs-shim')
					.width(t.normalWidth)
					.height(t.normalHeight);

				t.media.setVideoSize(t.normalWidth, t.normalHeight);
			}

			t.layers.children('div')
				.width(t.normalWidth)
				.height(t.normalHeight);

			t.fullscreenBtn
				.removeClass('mejs-unfullscreen')
				.addClass('mejs-fullscreen');

			t.setControlsSize();
			t.isFullScreen = false;

			t.container.find('.mejs-captions-text').css('font-size','');
			t.container.find('.mejs-captions-position').css('bottom', '');

			t.container.trigger('exitedfullscreen');
		}
	});

})(mejs.$);

(function($) {

	// Speed
	$.extend(mejs.MepDefaults, {

		// We also support to pass object like this:
		// [{name: 'Slow', value: '0.75'}, {name: 'Normal', value: '1.00'}, ...]
		speeds: ['2.00', '1.50', '1.25', '1.00', '0.75'],

		defaultSpeed: '1.00',
		
		speedChar: 'x'

	});

	$.extend(MediaElementPlayer.prototype, {

		buildspeed: function(player, controls, layers, media) {
			var t = this;

			if (t.media.pluginType == 'native') {
				var 
					speedButton = null,
					speedSelector = null,
					playbackSpeed = null,
					inputId = null;

				var speeds = [];
				var defaultInArray = false;
				for (var i=0, len=t.options.speeds.length; i < len; i++) {
					var s = t.options.speeds[i];
					if (typeof(s) === 'string'){
						speeds.push({
							name: s + t.options.speedChar,
							value: s
						});
						if(s === t.options.defaultSpeed) {
							defaultInArray = true;
						}
					}
					else {
						speeds.push(s);
						if(s.value === t.options.defaultSpeed) {
							defaultInArray = true;
						}
					}
				}

				if (!defaultInArray) {
					speeds.push({
						name: t.options.defaultSpeed + t.options.speedChar,
						value: t.options.defaultSpeed
					});
				}

				speeds.sort(function(a, b) {
					return parseFloat(b.value) - parseFloat(a.value);
				});

				var getSpeedNameFromValue = function(value) {
					for(i=0,len=speeds.length; i <len; i++) {
						if (speeds[i].value === value) {
							return speeds[i].name;
						}
					}
				};

				var html = '<div class="mejs-button mejs-speed-button">' +
							'<button type="button">' + getSpeedNameFromValue(t.options.defaultSpeed) + '</button>' +
							'<div class="mejs-speed-selector">' +
							'<ul>';

				for (i = 0, il = speeds.length; i<il; i++) {
					inputId = t.id + '-speed-' + speeds[i].value;
					html += '<li>' + 
								'<input type="radio" name="speed" ' + 
											'value="' + speeds[i].value + '" ' +
											'id="' + inputId + '" ' +
											(speeds[i].value === t.options.defaultSpeed ? ' checked' : '') +
											' />' +
								'<label for="' + inputId + '" ' +
											(speeds[i].value === t.options.defaultSpeed ? ' class="mejs-speed-selected"' : '') +
											'>' + speeds[i].name + '</label>' +
							'</li>';
				}
				html += '</ul></div></div>';

				speedButton = $(html).appendTo(controls);
				speedSelector = speedButton.find('.mejs-speed-selector');

				playbackSpeed = t.options.defaultSpeed;

				media.addEventListener('loadedmetadata', function(e) {
					if (playbackSpeed) {
						media.playbackRate = parseFloat(playbackSpeed);
					}
				}, true);

				speedSelector
					.on('click', 'input[type="radio"]', function() {
						var newSpeed = $(this).attr('value');
						playbackSpeed = newSpeed;
						media.playbackRate = parseFloat(newSpeed);
						speedButton.find('button').html(getSpeedNameFromValue(newSpeed));
						speedButton.find('.mejs-speed-selected').removeClass('mejs-speed-selected');
						speedButton.find('input[type="radio"]:checked').next().addClass('mejs-speed-selected');
					});
				speedButton
					.one( 'mouseenter focusin', function() {
						speedSelector
							.height(
								speedButton.find('.mejs-speed-selector ul').outerHeight(true) +
								speedButton.find('.mejs-speed-translations').outerHeight(true))
							.css('top', (-1 * speedSelector.height()) + 'px');
					});
			}
		}
	});

})(mejs.$);

(function($) {

	// add extra default options
	$.extend(mejs.MepDefaults, {
		// this will automatically turn on a <track>
		startLanguage: '',

		tracksText: mejs.i18n.t('Captions/Subtitles'),

		// By default, no WAI-ARIA live region - don't make a
		// screen reader speak captions over an audio track.
		tracksAriaLive: false,

		// option to remove the [cc] button when no <track kind="subtitles"> are present
		hideCaptionsButtonWhenEmpty: true,

		// If true and we only have one track, change captions to popup
		toggleCaptionsButtonWhenOnlyOne: false,

		// #id or .class
		slidesSelector: ''
	});

	$.extend(MediaElementPlayer.prototype, {

		hasChapters: false,

		cleartracks: function(player, controls, layers, media){
			if(player) {
				if(player.captions) player.captions.remove();
				if(player.chapters) player.chapters.remove();
				if(player.captionsText) player.captionsText.remove();
				if(player.captionsButton) player.captionsButton.remove();
			}
		},
		buildtracks: function(player, controls, layers, media) {
			if (player.tracks.length === 0)
				return;

			var t = this,
				attr = t.options.tracksAriaLive ?
					'role="log" aria-live="assertive" aria-atomic="false"' : '',
				i;

			if (t.domNode.textTracks) { // if browser will do native captions, prefer mejs captions, loop through tracks and hide
				for (i = t.domNode.textTracks.length - 1; i >= 0; i--) {
					t.domNode.textTracks[i].mode = "hidden";
				}
			}
			t.cleartracks(player, controls, layers, media);
			player.chapters =
					$('<div class="mejs-chapters mejs-layer"></div>')
						.prependTo(layers).hide();
			player.captions =
					$('<div class="mejs-captions-layer mejs-layer"><div class="mejs-captions-position mejs-captions-position-hover" ' +
					attr + '><span class="mejs-captions-text"></span></div></div>')
						.prependTo(layers).hide();
			player.captionsText = player.captions.find('.mejs-captions-text');
			player.captionsButton =
					$('<div class="mejs-button mejs-captions-button">'+
						'<button type="button" aria-controls="' + t.id + '" title="' + t.options.tracksText + '" aria-label="' + t.options.tracksText + '"></button>'+
						'<div class="mejs-captions-selector">'+
							'<ul>'+
								'<li>'+
									'<input type="radio" name="' + player.id + '_captions" id="' + player.id + '_captions_none" value="none" checked="checked" />' +
									'<label for="' + player.id + '_captions_none">' + mejs.i18n.t('None') +'</label>'+
								'</li>'	+
							'</ul>'+
						'</div>'+
					'</div>')
						.appendTo(controls);


			var subtitleCount = 0;
			for (i=0; i<player.tracks.length; i++) {
				if (player.tracks[i].kind == 'subtitles') {
					subtitleCount++;
				}
			}

			// if only one language then just make the button a toggle
			if (t.options.toggleCaptionsButtonWhenOnlyOne && subtitleCount == 1){
				// click
				player.captionsButton.on('click',function() {
					if (player.selectedTrack === null) {
						lang = player.tracks[0].srclang;
					} else {
						lang = 'none';
					}
					player.setTrack(lang);
				});
			} else {
				// hover or keyboard focus
				player.captionsButton.on( 'mouseenter focusin', function() {
					$(this).find('.mejs-captions-selector').removeClass('mejs-offscreen');
				})

				// handle clicks to the language radio buttons
				.on('click','input[type=radio]',function() {
					lang = this.value;
					player.setTrack(lang);
				});

				player.captionsButton.on( 'mouseleave focusout', function() {
					$(this).find(".mejs-captions-selector").addClass("mejs-offscreen");
				});

			}

			if (!player.options.alwaysShowControls) {
				// move with controls
				player.container
					.bind('controlsshown', function () {
						// push captions above controls
						player.container.find('.mejs-captions-position').addClass('mejs-captions-position-hover');

					})
					.bind('controlshidden', function () {
						if (!media.paused) {
							// move back to normal place
							player.container.find('.mejs-captions-position').removeClass('mejs-captions-position-hover');
						}
					});
			} else {
				player.container.find('.mejs-captions-position').addClass('mejs-captions-position-hover');
			}

			player.trackToLoad = -1;
			player.selectedTrack = null;
			player.isLoadingTrack = false;

			// add to list
			for (i=0; i<player.tracks.length; i++) {
				if (player.tracks[i].kind == 'subtitles') {
					player.addTrackButton(player.tracks[i].srclang, player.tracks[i].label);
				}
			}

			// start loading tracks
			player.loadNextTrack();

			media.addEventListener('timeupdate',function(e) {
				player.displayCaptions();
			}, false);

			if (player.options.slidesSelector !== '') {
				player.slidesContainer = $(player.options.slidesSelector);

				media.addEventListener('timeupdate',function(e) {
					player.displaySlides();
				}, false);

			}

			media.addEventListener('loadedmetadata', function(e) {
				player.displayChapters();
			}, false);

			player.container.hover(
				function () {
					// chapters
					if (player.hasChapters) {
						player.chapters.removeClass('mejs-offscreen');
						player.chapters.fadeIn(200).height(player.chapters.find('.mejs-chapter').outerHeight());
					}
				},
				function () {
					if (player.hasChapters && !media.paused) {
						player.chapters.fadeOut(200, function() {
							$(this).addClass('mejs-offscreen');
							$(this).css('display','block');
						});
					}
				});

			t.container.on('controlsresize', function() {
				t.adjustLanguageBox();
			});

			// check for autoplay
			if (player.node.getAttribute('autoplay') !== null) {
				player.chapters.addClass('mejs-offscreen');
			}
		},

		setTrack: function(lang){

			var t = this,
				i;

			if (lang == 'none') {
				t.selectedTrack = null;
				t.captionsButton.removeClass('mejs-captions-enabled');
			} else {
				for (i=0; i<t.tracks.length; i++) {
					if (t.tracks[i].srclang == lang) {
						if (t.selectedTrack === null)
							t.captionsButton.addClass('mejs-captions-enabled');
						t.selectedTrack = t.tracks[i];
						t.captions.attr('lang', t.selectedTrack.srclang);
						t.displayCaptions();
						break;
					}
				}
			}
		},

		loadNextTrack: function() {
			var t = this;

			t.trackToLoad++;
			if (t.trackToLoad < t.tracks.length) {
				t.isLoadingTrack = true;
				t.loadTrack(t.trackToLoad);
			} else {
				// add done?
				t.isLoadingTrack = false;

				t.checkForTracks();
			}
		},

		loadTrack: function(index){
			var
				t = this,
				track = t.tracks[index],
				after = function() {

					track.isLoaded = true;

					t.enableTrackButton(track.srclang, track.label);

					t.loadNextTrack();

				};


			$.ajax({
				url: track.src,
				dataType: "text",
				success: function(d) {

					// parse the loaded file
					if (typeof d == "string" && (/<tt\s+xml/ig).exec(d)) {
						track.entries = mejs.TrackFormatParser.dfxp.parse(d);
					} else {
						track.entries = mejs.TrackFormatParser.webvtt.parse(d);
					}

					after();

					if (track.kind == 'chapters') {
						t.media.addEventListener('play', function(e) {
							if (t.media.duration > 0) {
								t.displayChapters(track);
							}
						}, false);
					}

					if (track.kind == 'slides') {
						t.setupSlides(track);
					}
				},
				error: function() {
					t.removeTrackButton(track.srclang);
					t.loadNextTrack();
				}
			});
		},

		enableTrackButton: function(lang, label) {
			var t = this;

			if (label === '') {
				label = mejs.language.codes[lang] || lang;
			}

			t.captionsButton
				.find('input[value=' + lang + ']')
					.prop('disabled',false)
				.siblings('label')
					.html( label );

			// auto select
			if (t.options.startLanguage == lang) {
				$('#' + t.id + '_captions_' + lang).prop('checked', true).trigger('click');
			}

			t.adjustLanguageBox();
		},

		removeTrackButton: function(lang) {
			var t = this;

			t.captionsButton.find('input[value=' + lang + ']').closest('li').remove();

			t.adjustLanguageBox();
		},

		addTrackButton: function(lang, label) {
			var t = this;
			if (label === '') {
				label = mejs.language.codes[lang] || lang;
			}

			t.captionsButton.find('ul').append(
				$('<li>'+
					'<input type="radio" name="' + t.id + '_captions" id="' + t.id + '_captions_' + lang + '" value="' + lang + '" disabled="disabled" />' +
					'<label for="' + t.id + '_captions_' + lang + '">' + label + ' (loading)' + '</label>'+
				'</li>')
			);

			t.adjustLanguageBox();

			// remove this from the dropdownlist (if it exists)
			t.container.find('.mejs-captions-translations option[value=' + lang + ']').remove();
		},

		adjustLanguageBox:function() {
			var t = this;
			// adjust the size of the outer box
			t.captionsButton.find('.mejs-captions-selector').height(
				t.captionsButton.find('.mejs-captions-selector ul').outerHeight(true) +
				t.captionsButton.find('.mejs-captions-translations').outerHeight(true)
			);
		},

		checkForTracks: function() {
			var
				t = this,
				hasSubtitles = false;

			// check if any subtitles
			if (t.options.hideCaptionsButtonWhenEmpty) {
				for (i=0; i<t.tracks.length; i++) {
					if (t.tracks[i].kind == 'subtitles' && t.tracks[i].isLoaded) {
						hasSubtitles = true;
						break;
					}
				}

				if (!hasSubtitles) {
					t.captionsButton.hide();
					t.setControlsSize();
				}
			}
		},

		displayCaptions: function() {

			if (typeof this.tracks == 'undefined')
				return;

			var
				t = this,
				i,
				track = t.selectedTrack;

			if (track !== null && track.isLoaded) {
				for (i=0; i<track.entries.times.length; i++) {
					if (t.media.currentTime >= track.entries.times[i].start && t.media.currentTime <= track.entries.times[i].stop) {
						// Set the line before the timecode as a class so the cue can be targeted if needed
						t.captionsText.html(track.entries.text[i]).attr('class', 'mejs-captions-text ' + (track.entries.times[i].identifier || ''));
						t.captions.show().height(0);
						return; // exit out if one is visible;
					}
				}
				t.captions.hide();
			} else {
				t.captions.hide();
			}
		},

		setupSlides: function(track) {
			var t = this;

			t.slides = track;
			t.slides.entries.imgs = [t.slides.entries.text.length];
			t.showSlide(0);

		},

		showSlide: function(index) {
			if (typeof this.tracks == 'undefined' || typeof this.slidesContainer == 'undefined') {
				return;
			}

			var t = this,
				url = t.slides.entries.text[index],
				img = t.slides.entries.imgs[index];

			if (typeof img == 'undefined' || typeof img.fadeIn == 'undefined') {

				t.slides.entries.imgs[index] = img = $('<img src="' + url + '">')
						.on('load', function() {
							img.appendTo(t.slidesContainer)
								.hide()
								.fadeIn()
								.siblings(':visible')
									.fadeOut();

						});

			} else {

				if (!img.is(':visible') && !img.is(':animated')) {

					//

					img.fadeIn()
						.siblings(':visible')
							.fadeOut();
				}
			}

		},

		displaySlides: function() {

			if (typeof this.slides == 'undefined')
				return;

			var
				t = this,
				slides = t.slides,
				i;

			for (i=0; i<slides.entries.times.length; i++) {
				if (t.media.currentTime >= slides.entries.times[i].start && t.media.currentTime <= slides.entries.times[i].stop){

					t.showSlide(i);

					return; // exit out if one is visible;
				}
			}
		},

		displayChapters: function() {
			var
				t = this,
				i;

			for (i=0; i<t.tracks.length; i++) {
				if (t.tracks[i].kind == 'chapters' && t.tracks[i].isLoaded) {
					t.drawChapters(t.tracks[i]);
					t.hasChapters = true;
					break;
				}
			}
		},

		drawChapters: function(chapters) {
			var
				t = this,
				i,
				dur,
				//width,
				//left,
				percent = 0,
				usedPercent = 0;

			t.chapters.empty();

			for (i=0; i<chapters.entries.times.length; i++) {
				dur = chapters.entries.times[i].stop - chapters.entries.times[i].start;
				percent = Math.floor(dur / t.media.duration * 100);
				if (percent + usedPercent > 100 || // too large
					i == chapters.entries.times.length-1 && percent + usedPercent < 100) // not going to fill it in
					{
					percent = 100 - usedPercent;
				}
				//width = Math.floor(t.width * dur / t.media.duration);
				//left = Math.floor(t.width * chapters.entries.times[i].start / t.media.duration);
				//if (left + width > t.width) {
				//	width = t.width - left;
				//}

				t.chapters.append( $(
					'<div class="mejs-chapter" rel="' + chapters.entries.times[i].start + '" style="left: ' + usedPercent.toString() + '%;width: ' + percent.toString() + '%;">' +
						'<div class="mejs-chapter-block' + ((i==chapters.entries.times.length-1) ? ' mejs-chapter-block-last' : '') + '">' +
							'<span class="ch-title">' + chapters.entries.text[i] + '</span>' +
							'<span class="ch-time">' + mejs.Utility.secondsToTimeCode(chapters.entries.times[i].start, t.options) + '&ndash;' + mejs.Utility.secondsToTimeCode(chapters.entries.times[i].stop, t.options) + '</span>' +
						'</div>' +
					'</div>'));
				usedPercent += percent;
			}

			t.chapters.find('div.mejs-chapter').click(function() {
				t.media.setCurrentTime( parseFloat( $(this).attr('rel') ) );
				if (t.media.paused) {
					t.media.play();
				}
			});

			t.chapters.show();
		}
	});



	mejs.language = {
		codes:  {
			af:'Afrikaans',
			sq:'Albanian',
			ar:'Arabic',
			be:'Belarusian',
			bg:'Bulgarian',
			ca:'Catalan',
			zh:'Chinese',
			'zh-cn':'Chinese Simplified',
			'zh-tw':'Chinese Traditional',
			hr:'Croatian',
			cs:'Czech',
			da:'Danish',
			nl:'Dutch',
			en:'English',
			et:'Estonian',
			fl:'Filipino',
			fi:'Finnish',
			fr:'French',
			gl:'Galician',
			de:'German',
			el:'Greek',
			ht:'Haitian Creole',
			iw:'Hebrew',
			hi:'Hindi',
			hu:'Hungarian',
			is:'Icelandic',
			id:'Indonesian',
			ga:'Irish',
			it:'Italian',
			ja:'Japanese',
			ko:'Korean',
			lv:'Latvian',
			lt:'Lithuanian',
			mk:'Macedonian',
			ms:'Malay',
			mt:'Maltese',
			no:'Norwegian',
			fa:'Persian',
			pl:'Polish',
			pt:'Portuguese',
			// 'pt-pt':'Portuguese (Portugal)',
			ro:'Romanian',
			ru:'Russian',
			sr:'Serbian',
			sk:'Slovak',
			sl:'Slovenian',
			es:'Spanish',
			sw:'Swahili',
			sv:'Swedish',
			tl:'Tagalog',
			th:'Thai',
			tr:'Turkish',
			uk:'Ukrainian',
			vi:'Vietnamese',
			cy:'Welsh',
			yi:'Yiddish'
		}
	};

	/*
	Parses WebVTT format which should be formatted as
	================================
	WEBVTT

	1
	00:00:01,1 --> 00:00:05,000
	A line of text

	2
	00:01:15,1 --> 00:02:05,000
	A second line of text

	===============================

	Adapted from: http://www.delphiki.com/html5/playr
	*/
	mejs.TrackFormatParser = {
		webvtt: {
			pattern_timecode: /^((?:[0-9]{1,2}:)?[0-9]{2}:[0-9]{2}([,.][0-9]{1,3})?) --\> ((?:[0-9]{1,2}:)?[0-9]{2}:[0-9]{2}([,.][0-9]{3})?)(.*)$/,

			parse: function(trackText) {
				var
					i = 0,
					lines = mejs.TrackFormatParser.split2(trackText, /\r?\n/),
					entries = {text:[], times:[]},
					timecode,
					text,
					identifier;
				for(; i<lines.length; i++) {
					timecode = this.pattern_timecode.exec(lines[i]);

					if (timecode && i<lines.length) {
						if ((i - 1) >= 0 && lines[i - 1] !== '') {
							identifier = lines[i - 1];
						}
						i++;
						// grab all the (possibly multi-line) text that follows
						text = lines[i];
						i++;
						while(lines[i] !== '' && i<lines.length){
							text = text + '\n' + lines[i];
							i++;
						}
						text = $.trim(text).replace(/(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig, "<a href='$1' target='_blank'>$1</a>");
						// Text is in a different array so I can use .join
						entries.text.push(text);
						entries.times.push(
						{
							identifier: identifier,
							start: (mejs.Utility.convertSMPTEtoSeconds(timecode[1]) === 0) ? 0.200 : mejs.Utility.convertSMPTEtoSeconds(timecode[1]),
							stop: mejs.Utility.convertSMPTEtoSeconds(timecode[3]),
							settings: timecode[5]
						});
					}
					identifier = '';
				}
				return entries;
			}
		},
		// Thanks to Justin Capella: https://github.com/johndyer/mediaelement/pull/420
		dfxp: {
			parse: function(trackText) {
				trackText = $(trackText).filter("tt");
				var
					i = 0,
					container = trackText.children("div").eq(0),
					lines = container.find("p"),
					styleNode = trackText.find("#" + container.attr("style")),
					styles,
					text,
					entries = {text:[], times:[]};


				if (styleNode.length) {
					var attributes = styleNode.removeAttr("id").get(0).attributes;
					if (attributes.length) {
						styles = {};
						for (i = 0; i < attributes.length; i++) {
							styles[attributes[i].name.split(":")[1]] = attributes[i].value;
						}
					}
				}

				for(i = 0; i<lines.length; i++) {
					var style;
					var _temp_times = {
						start: null,
						stop: null,
						style: null
					};
					if (lines.eq(i).attr("begin")) _temp_times.start = mejs.Utility.convertSMPTEtoSeconds(lines.eq(i).attr("begin"));
					if (!_temp_times.start && lines.eq(i-1).attr("end")) _temp_times.start = mejs.Utility.convertSMPTEtoSeconds(lines.eq(i-1).attr("end"));
					if (lines.eq(i).attr("end")) _temp_times.stop = mejs.Utility.convertSMPTEtoSeconds(lines.eq(i).attr("end"));
					if (!_temp_times.stop && lines.eq(i+1).attr("begin")) _temp_times.stop = mejs.Utility.convertSMPTEtoSeconds(lines.eq(i+1).attr("begin"));
					if (styles) {
						style = "";
						for (var _style in styles) {
							style += _style + ":" + styles[_style] + ";";
						}
					}
					if (style) _temp_times.style = style;
					if (_temp_times.start === 0) _temp_times.start = 0.200;
					entries.times.push(_temp_times);
					text = $.trim(lines.eq(i).html()).replace(/(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig, "<a href='$1' target='_blank'>$1</a>");
					entries.text.push(text);
					if (entries.times.start === 0) entries.times.start = 2;
				}
				return entries;
			}
		},
		split2: function (text, regex) {
			// normal version for compliant browsers
			// see below for IE fix
			return text.split(regex);
		}
	};

	// test for browsers with bad String.split method.
	if ('x\n\ny'.split(/\n/gi).length != 3) {
		// add super slow IE8 and below version
		mejs.TrackFormatParser.split2 = function(text, regex) {
			var
				parts = [],
				chunk = '',
				i;

			for (i=0; i<text.length; i++) {
				chunk += text.substring(i,i+1);
				if (regex.test(chunk)) {
					parts.push(chunk.replace(regex, ''));
					chunk = '';
				}
			}
			parts.push(chunk);
			return parts;
		};
	}

})(mejs.$);

/*
* ContextMenu Plugin
* 
*
*/

(function($) {

$.extend(mejs.MepDefaults,
	{ 'contextMenuItems': [
		// demo of a fullscreen option
		{ 
			render: function(player) {
				
				// check for fullscreen plugin
				if (typeof player.enterFullScreen == 'undefined')
					return null;
			
				if (player.isFullScreen) {
					return mejs.i18n.t('Turn off Fullscreen');
				} else {
					return mejs.i18n.t('Go Fullscreen');
				}
			},
			click: function(player) {
				if (player.isFullScreen) {
					player.exitFullScreen();
				} else {
					player.enterFullScreen();
				}
			}
		}
		,
		// demo of a mute/unmute button
		{ 
			render: function(player) {
				if (player.media.muted) {
					return mejs.i18n.t('Unmute');
				} else {
					return mejs.i18n.t('Mute');
				}
			},
			click: function(player) {
				if (player.media.muted) {
					player.setMuted(false);
				} else {
					player.setMuted(true);
				}
			}
		},
		// separator
		{
			isSeparator: true
		}
		,
		// demo of simple download video
		{ 
			render: function(player) {
				return mejs.i18n.t('Download Video');
			},
			click: function(player) {
				window.location.href = player.media.currentSrc;
			}
		}	
	]}
);


	$.extend(MediaElementPlayer.prototype, {
		buildcontextmenu: function(player, controls, layers, media) {
			
			// create context menu
			player.contextMenu = $('<div class="mejs-contextmenu"></div>')
								.appendTo($('body'))
								.hide();
			
			// create events for showing context menu
			player.container.bind('contextmenu', function(e) {
				if (player.isContextMenuEnabled) {
					e.preventDefault();
					player.renderContextMenu(e.clientX-1, e.clientY-1);
					return false;
				}
			});
			player.container.bind('click', function() {
				player.contextMenu.hide();
			});	
			player.contextMenu.bind('mouseleave', function() {

				//
				player.startContextMenuTimer();
				
			});		
		},

		cleancontextmenu: function(player) {
			player.contextMenu.remove();
		},
		
		isContextMenuEnabled: true,
		enableContextMenu: function() {
			this.isContextMenuEnabled = true;
		},
		disableContextMenu: function() {
			this.isContextMenuEnabled = false;
		},
		
		contextMenuTimeout: null,
		startContextMenuTimer: function() {
			//
			
			var t = this;
			
			t.killContextMenuTimer();
			
			t.contextMenuTimer = setTimeout(function() {
				t.hideContextMenu();
				t.killContextMenuTimer();
			}, 750);
		},
		killContextMenuTimer: function() {
			var timer = this.contextMenuTimer;
			
			//
			
			if (timer != null) {				
				clearTimeout(timer);
				delete timer;
				timer = null;
			}
		},		
		
		hideContextMenu: function() {
			this.contextMenu.hide();
		},
		
		renderContextMenu: function(x,y) {
			
			// alway re-render the items so that things like "turn fullscreen on" and "turn fullscreen off" are always written correctly
			var t = this,
				html = '',
				items = t.options.contextMenuItems;
			
			for (var i=0, il=items.length; i<il; i++) {
				
				if (items[i].isSeparator) {
					html += '<div class="mejs-contextmenu-separator"></div>';
				} else {
				
					var rendered = items[i].render(t);
				
					// render can return null if the item doesn't need to be used at the moment
					if (rendered != null) {
						html += '<div class="mejs-contextmenu-item" data-itemindex="' + i + '" id="element-' + (Math.random()*1000000) + '">' + rendered + '</div>';
					}
				}
			}
			
			// position and show the context menu
			t.contextMenu
				.empty()
				.append($(html))
				.css({top:y, left:x})
				.show();
				
			// bind events
			t.contextMenu.find('.mejs-contextmenu-item').each(function() {
							
				// which one is this?
				var $dom = $(this),
					itemIndex = parseInt( $dom.data('itemindex'), 10 ),
					item = t.options.contextMenuItems[itemIndex];
				
				// bind extra functionality?
				if (typeof item.show != 'undefined')
					item.show( $dom , t);
				
				// bind click action
				$dom.click(function() {			
					// perform click action
					if (typeof item.click != 'undefined')
						item.click(t);
					
					// close
					t.contextMenu.hide();				
				});				
			});	
			
			// stop the controls from hiding
			setTimeout(function() {
				t.killControlsTimer('rev3');	
			}, 100);
						
		}
	});
	
})(mejs.$);
(function($) {
	// skip back button

	$.extend(mejs.MepDefaults, {
		skipBackInterval: 30,
		// %1 will be replaced with skipBackInterval in this string
		skipBackText: mejs.i18n.t('Skip back %1 seconds')
	});

	$.extend(MediaElementPlayer.prototype, {
		buildskipback: function(player, controls, layers, media) {
			var
				t = this,
				// Replace %1 with skip back interval
				backText = t.options.skipBackText.replace('%1', t.options.skipBackInterval),
				// create the loop button
				loop =
				$('<div class="mejs-button mejs-skip-back-button">' +
					'<button type="button" aria-controls="' + t.id + '" title="' + backText + '" aria-label="' + backText + '">' + t.options.skipBackInterval + '</button>' +
				'</div>')
				// append it to the toolbar
				.appendTo(controls)
				// add a click toggle event
				.click(function() {
					media.setCurrentTime(Math.max(media.currentTime - t.options.skipBackInterval, 0));
					$(this).find('button').blur();
				});
		}
	});

})(mejs.$);

/**
 * Postroll plugin
 */
(function($) {

	$.extend(mejs.MepDefaults, {
		postrollCloseText: mejs.i18n.t('Close')
	});

	// Postroll
	$.extend(MediaElementPlayer.prototype, {
		buildpostroll: function(player, controls, layers, media) {
			var
				t = this,
				postrollLink = t.container.find('link[rel="postroll"]').attr('href');

			if (typeof postrollLink !== 'undefined') {
				player.postroll =
					$('<div class="mejs-postroll-layer mejs-layer"><a class="mejs-postroll-close" onclick="$(this).parent().hide();return false;">' + t.options.postrollCloseText + '</a><div class="mejs-postroll-layer-content"></div></div>').prependTo(layers).hide();

				t.media.addEventListener('ended', function (e) {
					$.ajax({
						dataType: 'html',
						url: postrollLink,
						success: function (data, textStatus) {
							layers.find('.mejs-postroll-layer-content').html(data);
						}
					});
					player.postroll.show();
				}, false);
			}
		}
	});

})(mejs.$);

$(document).ready(function(){
	$('.mediaelement_audio,.mediaelement_video').mediaelementplayer();
});

/****** end css file: mediaelement-and-player.js ******/

/****** js file: ai_editmode.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/core/js/ai_editmode.js ******/
/****** last modified: 1463068306 (2016-05-12 10:51:46) ******/
//Samuel Larkin 2016.5.111
//Js to toggle edit mode on an off
var current_edit_mode_state = false;

function toggle_edit_view(toState)
{
	if(toState != null && toState == current_edit_mode_state)return;

	if(!current_edit_mode_state)
	{
		$('.ai_edit_toggle').each(function(){$(this).removeClass('ai_edit_toggle').addClass('ai_edit_toggle_off');});
		$('.ai_edit_toggle_border').each(function(){$(this).removeClass('ai_edit_toggle_border').addClass('ai_edit_toggle_border_off');});
		$('.dynalist_edit_off').each(function(){$(this).removeClass('dynalist_edit_off').addClass('dynalist_edit')});
		$('#edit_toggle_button').css('background-color','red');
		current_edit_mode_state = true;
	}
	else
	{
		$('.ai_edit_toggle_off').each(function() {$(this).removeClass('ai_edit_toggle_off').addClass('ai_edit_toggle');	});
		$('.ai_edit_toggle_border_off').each(function () {$(this).removeClass('ai_edit_toggle_border_off').addClass('ai_edit_toggle_border'); });
		$('.dynalist_edit').each(function(){$(this).removeClass('dynalist_edit').addClass('dynalist_edit_off')});
		$('#edit_toggle_button').css('background-color','transparent');
		current_edit_mode_state = false;
	}
}



$(document).ready(function(){
	$('#edit_toggle_button').show(0);
});

/****** end css file: ai_editmode.js ******/

/****** js file: ai_tracking.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/plugins/ai_tracking/ai_tracking.js ******/
/****** last modified: 1360217446 (2013-02-07 00:10:46) ******/

var ai_track_response = 'unused';
var ai_track_asynchronous = true; //set to false when calling this just before a form post or other dom-destroying event
function ai_track(event_name,key_type,key,owner_id,subkey,lead_tag_list,lead_status,lead_note)
{
	if(typeof(key_type)=='undefined') key_type='';
	if(typeof(key)=='undefined') key_type=0;
	if(typeof(owner_id)=='undefined') owner_id=0;
	if(typeof(subkey)=='undefined') subkey=0;
	if(typeof(lead_tag_list)=='undefined') lead_tag_list='';
	if(typeof(lead_status)=='undefined') lead_status='';
	if(typeof(lead_note)=='undefined') lead_note='';
	
	//current_url: everything after the first slash. So, like: reports/event_tracking
	current_page_request = window.location.href.replace(/^(?:\/\/|[^\/]+)*\//, "");

	$.ajax({
		async: ai_track_asynchronous,
	  url:'ai_tracking_trigger?event_name='+encodeURIComponent(event_name)+'&key_type='+encodeURIComponent(key_type)+'&key='+encodeURIComponent(key)+'&owner_id='+encodeURIComponent(owner_id)+'&subkey='+encodeURIComponent(subkey)+'&lead_tag_list='+encodeURIComponent(lead_tag_list)+'&lead_status='+encodeURIComponent(lead_status)+'&lead_note='+encodeURIComponent(lead_note)+'&current_page_request='+encodeURIComponent(current_page_request),
	  success: function(data){
	  	ai_track_response = data;
	  },
	  fail: function() { alert("error"); }
	});
}
/****** end css file: ai_tracking.js ******/

/****** js file: ai_ajax.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/plugins/ai_ajax/ai_ajax.js ******/
/****** last modified: 1408031264 (2014-08-14 10:47:44) ******/
$(document).ready(function(){
	// This is for links
	$(document).on("click", ".ai_ajax_container INPUT.cancel_button, .ai_ajax_container INPUT[type='button'].te, .ai_ajax_container a.te_ajax_link, .ai_ajax_container a.te, .ai_ajax_container a.te_asearch_link, .ai_ajax_container a.te_button, .ai_ajax_container a.te_fieldname", function(event){
		
		// Stop the normal event from firing
		event.preventDefault();
		
		// Define parameters
		var href = this.href;
		var onclick = $(this).data("onclick");
		
		// Determine parent container's ID
		var container_id = $(this).closest(".ai_ajax_container").attr("id");
		
		if(href !== undefined) {
			// This is a link, we should use it	
			ai_ajax_goto_link(href,{},"get",container_id);
		}
		
		if(onclick !== undefined) {
			// This is an onclick event and needs to be intercepted
			ai_ajax_goto_link(onclick,{},"get",container_id);
		}

		return false;
	})

	// This is for form submissions
	$(document).on("submit", ".ai_ajax_container FORM", function(event){
		
		// Stop the normal event from firing
		event.preventDefault();
		
		// Define parameters
		var action = $(this).attr('action');
  	var method = $(this).attr('method');
		var string = $(this).serialize();

		// Determine parent container's ID
		var container_id = $(this).closest(".ai_ajax_container").attr("id");
		
		if(action !== undefined) {
			
			// For some reason jquery's serialize function doesn't like the confirm delete form post, so, let's build it manually
			if(string == "") {
				// Indicator to know it was manual, as well as easy hack to not have to worry about the &
				string += "m";

				// get all the inputs into an array.
				$($(this).find(":input")).each(function() {
					string += "&" + $(this).attr("name") + "=" + $(this).val();
				});
			}
	
			ai_ajax_goto_link(action,string,method,container_id);
		}

		return false;
	})
	
	// Function to add class to links that are just in the table edit
	$(".ai_ajax_container a").each(function() {
		$(this).addClass("te_ajax_link");
	})
	
	// Unbind onclick events
	translate_onclicks();
});

// This removes onclick events from all onclicks, so, that the browser doesn't process them
function translate_onclicks()
{
	$(".ai_ajax_container INPUT.te, .ai_ajax_container INPUT.cancel_button").each(function() {
		var onclick = $(this).attr("onclick");
		if(onclick !== undefined) {
			onclick = onclick.match(/(window|document)[.]location\s*=\s*'([^']+)'/i);
			if(onclick[2] !== undefined) {
				$(this).attr("data-onclick",onclick[2]).attr("onclick",null).unbind();
			}
		}
	})
}

// This is the actual ajax functionality
function ai_ajax_goto_link(href,data,method,container_id)
{
	// Set opacity of container to show action
	$("#" + container_id).css({"opacity":"0.5"});

	console.log("Calling ai_ajax to go to: " + href);

	if(method == "post") {
		$.post(href,data,function(response){
			$("#" + container_id).css({"opacity":"1"}).html(response)
			translate_onclicks();
		}) 
	} else {
		$.get(href,data,function(response){
			$("#" + container_id).css({"opacity":"1"}).html(response)
			translate_onclicks();
		}) 
	}
}
/****** end css file: ai_ajax.js ******/

/****** js file: ajax.parallel.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/plugins/ajax/ajax.parallel.js ******/
/****** last modified: 1411149480 (2014-09-19 12:58:00) ******/
//j0zf 2006.3.12
//ajax.parallel.js
//my normal ajax.js library barfed on parallel requests because there was only 1 request object
/**
 * METHOD I:   ajax_get_request( ajax_url, ajax_handler, set_loading_id, forget_previous_requests )
 *	-- this method uses XMLHttpRequest() and processes commands
 *
 * METHOD II:  ajax_post_request( ajax_url, ajax_data, ajax_handler, set_loading_id, forget_previous_requests )
 *	-- this method uses XMLHttpRequest() and processes commands
 *	-- this method is better than ajax_get_request() when submitting a large amount of data
 *	-- data should be in url encoded format with escape()'d values ( e.g. variable1=value1&another_var=someother+value )
 *
 * METHOD III: ajax_call_js( unique_element_id, src_url, allow_reload_flag )
 *	-- this method immediatly runs as javascript the returned data
 *
 * AJAX CGI RETURN COMMANDS:
 *	-- Format:  ajax command|cgi returned ajax data
 *	-- by default the "ajax command" is just the "element id" who's innerHTML will be replaced
 *	   by the "cgi returned ajax data" text or html.
 *
 * SPECIAL CGI RETURN COMMANDS:
 *	-- ajax_error : reports error string
 *		* if the "ajax_error" element id is available then it will replace it's innerHTML with
 *		  the error text "cgi returned ajax data".
 *		* if the "ajax_error" element id is not available then it will do an alert('cgi returned ajax data / error text');
 *	-- ajax_run_script : will eval('cgi returned ajax data / javascript');
 *
 */

//USED TO SYNCHRONIZE THE PARALLEL ARRAYS
var ajax_requests_count = 0;

//AN ARRAY THAT CONTAINS THE REQUESTED AJAX OBJECTS
var ajax_requests = new Array();

//KEEP TRACK OF HANDLERS SO WE DISPATCH THE CORRECT ONE
//parallel array to ajax_requests
var ajax_handlers = new Array();

function ajax_createRequestObject( ajax_handler )
{
	var i = ajax_requests_count++;
    var ajax_http;
    var browser = navigator.appName;

	//CREATE THE AJAX REQUEST OBJECT
	if( browser == "Microsoft Internet Explorer" && window.ActiveXObject )
	{
        ajax_http = new ActiveXObject("Microsoft.XMLHTTP");
    }
	else
	{
        ajax_http = new XMLHttpRequest();
    }

	//SETUP THE HANDLER DISPATCHER
	ajax_http.onreadystatechange = ajax_handler_dispatcher;

	//ADD THE HANDLER
	if( ajax_handler == null )
	{
		ajax_handlers[i] = ajax_handler_default;
	}
	else
	{
		ajax_handlers[i] = ajax_handler;
	}

	//ADD THE REQUEST OBJECT
	ajax_requests[i] = ajax_http;
    return ajax_http;
}

function ajax_handler_dispatcher()
{
	var i = 0;
	var ajax_http = null;
	var ajax_handler = null;

	if( ajax_requests_count < 1 ) return;

	for( i = (ajax_requests_count - 1); i >= 0; i-- )
	{
		if( ajax_requests[i] && ajax_handlers[i] && ajax_requests[i].readyState == 4 )
		{
			ajax_http = ajax_requests[i];
			ajax_requests[i] = null;
			ajax_handler = ajax_handlers[i];
			ajax_handlers[i] = null;

			if ( ajax_http.status == 200 )
			{
				//alert( 'RESPONSE TEXT:[' + ajax_http.responseText + ']' );
				ajax_handler( ajax_http );
			}
			else if ( ajax_http.status == 403 && ajax_http.statusText == "Logged Out" )
			{
				window.location = 'login.php';
			}
			else
			{
				ajax_report_error( 'Ajax Error - Status Code: "' + ajax_http.status + '" Status Text: "' + ajax_http.statusText + '".' );
			}
		}
	}
}

//FORGET ALL PREVIOUS AJAX REQUESTS
function ajax_forget_requests()
{
	ajax_requests_count = 0;
	ajax_requests = new Array();
	ajax_handlers = new Array();
}

//VERY SIMPLE TO USE DEFAULT HANDLER
//CUSTOM HANDLERS CAN BE SPECIFIED WHEN MAKING THE REQUESTS
//Make requests by:
//  ajax_get_request( ajax_url, ajax_handler, set_loading_id, forget_previous_requests )
//  or
//  ajax_post_request( ajax_url, ajax_data, ajax_handler, set_loading_id, forget_previous_requests )
function ajax_handler_default( ajax_http )
{
	var sep_loc = ajax_http.responseText.indexOf( '|' );
	var response_name = '';
	var response_value = '';

	if( sep_loc > 0 )
	{
		response_name = ajax_trim_str( ajax_http.responseText.substr( 0, sep_loc ) );
		response_value = ajax_http.responseText.substr( 1 + sep_loc );

		if( response_name == 'ajax_error' )
		{
			//REPORT THE ERROR
			ajax_report_error( response_value );
		}
		else if( response_name == 'ajax_run_script' )
		{
			ajax_run_script( response_value );
		}
		else
		{
			//WRITE THE RESPONSE TO THE SPECIFIED ELEMENT
			if( ajax_set_value( response_name, response_value ) )
			{
				ajax_clear_error();
			}
			else
			{
				ajax_report_error( 'Error: Ajax Element Not Found (' + response_name + ').' );
			}
		}
	}
	else
	{
		ajax_report_error( 'Error: Invalid Ajax Response.' );
	}
}

function ajax_report_error( str )
{
	var ajerr = document.getElementById('ajax_error');
	/*if ( ai.visor )
	{
		ai.visor.set(str);
		ai.visor.show();
	}
	else if ( ai.toaster )
	{
		ai.toaster.set(str);
		ai.toaster.show();
	}*/
	if ( ai.notification )
	{
		ai.notification.error("AJAX Error", str, true);
	}
	else if ( ajerr )
	{
		ajerr.innerHTML = str;
	}
	else
	{
		alert( str );
	}
}

function ajax_clear_error()
{
	var ajerr = document.getElementById('ajax_error');
	if( ajerr )
	{
		ajerr.innerHTML = "";
	}
}

function ajax_run_script( str )
{
	eval(str);
}

function ajax_trim_str( str )
{
   str = str.replace(/^\s+/, '');
   str = str.replace(/\s+$/, '');
   return str;
}

/**
 * SET LOADING IMAGE
 */
function ajax_set_loading( loading_id )
{
	loading_id = document.getElementById( loading_id );
	if(loading_id)
	{
		loading_id.innerHTML = '<div class="ajax_loading_icon"><span class="ajax_loading_icon">Loading...</span></div>';
	}
}

/**
 * GET AN ELEMENTS VALUE.... Never mind the element's type...
 * -- add types as needed..
 * -- Not currently supported:
 *		- radio buttons
 *		- select tags with "multselect" enabled
 *		- and more...
 */
function ajax_get_value( element_id )
{
	var e = document.getElementById( element_id );
	var v = '';
	if( !e ){ return null; }

	switch( e.tagName.toUpperCase() )
	{
		case 'INPUT':
			switch( e.type.toUpperCase() )
			{
				case 'TEXT':
					v = e.value;
					break;
				case 'HIDDEN':
					v = e.value;
					break;
				case 'CHECKBOX':
					v = ( e.checked ? e.value : '' );
					break;
				default:
					v = e.value;
					break;
			}
			break;
		case 'TEXTAREA':
			v = e.value;
			break;
		case 'SELECT':
			v = e.options[ e.selectedIndex ].value;
			break;
		default:
			v = e.innerHTML;
			break;
	}

	return v;
}

/**
 * SET AN ELEMENTS VALUE.... Never mind the element's type...
 * -- add types as needed..
 */
function ajax_set_value( element_id, v )
{
	var e = document.getElementById( element_id );
	if( !e ){ return null; }

	switch( e.tagName.toUpperCase() )
	{
		case 'INPUT':
			switch( e.type.toUpperCase() )
			{
				case 'TEXT':
					e.value = v;
					break;
				default:
					e.value = v;
					break;
			}
			break;
		default:
			e.innerHTML = v;
			break;
	}

	return v;
}

/**
 * CALL A JAVASCRIPT FILE
 *	-- yes this can have a PHP or other CGI extension ( .js not required )
 *	-- Output will be ran as Javascript
 *
 *	unique_element_id : mangle away.. make it origninal to the page
 *	allow_reload_flag : if true then unique_element_id may be replaced by a new script load
 *
 */
function ajax_call_js( unique_element_id, src_url, allow_reload_flag )
{
	if( !allow_reload_flag && document.getElementById( unique_element_id ) )return;

	var head = document.getElementsByTagName('head').item(0);
	var script = document.createElement('script');
	script.src = src_url;
	script.type = 'text/javascript';
	script.language = 'javascript';
	script.id = unique_element_id;
	head.appendChild(script);
}

/**
 * USE "GET" METHOD TO MAKE HTTP REQUEST
 * ajax_handler : This is the function which will handle the request when retured as success
 * set_loading_id : (optional) This is the element id who's innerHTML will be replaced by the loading icon
 * forget_previous_requests : Destroys the handler queue before making request
 *
 */
function ajax_get_request( ajax_url, ajax_handler, set_loading_id, forget_previous_requests )
{
	if( !ajax_handler ){ ajax_report_error( 'Error: Invalid Ajax Handler Javascript Function.' ); return; }
	if( forget_previous_requests == true ){ ajax_forget_requests(); }
	if( set_loading_id && set_loading_id != '' ){ ajax_set_loading( set_loading_id ); }

	var ajax_http = ajax_createRequestObject( ajax_handler );

    ajax_http.open( 'get', ajax_url );
	ajax_http.send( null );
}

/**
 * USE "POST" METHOD TO MAKE HTTP REQUEST
 * ajax_data : Contains the POST data.
 *	-- this method is better than ajax_get_request() when submitting a large amount of data
 *	-- data should be in url encoded format with escape()'d values ( e.g. variable1=value1&another_var=someother+value )
 * ajax_handler : This is the function which will handle the request when retured as success
 * set_loading_id : (optional) This is the element id who's innerHTML will be replaced by the loading icon
 * forget_previous_requests : Destroys the handler queue before making request
 *
 */
function ajax_post_request( ajax_url, ajax_data, ajax_handler, set_loading_id, forget_previous_requests )
{
	if( !ajax_handler ){ ajax_report_error( 'Error: Invalid Ajax Handler Javascript Function.' ); return; }
	if( forget_previous_requests == true ){ ajax_forget_requests(); }
	if( set_loading_id && set_loading_id != '' ){ ajax_set_loading( set_loading_id ); }

	var ajax_http = ajax_createRequestObject( ajax_handler );

    ajax_http.open( 'post', ajax_url );
    ajax_http.setRequestHeader( 'Content-Type', 'application/x-www-form-urlencoded' );
	ajax_http.send( ajax_data );
}

/**
 * Ajax Handler that expects a JSON string in the response representing a JavaScript object
 * This function is intended to be an alternative to ajax_handler_default()
 * and handles multiple script/error/DOM-inserts
 * Parsing is done using an external JSON parser library (included) and thus
 * should not encounter security issues presented when using the simple eval() approach
 *
 * Each object member is the ID of the HTML element in the DOM (no error is displayed if not found)
 * Each object member's values will be placed into their respective HTML elements
 * Because there are multiple instances, this will not throw errors if
 *
 * - JonJon <jon@apogeeinvent.com> 2009.05.10
 */
function ajax_handler_JSON(ajax_http)
{
	// Legacy error handling found: go backward to ajax_handler_default()
	if ( ajax_http.responseText.match(/^\s*ajax_error\|/) )
	{
		return ajax_handler_default(ajax_http);
	}
	try
	{
		var obj = JSON.parse(ajax_http.responseText); // throws errors
		for ( var key in obj )
		{
			// An error occured, stop everything now!
			if ( key == "ajax_error" )
			{
				ajax_report_error(obj[key]);
				return;
			}
			// Found a run command
			else if ( key == "ajax_run_script" )
			{
				ajax_run_script(obj[key]);
			}
			// Insert into the DOM
			else
			{
				ajax_set_value(key, obj[key])
			}
		}
		ajax_clear_error();
	}
	catch ( e )
	{
		ajax_report_error("Error: Could not parse JSON response");
	}
}

/**
 * Ajax Handler that expects to do nothing and will do nothing
 *
 * - JonJon <jon@apogeeinvent.com> 2009-09-04
 */
function ajax_handler_noop() { }

/****** end css file: ajax.parallel.js ******/

/****** js file: jquery.jonbox.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/plugins/jonbox/jquery.jonbox.js ******/
/****** last modified: 1445445038 (2015-10-21 11:30:38) ******/
/**
 * jquery.jonbox.js
 *  ~ Jon ????.??.??
 *  ~ JosephL 2008.10.24
 *
 * jQuery needs to be included on the page including this script... v 1.2.6 or higher
 *
 * 2008.10.24
 *  - Added jonbox alert
 *  - Added jonbox form
 *  - Uses ai javascript.parallel.js now
 *  - Tested working, IE6, IE7, FireFox(OS X), Safari(OS X), Opera(OS X)
 *
 * 2008.10.26
 *  - Added re-positioning support, now finds position bassed off of viewport
 *  - Added better resize/scroll support
 *  - Added jonbox_open_div
 *
 * 2008.10.27
 *  - Added jonbox_open_img
 *
 * 2008.11.05
 *  - Add feature to hide all elements with class="jonbox_hide" when jonbox is active
 *    and show when jonbox is closed
 **/
var jonbox_close_image = "includes/plugins/jonbox/images/jonbox_close.png";
var jonbox_close_hot_image = "includes/plugins/jonbox/images/jonbox_close_hot.png";
var jonbox_loading_image = "includes/plugins/jonbox/images/jonbox_loading.gif";

/** var bool Set to TRUE at anytime to make JonBox a non-closeable, persistent pop-up */
var jonbox_persistent = false;

if(typeof jQuery!='undefined') {
	$(document).ready(init_jonbox);
} else {
	// alert('Error: jonbox requires jQuery to be included.');
}

/**
 * Sets up the hidden div to display the jonbox
 * Also binds the click to all "a" objects withs rel="jonbox"
 **/
function init_jonbox(e)
{
	init_links();

	var img1 = new Image();
	img1.src = jonbox_close_image;

	var img2 = new Image();
	img2.src = jonbox_close_hot_image;

	var img_load = new Image();
	img_load = jonbox_loading_image;

	if($('#jonbox_jblock').length <= 0) {
		$("<div />").attr("id", "jonbox_jblock").appendTo("body").hide().css({
			backgroundColor: "#000",
			opacity: 0,
			width: "100%",
			position: "absolute",
			left: 0,
			top: 0,
			zIndex: 600
		}).click(close_jonbox);
	}
	// .click(close_jonbox) // append to above call to enable clicking outside the box to close.

	if($('#jonbox_loading').length <= 0) {
		$("<div />").attr("id", "jonbox_loading").appendTo("body").hide().css({
			backgroundColor:"#656565",
			color: "#f0f0f0",
			fontFamily: "'Lucida Grande', Arial, Helvetica, sans-serif",
			fontSize: "1.5em",
			fontWeight: 700,
			position: "absolute",
			left: "-9999px",
			top: "-9999px",
			zIndex: 700,
			border: "solid 2px #3F3F3F",
			padding: "5px 10px 5px 10px"
		}).html($("<img />").attr({
			src: jonbox_loading_image,
			alt: "Loading",
			title: "Loading"
		})).click(close_jonbox); // If error occurs, they can click loading to get out of jonbox
	}

	if($('#jonbox').length <= 0) {
		$("<div />").attr("id", "jonbox").appendTo("body").hide().css({
			backgroundColor: "#f0f0f0",
			opacity: 0,
			position: "absolute",
			left: 0,
			top: 0,
			zIndex: 1000,
			"border-radius": "10px",
			"border": "2px solid #ccc",
			"box-shadow": "2px 2px 10px #000"
		});
	}

	if($('#jonbox_titlebar').length <= 0) {
		$("<div />").attr("id", "jonbox_titlebar").appendTo("#jonbox").css({
			//background: "transparent url(includes/plugins/jonbox/images/title_bar_bg.png) repeat-x -15px bottom",
			textAlign: "right",
			padding: "3px",
			"border-radius": "10px 10px 0 0"
		});
	}

	if($('#jonbox_content').length <= 0) {
		$("<div />").attr("id", "jonbox_content").appendTo("#jonbox").css({
			background: "#ffffff",
			padding: "15px",
			"border-radius": "0 0 10px 10px"
		});
	}

	// only append if it does not exist already
	if($('#jonbox_close_x').length <= 0) {
		$("<img />").attr({
			src: jonbox_close_image,
			alt: "x",
			title: "Close"
		}).attr('id', 'jonbox_close_x').css({
			cursor: "pointer"
		}).hover(function () {
			this.src = jonbox_close_hot_image;
		}, function () {
			this.src = jonbox_close_image;
		}).appendTo("#jonbox_titlebar").click(close_jonbox);
	}

	if ( $("#jonbox_quick_content").length <= 0 ) {
		$("<div />").attr("id", "jonbox_quick_content").appendTo("body").hide();
	}
}

function init_links()
{
	/*$("a").each(function(i) {
		if ( $(this).attr("rel") == "jonbox" ) {
			$(this).bind("click", {aobj: this}, open_jonbox_from_object);
		}
	});*/

	// Traditional rel="jonbox" anchors
	$("body").on("click",'a[rel="jonbox"]',function(e) {
		e.data = {aobj:this};
		open_jonbox_from_object(e);
		return false;
	});

	// Delegated rel="jonbox_delegated" anchors
	// -----
	// The actual event is handled by the DOM element with rel="jonbox_delegator"
	// This will allow AJAX drawn anchors with rel="jonbox_delegated" to fire open_jonbox()
	// even after initial page load when contained inside the rel="jonbox_delegator" element
	$('[rel="jonbox_delegator"]').on("click", 'a[rel="jonbox_delegated"]', function( e ) {
		e.data = {aobj:this};
		open_jonbox_from_object(e);
		return false;
	});
}

/**
 * Opens a jonbox from a "a href=" object.
 *
 * @param: e : the object
 **/
function open_jonbox_from_object(e)
{
	e.preventDefault();
	var opts = {};
	if ( $(e.data.aobj).data("jonboxWidth") ) {
		opts.width = $(e.data.aobj).data("jonboxWidth");
	}
	if ( $(e.data.aobj).data("jonboxHeight") ) {
		opts.height = $(e.data.aobj).data("jonboxHeight");
	}
	return open_jonbox(e.data.aobj.href, "", opts);
}

/**
 * Opens a jonbox, retiving the content via. ajax.parallel and handling it properly for
 * the jonbox system
 *
 * @param: url : the url to retive & display
 * @param: post_str OPTIONAL: post string to submit with the http call using post
 **/
function open_jonbox(url, post_str, opts)
{
	$("#jonbox_jblock").css({
		height: $(document).height()
	}).show(1, function() {
		$(this).animate({
			opacity: 0.50
		}, 200, null, function() {
			show_loading();
			if ( $.isPlainObject(opts) ) {
				if ( typeof opts.width != "undefined" ) {
					$("#jonbox_content").css({"width":opts.width});
				} else {
					$("#jonbox_content").css({"width":"auto"});
				}
				if ( typeof opts.height != "undefined" ) {
					$("#jonbox_content").css({"height":opts.height});
				} else {
					$("#jonbox_content").css({"height":"auto"});
				}
			}
			// use AI ajax handler instead of jQuery handler
			if(typeof post_str == "undefined" || post_str == "") {
				ajax_get_request(url, jonbox_ajax_call_return);
			} else {
				ajax_post_request(url, post_str, jonbox_ajax_call_return);
			}
		});
	});
	return false;
}

/**
 * Handles AI standard ajax returns better
 * Displays results nicely in the jonbox
 **/
function jonbox_ajax_call_return( ajax_http )
{
	var sep_loc = ajax_http.responseText.indexOf( '|' );
	var response_name = '';
	var response_value = '';

	if( sep_loc > 0 && sep_loc < 256 )
	{
		response_name = ajax_trim_str( ajax_http.responseText.substr( 0, sep_loc ) );
		response_value = ajax_http.responseText.substr( 1 + sep_loc );

		if( response_name == 'ajax_error' )
		{
			//REPORT THE ERROR
			var err_msg = '<table><tr><td valign="top" style="padding-right:20px;"><img src="includes/plugins/jonbox/images/alert_red_48.png" style="align:left;margin-left:20x;" align="left" /></td>';
			err_msg +='<td style="width:400px;color:#FF0000;">';
			err_msg += response_value + '<br><div style="text-align:right;padding-left:10px;height:20px;"><input type="button" onclick="close_jonbox()" value="OK"></div></td>';
			$("#jonbox_content").html(err_msg);
		}
		else if( response_name == 'ajax_run_script' )
		{
			close_jonbox();
			ajax_run_script( response_value );
		}
		else
		{
			// Ingore the set location and set the response as the content.
			$("#jonbox_content").html(response_value);
		}
	}
	else
	{
		// jonbox support full page fetches, no error in this case
		$("#jonbox_content").html(ajax_http.responseText);
	}

	$.event.trigger({
		type: "jonbox-ajaxStop",
		message: "JonBox has finished AJAX",
		time: new Date()
	});

	// Everything is ready, show the jonbox!
	show_jonbox();
}

/**
 * Hides the loading icon then animates in the the jonbox
 **/
function show_jonbox(hide_frame_and_maximize)
{
	// Set any special items with class jonbox_hide to be hidden
	// These items may interfear with the jonbox
	$('.jonbox_hide').css('visibility','hidden');

	$.event.trigger({
		type: "jonbox-showStart",
		message: "JonBox is beginning to show",
		time: new Date()
	});

	// Show the jobbox with full content
	$("#jonbox_loading").fadeOut("fast", function() {
		$("#jonbox").show(1, function() {
			position("jonbox");
			var top = $(this).css('top');
			top = parseInt(top);
			$(this).css({
				top: (top - 20) + "px"
			}).animate({
				top: (top + 20) + "px",
				opacity: 1
			}, 300);

			if(hide_frame_and_maximize == true) {
				// Special logic to hide frame
				if($('#jonbox').length > 0) {
					$("#jonbox").css({
						background: "none",
						width: "90%",
						height: "90%",
						"border-radius": "0px",
						"border": "none",
						"box-shadow": "none"
					});
				}
				if($('#jonbox_content').length > 0) {
					$("#jonbox_content").css({
						padding: 0
					});
				}
			} 
			else {
				// Reset jonbox next time, this is the same as init, so, if init changes, this needs to change as well
				// This was removed because it was causing nondesired behavior, where the jonbox would move from the left side of the screen instead of the top
			/*	if($('#jonbox').length > 0) {
					$("#jonbox").css({
						backgroundColor: "#f0f0f0",
						opacity: 0,
						position: "absolute",
						left: 0,
						top: 0,
						width: "auto",
						height: "auto",
						zIndex: 1000,
						"border-radius": "10px",
						"border": "2px solid #ccc",
						"box-shadow": "2px 2px 10px #000"
					});
				}*/

				if($('#jonbox_content').length > 0) {
					$("#jonbox_content").css({
						background: "#ffffff",
						padding: "15px",
						"border-radius": "0 0 10px 10px"
					});
				}
			}

			// Go Ahead and reposition
			jonbox_reposition_resize();

			$(window).resize(jonbox_reposition_resize).scroll(jonbox_reposition_scroll);

			$.event.trigger({
				type: "jonbox-showComplete",
				message: "JonBox is finished showing",
				time: new Date()
			});

			// Logic to make dynamic areas work as expected
			if ( typeof disable_all_dynamic_areas_not_part_of_jonbox != "undefined" ) {
				disable_all_dynamic_areas_not_part_of_jonbox();
			}
			timeout = setTimeout('build_dyna_area_elements(); update_dynamic_areas_NOW()', 500);
		});
	});
}

function show_loading()
{
	position("jonbox_loading");
	$("#jonbox_loading").fadeIn("fast");
}

function position(div_id)
{
	set_position(div_id, false);
}

/**
 * bounded to window resize event, move the jonbox
 **/
var reposition_active = false;
var scroll_x = 0;
var scroll_y = 0;
var vp_x = 0;
var vp_y = 0;
function jonbox_reposition_resize(e)
{
	// Get active window
	var win = get_window_sizes();
	scroll_offset_x = win.scroll_offset_x;
	scroll_offset_y = win.scroll_offset_y;
	vp_width = win.vp_width;
	vp_height = win.vp_height;

	// If it does not match, then the effect is still in play
	// IE only, if other browser run the event because scroll
	// and resize trigger once rather than over and over
	if(navigator.userAgent.indexOf("MSIE") == -1 || (
		win.scroll_offset_x == scroll_x
		&& win.scroll_offset_y == scroll_y
		&& win.vp_width == vp_x
		&& win.vp_height == vp_y)) {
			// Matched, so re-position the window
			$("#jonbox_jblock").css({
				height: $(document).height()
			});
			set_position('jonbox', true);
		}
		else {
			reposition_active = true;
			scroll_x = win.scroll_offset_x;
			scroll_y = win.scroll_offset_y;
			vp_x = win.vp_width;
			vp_y = win.vp_height;
		}
}

var timer = false;
function jonbox_reposition_scroll(e)
{
	// Get active window
	var win = get_window_sizes();
	scroll_offset_x = win.scroll_offset_x;
	scroll_offset_y = win.scroll_offset_y;
	vp_width = win.vp_width;
	vp_height = win.vp_height;

	// If it does not match, then the effect is still in play
	if(win.scroll_offset_x == scroll_x
		&& win.scroll_offset_y == scroll_y
		&& win.vp_width == vp_x
		&& win.vp_height == vp_y) {
			// Matched, so re-position the window
			$("#jonbox_jblock").css({
				height: $(document).height(),
				width: $(document).width()
			});
			set_position('jonbox', true);
			timer = false;
		}
		else {
			reposition_active = true;
			scroll_x = win.scroll_offset_x;
			scroll_y = win.scroll_offset_y;
			vp_x = win.vp_width;
			vp_y = win.vp_height;
			// timeout and try again (only once)
			// some browswer act like they are trying over and over but never
			// successed in running the effect
			if(!timer) {
				setTimeout(jonbox_reposition_scroll, 400);
				timer = true;
			}
		}
}

/**
 * Positions the jonbox (1/3 centering vertically, absolute centering horizontally)
 * param string div_id  the id of the jonblock
 * 2008.01.08 - If box height is greater than 1/3 center viewing space, simplay display 25 pixles down ~JosephL
 * 2008.10.26 - Taken from jonbox 1.0, added animation effects ~ JosephL
 * returns void
 */
function set_position(div_id, animate)
{
	var jonbox = document.getElementById(div_id);
	
	var scroll_offset_x, scroll_offset_y, vp_width, vp_height, jonbox_height, jonbox_width;

	var win = get_window_sizes();
	scroll_offset_x = win.scroll_offset_x;
	scroll_offset_y = win.scroll_offset_y;
	vp_width = win.vp_width;
	vp_height = win.vp_height;

	// Computer jonbox dimensions
	jonbox_height = jonbox.offsetHeight;
	jonbox_width = jonbox.offsetWidth;

	// Set the CSS to position the jonbox - x axis
	var jonbox_x = parseInt((vp_width - jonbox.offsetWidth) / 2 + scroll_offset_x);
	
	// Set the CSS to position the jonbox - y axis
	var jonbox_y = 0;
	var static_pos = false;

	if(jonbox_height+25 > vp_height)
	{
		// display 25 from top of viewport
		if(jonbox.style.top == "0pt" || jonbox.style.top == "0" ||jonbox.style.top == "0px")
		{
			jonbox_y = parseInt(25 + scroll_offset_y);
		}
		else
		{
			static_pos = true;
		}
	}
	else if(jonbox_height > (vp_height - ( vp_height * (1/3) )))
	{
		// this box is bigger than 1/3 the viewport!  Simply 25 pixles down from screen
		jonbox_y = parseInt(25 + scroll_offset_y);
	}
	else
	{
		// display 1/3 centering vertically
		jonbox_y = parseInt((2 * vp_height - 3 * jonbox_height) / 6 + scroll_offset_y);
	}

	if (jonbox_y < 25) { jonbox_y = 25; }
	
	if(!static_pos)
	{
		// both X and Y
		if(animate) {
			$("#" + div_id).animate({
				top: jonbox_y + "px",
				left: jonbox_x + "px"
			}, 200, "swing");
		} else {
			jonbox.style.top = jonbox_y + "px";
			jonbox.style.left = jonbox_x + "px";
		}
	}
	else {
		// only X
		if(animate) {
			$("#" + div_id).animate({
				left: jonbox_x + "px"
			}, 200, "swing");
		}
		else {
			jonbox.style.left = jonbox_x + "px";
		}
	}
};

/**
 * return JSON literal contating scroll offsets & viewport information
 * multi-browser support
 **/
function get_window_sizes()
{
	// Compute scroll offsets for different browsers
	if (self.pageYOffset)
	{
		scroll_offset_x = self.pageXOffset;
		scroll_offset_y = self.pageYOffset;
	}
	else if (document.documentElement && document.documentElement.scrollTop)
	{
		scroll_offset_x = document.documentElement.scrollLeft;
		scroll_offset_y = document.documentElement.scrollTop;
	}
	else if (document.body)
	{
		scroll_offset_x = document.body.scrollLeft;
		scroll_offset_y = document.body.scrollTop;
	}

	// Computer viewport dimensions of different browsers
	if (self.innerHeight)
	{
		vp_width = self.innerWidth;
		vp_height = self.innerHeight;
	}
	else if (document.documentElement && document.documentElement.clientHeight)
	{
		vp_width = document.documentElement.clientWidth;
		vp_height = document.documentElement.clientHeight;
	}
	else if (document.body)
	{
		vp_width = document.body.clientWidth;
		vp_height = document.body.clientHeight;
	}


	return {'scroll_offset_y':scroll_offset_y, 'scroll_offset_x':scroll_offset_x, 'vp_width':vp_width, 'vp_height':vp_height};
}
/**
 * Helper function to display jonbox_display_message, for compatibility
 * @param: msg : html or plain txt message to display
 **/
function jonbox_alert(msg)
{
	jonbox_display_message(msg,"alert");
}

/**
 * Helper function to display jonbox_display_message, for compatibility
 * @param: msg : html or plain txt message to display
 **/
function jonbox_info(msg)
{
	jonbox_display_message(msg,"information");
}

/**
 * Helper function to display jonbox_display_message, for compatibility
 * @param: msg : html or plain txt message to display
 **/
function jonbox_checkmark(msg)
{
	jonbox_display_message(msg,"check");
}

/**
 * Prompts the user with a message in a pretty fashion.
 * @param: msg : html or plain txt message to display
 **/
function jonbox_display_message(msg,type)
{
	var full_msg = '<table><tr><td valign="top" style="padding-right:20px;">';

	// Switch to determine what icon to display

	switch(type) {
		case "check":
			full_msg += '<img src="includes/plugins/jonbox/images/check_mark_48.png" style="align:left;margin-left:20px;width:48px;height:48px;border:0;" align="left" />';
			break;
		case "danger":
			full_msg += '<img src="includes/plugins/jonbox/images/alert_red_48.png" style="align:left;margin-left:20px;width:48px;height:48px;border:0;" align="left" />';
			break;
		case "information":
			full_msg += '<img src="includes/plugins/jonbox/images/information.svg" style="align:left;margin-left:20px;width:48px;height:48px;border:0;" align="left" />';
			break;
		default:
			full_msg += '<img src="includes/plugins/jonbox/images/alert_yellow.svg" style="align:left;margin-left:20px;width:48px;height:48px;border:0;" align="left" />';
			break;
	}

	full_msg += '</td>';
	full_msg +='<td style="width:400px">';
	full_msg += msg + '<br><div style="text-align:right;padding-left:10px;height:20px;"><input type="button" onclick="close_jonbox()" value="OK"></div></td>';
	$("#jonbox_jblock").css({
		height: $(document).height()
	}).show(1, function() {
		$(this).animate({
			opacity: 0.60
		}, 100, null, function() {
			$("#jonbox_content").html(full_msg);
			show_jonbox();
		});
	});
	return false;
}


/**
 * Given form elements, and a callback funtions.  Create a pop-up that wants users input
 *
 * @param: form_id : string, the id of an element where the inner contents are the form elements to display
 * @param: passed_callback : function, the function to call once the user submits the form, returns true/false
 *          if return is true, closes the jonbox, if false, keep it open
 * @example:
 *  <div id="test_form_contents"><input type="text" name="test_input"/></div>
 *  <script> function callback_test(frm){...} </script>
 *  TO CALL: jonbox_form('test_corm_contents', callback_test);
 **/
var callback = '';
function jonbox_form(form_id, passed_callback)
{
	show_loading();

	tagtype = $('#'+form_id).prop("tagName");
	var form = (tagtype.toLowerCase()=='textarea')? $('#'+form_id).val():$('#'+form_id).html();
	callback = passed_callback;

	var full_form = '';
	full_form += '<form name="jonbox_form" action="#" method="GET" onSubmit="if(callback(this)){close_jonbox();}return false;">';
	full_form += '<p id="jonbox_form_error" style="color:#FF0000;font-weight:bold;"></p>';
	full_form += form;
	full_form += '<br><div style="text-align:right;padding-top:10px;"><input type="button" onclick="close_jonbox()" value="Cancel">';
	full_form += '&nbsp;<input type="submit" value="Submit"></div></td>';
	full_form += '</form>';
	$("#jonbox_jblock").css({
		height: $(document).height()
	}).show(1, function() {
		$(this).animate({
			opacity: 0.60
		}, 100, null, function() {
			$("#jonbox_content").html(full_form);
			show_jonbox();
		});
	});

	return false;
}

/**
 * Given form elements, and a callback funtions.  Create a pop-up that wants users input
 *
 * @param: form_id : string, the id of an element where the inner contents are the form elements to display
 * @param: passed_callback : function, the function to call once the user submits the form, returns true/false
 *          if return is true, closes the jonbox, if false, keep it open
 * @example:
 *  <div id="test_form_contents"><input type="text" name="test_input"/></div>
 *  <script> function callback_test(frm){...} </script>
 *  TO CALL: jonbox_form('test_corm_contents', callback_test);
 **/
var callback = '';
function jonbox_full_form(form_id, passed_callback)
{
	var full_form = $('#'+form_id).html();
	callback = passed_callback;

	$("#jonbox_jblock").css({
		height: $(document).height()
	}).show(1, function() {
		$(this).animate({
			opacity: 0.60
		}, 100, null, function() {
			$("#jonbox_content").html(full_form);
			show_jonbox();
		});
	});
	return false;
}

/**
 * Display the contents of a div in a jonbox (more jonbox 1.0 style)
 *
 * @param: div_id : the id of the div whos content will be displayed
 **/
function jonbox_open_div(div_id,hide_frame_and_maximize)
{
	var div_contents = $("#"+div_id).html();
	// Convert the original divs html to be text
	$("#"+div_id).addClass("jonbox_converted_to_text").text(div_contents).html();

	$("#jonbox_jblock").css({
		height: $(document).height()
	}).show(1, function() {
		$(this).animate({
			opacity: 0.60
		}, 100, null, function() {
			$("#jonbox_content").data("jonbox_original_div",div_id).html(div_contents);
			show_jonbox(hide_frame_and_maximize);
		});
	});
}

/**
 * Starts loading an image, once loaded displays the jonbox
 *
 * @param: img_src : the source of the image
 **/
var image = null;
function jonbox_open_img(img_src)
{
	$("#jonbox_jblock").css({
		height: $(document).height()
	}).show(1, function() {
		$(this).animate({
			opacity: 0.50
		}, 200, null, function() {
			show_loading();
			image = new Image();
			image.src = img_src;

			// Show the loading until pre-loading is complete
			setTimeout(jonbox_img_delay, '300');
		});
	});
	return false;
}
/**
 * Checks to see if the image is done loading, if it is then
 *  create the jonbox and display, otherwise timeout and check again
 *
 * uses global image object
 **/
function jonbox_img_delay()
{
	if(!image.complete) {
		setTimeout(jonbox_img_delay, '300');
	} else {
		// Have the image only show as the source
		$("#jonbox_content").html("");
		$("<img />").attr({
			src: image.src
		}).appendTo("#jonbox_content");

		show_jonbox();
	}
}
/**
 * Display an error in the active form (assumes the submit callback return false, avoiding the jonbox being closed)
 * @param: msg : error message to display
 **/
function jonbox_form_error(msg)
{
	$('#jonbox_form_error').html(msg);
}

/**
 * Animate out the visiable jonbox and background.
 **/
function close_jonbox(e)
{
	if ( jonbox_persistent ) { return false; }
	// ~dustinh @ 8/24/2012
	// This removes ALL events bound to the window. need to be less...nuclear. unbind ONLY jonbox events
	//$(window).unbind("resize").unbind("scroll");
	$(window).unbind("resize", jonbox_reposition_resize).unbind("scroll", jonbox_reposition_scroll);

	$.event.trigger({
		type: "jonbox-hideStart",
		message: "JonBox is beginning to hide",
		time: new Date()
	});

	$("#jonbox_loading").fadeOut("Fast", function() {
		var top = $("#jonbox").css('top');
		top = parseInt(top);

		$("#jonbox").animate({
			top: (top + 20) + "px",
			opacity: 0
		}, 200, null, function() {
			$(this).hide();
			$("#jonbox_jblock").animate({
				opacity: 0
			}, 200, null, function() {

				// Let's determine the original div and reset it back to the original html
				var original_div = $("#jonbox_content").data("jonbox_original_div");
				if(typeof original_div != "undefined") {
					$("#" + original_div).html($("#" + original_div).text()).removeClass("jonbox_converted_to_text");
				}

				$(this).hide();
				//$("#jonbox_content").html(''); // Removed to allow jonbox.close_div to work in IE

				// Show any of those hidden items
				$('.jonbox_hide').css('visibility','visible');
				if ( typeof jonbox != "undefined" && jonbox.current_open_div !== null ) {
					jonbox.close_div();
				}

				// Destroy jonbox_content
				$("#jonbox_content").empty();

				$.event.trigger({
					type: "jonbox-hideComplete",
					message: "JonBox is finished hiding",
					time: new Date()
				});
			})
		});
	});

	enable_all_dynamic_areas();

	return false;
}

////////////////////////////////////////////////////////////////
// 2012.07.13 -JonJon
// The beginnings of a move to a JonBox object
// It's purpose of above date is to help in bugs with duplicate DOM IDs being created on jonbox_open_div()

jonbox = {
	noop : function() {}

	, current_open_div : null

	, set_and_show : function( quick_html ) {
		$("#jonbox_quick_content").html(quick_html);
		this.open_div("jonbox_quick_content");
	}

	, open_div : function( div_id ) {
		var $div = $("#" + div_id);
		$("#jonbox_jblock").css({
			height: $(document).height()
		}).show(1, function() {
			$(this).animate({
				opacity: 0.60
			}, 100, null, function() {
				$("#jonbox_content").html("");
				$("#jonbox_content").append($div);
				$div.show();
				show_jonbox();
				jonbox.current_open_div = $div;
			})
		});
		return false;
	}

	, close_div : function() {
		if ( jonbox_persistent ) { return false; }
		if ( this.current_open_div != null ) {
			this.current_open_div.hide();
			$("body").append(this.current_open_div);
			this.current_open_div = null;
		}
	}
};

////////////////////////////////////////////////////////////////
// JonBox as a jQuery plugin
// Selected elements become a trigger that opens a jonbox
// For more information please see README.txt under the section "USING THE JQUERY PLUGIN"
//--------------------------------------------------------------
(function( $ ) {
	$.fn.jonbox = function( options ) {
		var defaults = {
			"alert"   : "",
			"content" : "",
			"href"    : "",
			"info"    : "",
			"selector": null,
			"target"  : ""
		};
		var globalOpts = $.extend(defaults, options);

		return this.each(function() {
			var $$ = globalOpts.selector === null ? $(this) : $(globalOpts.selector, this);

			var attrs = {};
			if ( $$.is("a") && $.type($$.attr("href")) != "undefined" ) {
				attrs.href = $$.attr("href");
			}
			var datum = {
				"alert"   : $$.data("alert"),
				"content" : $$.data("content"),
				"href"    : $$.data("href"),
				"info"    : $$.data("info"),
				"target"  : $$.data("target")
			};
			var opts = $.extend(globalOpts, datum, attrs);

			if ( opts.href != "" && opts.href != "#" ) {
				$(this).on("click", opts.selector, function( e ) {
					e.preventDefault();
					open_jonbox(opts.href);
				});
			} else if ( opts.target != "" ) {
				$(this).on("click", opts.selector, function( e ) {
					e.preventDefault();
					jonbox.open_div(opts.target);
				});
			} else if ( opts.content != "" ) {
				var rand = Math.round(Math.random() * 8999) + 1000;
				var id   = 'jonbox_cached_content_' + rand;
				$("body").append('<div id="' + id + '" style="display:none;">' + opts.content + '</div>');
				$(this).on("click", opts.selector, function( e ) {
					e.preventDefault();
					jonbox.open_div(id);
				});
			} else if ( opts.alert != "" ) {
				$(this).on("click", opts.selector, function( e ) {
					e.preventDefault();
					jonbox_alert(opts.alert);
				});
			} else if ( opts.info != "" ) {
				$(this).on("click", opts.selector, function( e ) {
					e.preventDefault();
					jonbox_info(opts.info);
				});
			}
		});
	};
}( jQuery ));

/****** end css file: jquery.jonbox.js ******/

/****** js file: json2.min.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/plugins/ajax/json2.min.js ******/
/****** last modified: 1360217448 (2013-02-07 00:10:48) ******/
if(!this.JSON){JSON={}}(function(){function f(n){return n<10?"0"+n:n}if(typeof Date.prototype.toJSON!=="function"){Date.prototype.toJSON=function(key){return this.getUTCFullYear()+"-"+f(this.getUTCMonth()+1)+"-"+f(this.getUTCDate())+"T"+f(this.getUTCHours())+":"+f(this.getUTCMinutes())+":"+f(this.getUTCSeconds())+"Z"};String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(key){return this.valueOf()}}var cx=/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,escapable=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,gap,indent,meta={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"},rep;function quote(string){escapable.lastIndex=0;return escapable.test(string)?'"'+string.replace(escapable,function(a){var c=meta[a];return typeof c==="string"?c:"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)})+'"':'"'+string+'"'}function str(key,holder){var i,k,v,length,mind=gap,partial,value=holder[key];if(value&&typeof value==="object"&&typeof value.toJSON==="function"){value=value.toJSON(key)}if(typeof rep==="function"){value=rep.call(holder,key,value)}switch(typeof value){case"string":return quote(value);case"number":return isFinite(value)?String(value):"null";case"boolean":case"null":return String(value);case"object":if(!value){return"null"}gap+=indent;partial=[];if(Object.prototype.toString.apply(value)==="[object Array]"){length=value.length;for(i=0;i<length;i+=1){partial[i]=str(i,value)||"null"}v=partial.length===0?"[]":gap?"[\n"+gap+partial.join(",\n"+gap)+"\n"+mind+"]":"["+partial.join(",")+"]";gap=mind;return v}if(rep&&typeof rep==="object"){length=rep.length;for(i=0;i<length;i+=1){k=rep[i];if(typeof k==="string"){v=str(k,value);if(v){partial.push(quote(k)+(gap?": ":":")+v)}}}}else{for(k in value){if(Object.hasOwnProperty.call(value,k)){v=str(k,value);if(v){partial.push(quote(k)+(gap?": ":":")+v)}}}}v=partial.length===0?"{}":gap?"{\n"+gap+partial.join(",\n"+gap)+"\n"+mind+"}":"{"+partial.join(",")+"}";gap=mind;return v}}if(typeof JSON.stringify!=="function"){JSON.stringify=function(value,replacer,space){var i;gap="";indent="";if(typeof space==="number"){for(i=0;i<space;i+=1){indent+=" "}}else{if(typeof space==="string"){indent=space}}rep=replacer;if(replacer&&typeof replacer!=="function"&&(typeof replacer!=="object"||typeof replacer.length!=="number")){throw new Error("JSON.stringify")}return str("",{"":value})}}if(typeof JSON.parse!=="function"){JSON.parse=function(text,reviver){var j;function walk(holder,key){var k,v,value=holder[key];if(value&&typeof value==="object"){for(k in value){if(Object.hasOwnProperty.call(value,k)){v=walk(value,k);if(v!==undefined){value[k]=v}else{delete value[k]}}}}return reviver.call(holder,key,value)}cx.lastIndex=0;if(cx.test(text)){text=text.replace(cx,function(a){return"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)})}if(/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,"@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:\s*\[)+/g,""))){j=eval("("+text+")");return typeof reviver==="function"?walk({"":j},""):j}throw new SyntaxError("JSON.parse")}}}());
/****** end css file: json2.min.js ******/

/****** js file: draw.comp_plan.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/modules/comp_plan/includes/draw.comp_plan.js ******/
/****** last modified: 1444408607 (2015-10-09 11:36:47) ******/
var comp_plan =
{
	te_url: ""
	,
	init : function()
	{
		this.te_url = $("#comp_plan_te_table").attr("data-url");
		$(document).ajaxStop(comp_plan.draw_nicer_groups);
		this.reload_all_ranks();
		this.init_multiselector("volume_type");
		this.init_multiselector("rank");
		this.init_multiselector("account_type");
		this.init_multiselector("user_role");

		if ( $.fn.scrollspy != null )
		{
			$("#rank_menu").scrollspy({
				  'min': 50
				, 'max' : 1000000
				, 'onEnter': function()
				{
					$("#rank_menu").addClass("pinned");
				}
				, 'onLeave': function()
				{
					$("#rank_menu").removeClass("pinned");
				}
			});
		}
	}
	,
	init_multiselector : function( fieldname )
	{
		$(".comp_plan_rank").on("click", "." + fieldname + "_multiselector", function( e )
		{
			var rand = $(this).attr("data-rand");
			$("#" + fieldname + "_multiselector_" + rand).val("");
			$("." + fieldname + "_multiselector_" + rand).each(function( i, elem )
			{
				if ( $(this).is(":checked") )
				{
					var newval = $("#" + fieldname + "_multiselector_" + rand).val();
					if ( newval != "" )
					{
						newval += ",";
					}
					newval += $(this).val();
					$("#" + fieldname + "_multiselector_" + rand).val(newval);
				}
			});
		});
	}
	,
	url : function( more )
	{
		var url = this.te_url;
		if ( typeof more != "undefined" )
		{
			url += "&" + more;
		}
		return url;
	}
	,
	ajax_url : function( cmd, more )
	{
		var ajax_url = this.te_url + "&ai_skin=full_page&te_mode=ajax&ajax_cmd=" + ai.urlencode(cmd);
		if ( typeof more != "undefined" )
		{
			ajax_url += "&" + more;
		}
		return ajax_url;
	}
	,
	save_rule : function( frm, key )
	{
		var url = this.ajax_url("save_rule", "te_key=" + ai.urlencode(key));
		$.post(url, $(frm).serialize(), function( data )
		{
			if ( $.trim(data) == "OK" || $.trim(data) == "OK-refresh" )
			{
				if ( $.trim(data) == "OK-refresh" )
				{
					comp_plan.reload_all_ranks();
				}
				else
				{
					comp_plan.reload_rank(key);
				}
			}
			else
			{
				jonbox_alert(data);
			}
		});
	}
	,
	delete_rule : function( rule_id, key )
	{
		var confirmed = confirm('Do you really want to DELETE this rule?');
		if ( confirmed )
		{
			var url = this.ajax_url("delete_rule", "te_key=" + ai.urlencode(key));
			$.post(url, {"rule":rule_id}, function( data )
			{
				if ( $.trim(data) == "OK" || $.trim(data) == "OK-refresh" )
				{
					ai.notification.success("Deleted", "The rule has successfully been deleted.");
					if ( $.trim(data) == "OK-refresh" )
					{
						comp_plan.reload_all_ranks();
					}
					else
					{
						comp_plan.reload_rank(key);
					}
				}
				else
				{
					jonbox_alert(data);
				}
			});
		}
	}
	,
	delete_all_rule : function( rule_id, key )
	{
		var confirmed = confirm('Do you really want to DELETE this rule from ALL ranks?');
		if ( confirmed )
		{
			var url = this.ajax_url("delete_all_rule", "te_key=" + ai.urlencode(key));
			$.post(url, {"rule":rule_id}, function( data )
			{
				if ( $.trim(data) == "OK" )
				{
					ai.notification.success("Deleted", "All rules have successfully been deleted.");
					comp_plan.reload_all_ranks();
				}
				else
				{
					jonbox_alert(data);
				}
			});
		}
	}
	,
	rearrange_rule : function( rule_id, dir, key )
	{
		var url = this.ajax_url("rearrange_rule", "te_key=" + ai.urlencode(key));
		$.post(url, {"rule": rule_id, "dir": dir}, function( data )
		{
			if ( $.trim(data) == "OK" )
			{
				comp_plan.reload_rank(key);
			}
			else
			{
				jonbox_alert(data);
			}
		});
	}
	,
	copy_rule_up : function( rule_id, key )
	{
		var confirmed = confirm('Do you really want to COPY this rule and its settings to all higher ranks?');
		if ( confirmed )
		{
			var url = this.ajax_url("copy_rule_up", "te_key=" + ai.urlencode(key));
			$.post(url, {"rule": rule_id}, function( data )
			{
				if ( $.trim(data) == "OK" )
				{
					ai.notification.success("Copied", "The rules have successfully been copied.");
					comp_plan.reload_all_ranks();
				}
				else
				{
					jonbox_alert(data);
				}
			});
		}
	}
	,
	group_with : function( rule_id, key )
	{
		var url = this.ajax_url("group_with", "te_key=" + ai.urlencode(key));
		$.post(url, {"rule": rule_id}, function( data )
		{
			if ( $.trim(data) == "OK" )
			{
				comp_plan.reload_all_ranks();
			}
			else
			{
				jonbox_alert(data);
			}
		});
	}
	,
	share_rule_up : function( rule_id, key )
	{
		var confirmed = confirm('Do you really want to SHARE the settings of this rule to all higher ranks?');
		if ( confirmed )
		{
			var url = this.ajax_url("share_rule_up", "te_key=" + ai.urlencode(key));
			$.post(url, {"rule": rule_id}, function( data )
			{
				if ( $.trim(data) == "OK" )
				{
					ai.notification.success("Shared", "The rules and settings have successfully been shared.");
					comp_plan.reload_all_ranks();
				}
				else
				{
					jonbox_alert(data);
				}
			});
		}
	}
	,
	toggle_rule : function( rule_id, val, key )
	{
		var url = this.ajax_url("toggle_rule", "te_key=" + ai.urlencode(key));
		$.post(url, {"rule": rule_id, "val": val}, function( data )
		{
			if ( $.trim(data) == "OK" )
			{
				if ( val == 1 )
				{
					ai.notification.success("Disabled", "The rule has been disabled.");
				}
				else
				{
					ai.notification.success("Enabled", "The rule has been enabled.");
				}
				comp_plan.reload_all_ranks();
			}
			else
			{
				jonbox_alert(data);
			}
		});
	}
	,
	reload_rank : function( key )
	{
		$("#module_loader_" + key).html('<img src="images/loading.gif" alt=""> Reloading');
		var url = comp_plan.ajax_url("load_rules", "te_key=" + ai.urlencode(key));
		$("#comp_plan_rank_" + key).load(url);
	}
	,
	reload_all_ranks : function()
	{
		$(".comp_plan_rank").each(function( i )
		{
			var key = $(this).attr("data-id");
			comp_plan.reload_rank(key);
		});
	}
	,
	draw_nicer_groups : function()
	{
		$(".comp_plan_rule").removeClass("nice-group-start");
		$(".comp_plan_rule").removeClass("nice-group-end");

		$(".comp_plan_rule.grouped").each(function( i )
		{
			var row_key  = parseInt($(this).attr("data-key"));
			var row_i    = parseInt($(this).attr("data-i"));
			var row_type = $(this).attr("data-type");

			var first_in_group_class = ".comp_plan_rule-" + row_type + "-" + row_key + "-" + (row_i - 1) + ":not(.grouped)";
			$(first_in_group_class).addClass("nice-group-start");

			var past_last_in_group_class = ".comp_plan_rule-" + row_type + "-" + row_key + "-" + (row_i + 1) + ":not(.grouped)";
			var next_sibling = ".comp_plan_rule-" + row_type + "-" + row_key + "-" + (row_i + 1);
			if ( $(past_last_in_group_class).length > 0 || $(next_sibling).length == 0 )
			{
				$(this).addClass("nice-group-end");
			}
		});
	}
};

$(document).ready(function( event )
{
	comp_plan.init();
});

function comp_plan_delete_selected()
{
	var frm = document.getElementById('comp_plan_table_form');

	if( confirm('Delete Selected Items?') )
	{
		frm.action = comp_plan.url("te_mode=multidelete");
		frm.submit();
	}
}

function comp_plan_process_multiselect_checkbox( selectall_checkbox )
{
	var frm = document.getElementById('comp_plan_table_form');

	for( var i=0; i < frm.elements.length; i++ )
	{
		if( frm.elements[i].type == 'checkbox' && frm.elements[i].name == 'te_multiselect[]' )
		{
			frm.elements[i].checked = selectall_checkbox.checked;
		}

	}
}

function comp_plan_update_sort_index(table, row)
{
	// Fix Zebra Stripping
	$("table.te_main_table tr:even").removeClass("te_odd_row").addClass("te_even_row");
	$("table.te_main_table tr:odd").removeClass("te_even_row").addClass("te_odd_row");

	var post_str = $(table).tableDnDSerialize();

	$('#saving').css('display', 'inline');

	// Create a post request
	var url = comp_plan.ajax_url("update_sort_index");
	ajax_post_request(url, post_str, ajax_handler_default);
}

/****** end css file: draw.comp_plan.js ******/

/****** js file: jquery.scrollspy.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/js/jquery.scrollspy.js ******/
/****** last modified: 1360217430 (2013-02-07 00:10:30) ******/
/*!
 * jQuery Scrollspy Plugin
 * Author: @sxalexander
 * Licensed under the MIT license
 */

;
(function($, window, document, undefined) {
	$.fn.extend({
		scrollspy: function(options) {
			var defaults = {
				min: 0,
				max: 0,
				mode: 'vertical',
				buffer: 0,
				container: window,
				onEnter: options.onEnter || [],
				onLeave: options.onLeave || [],
				onTick: options.onTick ||  []
			};

			var options = $.extend({}, defaults, options);

			return this.each(function(i) {
				var element = this;
				var o = options;
				var $container = $(o.container);
				var mode = o.mode;
				var buffer = o.buffer;
				var enters = leaves = 0;
				var inside = false;

				/* add listener to container */
				$container.bind('scroll', function(e) {
					var position = {
						top: $(this).scrollTop(),
						left: $(this).scrollLeft()
					};

					var xy = (mode == 'vertical') ? position.top + buffer : position.left + buffer,
						max = o.max,
						min = o.min;

					/* fix max */
					if ($.isFunction(o.max)) {
						max = o.max();
					}

					/* fix max */
					if ($.isFunction(o.min)) {
						min = o.min();
					}

					if (max == 0) {
						max = (mode == 'vertical') ? $container.height() : $container.outerWidth() + $(element).outerWidth();
					}

					/* if we have reached the minimum bound but are below the max ... */
					if (xy >= o.min && xy <= max) {
						/* trigger enter event */
						if (!inside) {
							inside = true;
							enters++;

							/* fire enter event */
							$(element).trigger('scrollEnter', {
								position : position
							});

							if ($.isFunction(o.onEnter)) {
								o.onEnter(element, position);
							}
						}

						/* triger tick event */
						$(element).trigger('scrollTick', {
							position: position,
							inside: inside,
							enters: enters,
							leaves: leaves
						});

						if ($.isFunction(o.onTick)) {
							o.onTick(element, position, inside, enters, leaves);
						}
					} else {
						if (inside) {
							inside = false;
							leaves++;

							/* trigger leave event */
							$(element).trigger('scrollLeave', {
								position: position,
								leaves: leaves
							});

							if ($.isFunction(o.onLeave)) {
								o.onLeave(element, position);
							}
						}
					}
				});
			});
		}
	});
})(jQuery, window);
/****** end css file: jquery.scrollspy.js ******/

/****** js file: jquery.sidr.min.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/core/js/sidr/jquery.sidr.min.js ******/
/****** last modified: 1419010587 (2014-12-19 11:36:27) ******/
/*! Sidr - v1.2.1 - 2013-11-06
 * https://github.com/artberri/sidr
 * Copyright (c) 2013 Alberto Varela; Licensed MIT */
(function(e){var t=!1,i=!1,n={isUrl:function(e){var t=RegExp("^(https?:\\/\\/)?((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|((\\d{1,3}\\.){3}\\d{1,3}))(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*(\\?[;&a-z\\d%_.~+=-]*)?(\\#[-a-z\\d_]*)?$","i");return t.test(e)?!0:!1},loadContent:function(e,t){e.html(t)},addPrefix:function(e){var t=e.attr("id"),i=e.attr("class");"string"==typeof t&&""!==t&&e.attr("id",t.replace(/([A-Za-z0-9_.\-]+)/g,"sidr-id-$1")),"string"==typeof i&&""!==i&&"sidr-inner"!==i&&e.attr("class",i.replace(/([A-Za-z0-9_.\-]+)/g,"sidr-class-$1")),e.removeAttr("style")},execute:function(n,s,a){"function"==typeof s?(a=s,s="sidr"):s||(s="sidr");var r,d,l,c=e("#"+s),u=e(c.data("body")),f=e("html"),p=c.outerWidth(!0),g=c.data("speed"),h=c.data("side"),m=c.data("displace"),v=c.data("onOpen"),y=c.data("onClose"),x="sidr"===s?"sidr-open":"sidr-open "+s+"-open";if("open"===n||"toggle"===n&&!c.is(":visible")){if(c.is(":visible")||t)return;if(i!==!1)return o.close(i,function(){o.open(s)}),void 0;t=!0,"left"===h?(r={left:p+"px"},d={left:"0px"}):(r={right:p+"px"},d={right:"0px"}),u.is("body")&&(l=f.scrollTop(),f.css("overflow-x","hidden").scrollTop(l)),m?u.addClass("sidr-animating").css({width:u.width(),position:"absolute"}).animate(r,g,function(){e(this).addClass(x)}):setTimeout(function(){e(this).addClass(x)},g),c.css("display","block").animate(d,g,function(){t=!1,i=s,"function"==typeof a&&a(s),u.removeClass("sidr-animating")}),v()}else{if(!c.is(":visible")||t)return;t=!0,"left"===h?(r={left:0},d={left:"-"+p+"px"}):(r={right:0},d={right:"-"+p+"px"}),u.is("body")&&(l=f.scrollTop(),f.removeAttr("style").scrollTop(l)),u.addClass("sidr-animating").animate(r,g).removeClass(x),c.animate(d,g,function(){c.removeAttr("style").hide(),u.removeAttr("style"),e("html").removeAttr("style"),t=!1,i=!1,"function"==typeof a&&a(s),u.removeClass("sidr-animating")}),y()}}},o={open:function(e,t){n.execute("open",e,t)},close:function(e,t){n.execute("close",e,t)},toggle:function(e,t){n.execute("toggle",e,t)},toogle:function(e,t){n.execute("toggle",e,t)}};e.sidr=function(t){return o[t]?o[t].apply(this,Array.prototype.slice.call(arguments,1)):"function"!=typeof t&&"string"!=typeof t&&t?(e.error("Method "+t+" does not exist on jQuery.sidr"),void 0):o.toggle.apply(this,arguments)},e.fn.sidr=function(t){var i=e.extend({name:"sidr",speed:200,side:"left",source:null,renaming:!0,body:"body",displace:!0,onOpen:function(){},onClose:function(){}},t),s=i.name,a=e("#"+s);if(0===a.length&&(a=e("<div />").attr("id",s).appendTo(e("body"))),a.addClass("sidr").addClass(i.side).data({speed:i.speed,side:i.side,body:i.body,displace:i.displace,onOpen:i.onOpen,onClose:i.onClose}),"function"==typeof i.source){var r=i.source(s);n.loadContent(a,r)}else if("string"==typeof i.source&&n.isUrl(i.source))e.get(i.source,function(e){n.loadContent(a,e)});else if("string"==typeof i.source){var d="",l=i.source.split(",");if(e.each(l,function(t,i){d+='<div class="sidr-inner">'+e(i).html()+"</div>"}),i.renaming){var c=e("<div />").html(d);c.find("*").each(function(t,i){var o=e(i);n.addPrefix(o)}),d=c.html()}n.loadContent(a,d)}else null!==i.source&&e.error("Invalid Sidr Source");return this.each(function(){var t=e(this),i=t.data("sidr");i||(t.data("sidr",s),"ontouchstart"in document.documentElement?(t.bind("touchstart",function(e){e.originalEvent.touches[0],this.touched=e.timeStamp}),t.bind("touchend",function(e){var t=Math.abs(e.timeStamp-this.touched);200>t&&(e.preventDefault(),o.toggle(s))})):t.click(function(e){e.preventDefault(),o.toggle(s)}))})}})(jQuery);
/****** end css file: jquery.sidr.min.js ******/

/****** js file: top_bar.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/plugins/top_bar/top_bar.js ******/
/****** last modified: 1441393170 (2015-09-04 13:59:30) ******/
var ai_top_bar =
{
	init : function()
	{
		$("#ai_top_bar").prependTo("body");

		if ( $.fn.scrollspy != null )
		{
			var tb_bot = $("#ai_top_bar").outerHeight();
			$("#ai_top_bar").scrollspy({
				  'min': 1
				, 'max' : 1000000
				, 'onEnter': function()
				{
					$("#ai_top_bar").addClass("pinned");
				}
				, 'onLeave': function()
				{
					$("#ai_top_bar").removeClass("pinned");
				}
			});
		}

		$("#ai_top_bar a").on("click", function( e )
		{
			var $panels = $(this).parents(".ai_top_bar_panels");
			if ( $panels.length )
			{
				$panels.fadeOut(200);
				return;
			}

			var $ul = $(this).parents("ul.nested_level");
			if ( $ul.length )
			{
				$ul.fadeOut(200);
				return;
			}
		})

		// Fix menu clicks that disable entire menus (since some are AJAX clicks that do not leave the page)
		$("span.nohref", "#ai_top_bar").on("mouseenter", function( e ) {
			//$(".ai_top_bar_panels, ul.nested_level", "#ai_top_bar").prop("style", false);
			$(".ai_top_bar_panels, ul.nested_level", "#ai_top_bar").css("display", "");
		});

		/*$("#ai_top_bar_toggler").on("click", function( e ) {
			e.preventDefault();
			$("#ai_top_bar .sectioned_content").slideToggle();
		});*/
		$("#ai_top_bar_toggler").sidr({"name":"sidr-left", "source":"#ai_top_bar .sectioned_content.left_content"});
		$("#ai_top_bar_toggler_user").sidr({"name":"sidr-right", "source":"#ai_top_bar .sectioned_content.right_content", "side":"right"});
	}
};

$(document).ready(function( event )
{
	ai_top_bar.init();
});
/****** end css file: top_bar.js ******/

/****** js file: translation_manager.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/plugins/translator/translation_manager.js ******/
/****** last modified: 1477672763 (2016-10-28 11:39:23) ******/
var translation_manager = {
	initd : false
	,_highlight: false
	, init : function() {
	}
	, delayed_init : function() {
		if ( !this.initd ) {
			$("#translation_manager_translation").blur(function( e ) {
				$("#translation_manager_focus_input").focus();
			}).keydown(function( e ) {
				if ( e.ctrlKey && e.which == 13 ) {
					var $frm_obj = $("#translation_manager_form")
					translation_manager.update($frm_obj);
				} else if ( e.ctrlKey && e.which == 37 ) {
					$(this).blur();
				}
			});

			$("#translation_manager_focus_input").keydown(function( e ) {
				var $active_choice = $(".tm_phrase_choice_active");
				if ( $active_choice.length > 0 ) {
					if ( e.which == 38 ) {
						var $prev_choice = $active_choice.prevAll(".tm_phrase_choice:visible");
						console.log($prev_choice);
						if ( $prev_choice.length > 0 ) {
							translation_manager.choose($prev_choice[0]);
						}
					} else if ( e.which == 40 ) {
						var $next_choice = $active_choice.nextAll(".tm_phrase_choice:visible");
						console.log($next_choice);
						if ( $next_choice.length > 0 ) {
							translation_manager.choose($next_choice[0]);
						}
					} else if ( e.which == 39 || e.which == 13 ) {
						e.preventDefault();
						$("#translation_manager_translation").focus();
					}
				}
			});

			$("#modal-overlay").remove();
			$("#loadingDiv").remove();
			this.initd = true;
		}
	}
	, select : function( select_obj ) {
		this.delayed_init();

		var lang = $(select_obj).val();
		$("#translation_manager_lang_input").val(lang);

		var lang_name = $("#tm_lang_option_" + lang).html();
		$("#translation_manager_step4_title").html(lang_name);

		$("#translation_manager_original_phrase").html("");
		$("#translation_manager_translation").attr("placeholder", "").val("");
		$("#translation_manager_key").val("");

		$(".tm_phrase_choice").show();
		$(".tm_phrase_choice.not_in_" + lang).hide();
	}
	, choose : function( elem ) {
		this.delayed_init();

		$(".tm_phrase_choice_active").removeClass("tm_phrase_choice_active");
		$(elem).addClass("tm_phrase_choice_active");

		var pos = $(elem).position().top;
		if ( pos < 0 || pos > 350 ) {
			var pos_of_0 = $(".tm_phrase_choice_0").position().top;
			var new_top = pos_of_0 * -1;
			if ( pos < 0 ) {
				new_top -= 200;
			} else if ( pos > 350 ) {
				new_top += 200;
			}
			$("#translation_manager_phrase_list").animate({scrollTop: new_top}, 200);
		}

		var key = $(elem).attr("data-key");
		$("#translation_manager_key").val(key);

		var full_phrase = $(elem).html();
		$("#translation_manager_original_phrase").html(full_phrase);

		var lang = $("#translation_manager_lang_input").val();
		$("#translation_manager_translation").attr("placeholder", "Loading...").val("").blur();
		$.post("translation_manager.php?cmd=choose", "key=" + this.u(key) + "&lang=" + this.u(lang), function( data, success, xhr ) {
			switch ( data.status ) {
				case "0":
					translation_manager.error(data.message);
					break;
				case "1":
					$("#translation_manager_translation").val(data.message).blur();
					break;
				case "2":
					$("#translation_manager_translation").attr("placeholder", "No Data").val("").blur();
					break;
				default:
					translation_manager.error(data);
					break;
			}
		}, "json");
	}
	, update : function( frm_obj ) {
		this.delayed_init();

		var params = $(frm_obj).serialize();
		    params += "&phrase=" + this.u($("#translation_manager_translation").val());
		$.post("translation_manager.php?cmd=update", params, function( data, success, xhr ) {
			if ( data.status ) {
				switch ( data.status ) {
					case "1":
						$("#translation_manager_saved p").show();
						$("#translation_manager_translation").blur();
						setTimeout('$("#translation_manager_saved p").fadeOut();', 2000);
						break;
					default:
						translation_manager.error(data.message);
						break;
				}
			} else {
				translation_manager.error(data);
			}
		}, "json");
		return false;
	}

	, u : function( string ) {
		return encodeURIComponent(string);
	}

	, error : function( string ) {
		string += ' &nbsp; <a href="javascript:void(0)" onclick="translation_manager.dismiss();">Dismiss</a>';
		$("#translation_manager_error").html(string);
	}
	, dismiss : function() {
		$("#translation_manager_error").html("");
	}

	/**
	 *
	 */
	,_fix_input_highlight : function($elem)
	{
		$.each( utility2.get_element_attributes($elem), function ( property, attribute ) {
			if(/<[a-z][\s\S]*>/i.test(attribute) // has html tag
				&& attribute.indexOf('translate_highlight') != -1)
			{
				$($elem).prop(property, utility2.remove_html_tags_from_string(attribute));
				$($elem).addClass('translate_highlight_input');
			}
		});
	}
	/**
	 *
	 */
	,run_translate_highlight : function()
	{
		var that = this;

		if(!this._highlight){
			// when jonbox finish loading run this method everytime
			$(document).on("jonbox-ajaxStop", function( e ) { that.run_translate_highlight(); });
		}

		$.each($('input'),function(index,value) {
			that._fix_input_highlight($(this));
		});

		$.each($('option'),function(index,value)
		{
			if( $(this).html().indexOf("\u200C") > 0 ) // because option element cannot have html an visible code is existed to find
			{
				$(this).addClass('translate_highlight');
			}
		});


		this._highlight = true;
	}
};

$(document).ready(function( event ) {
	translation_manager.init();
});

/****** end css file: translation_manager.js ******/

/****** js file: match_height.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/js/match_height.js ******/
/****** last modified: 1467821330 (2016-07-06 11:08:50) ******/
/**
* jquery.matchHeight.js master
* http://brm.io/jquery-match-height/
* License: MIT
*/

;(function($) {
    /*
    *  internal
    */

    var _previousResizeWidth = -1,
        _updateTimeout = -1;

    /*
    *  _parse
    *  value parse utility function
    */

    var _parse = function(value) {
        // parse value and convert NaN to 0
        return parseFloat(value) || 0;
    };

    /*
    *  _rows
    *  utility function returns array of jQuery selections representing each row
    *  (as displayed after float wrapping applied by browser)
    */

    var _rows = function(elements) {
        var tolerance = 1,
            $elements = $(elements),
            lastTop = null,
            rows = [];

        // group elements by their top position
        $elements.each(function(){
            var $that = $(this),
                top = $that.offset().top - _parse($that.css('margin-top')),
                lastRow = rows.length > 0 ? rows[rows.length - 1] : null;

            if (lastRow === null) {
                // first item on the row, so just push it
                rows.push($that);
            } else {
                // if the row top is the same, add to the row group
                if (Math.floor(Math.abs(lastTop - top)) <= tolerance) {
                    rows[rows.length - 1] = lastRow.add($that);
                } else {
                    // otherwise start a new row group
                    rows.push($that);
                }
            }

            // keep track of the last row top
            lastTop = top;
        });

        return rows;
    };

    /*
    *  _parseOptions
    *  handle plugin options
    */

    var _parseOptions = function(options) {
        var opts = {
            byRow: true,
            property: 'height',
            target: null,
            remove: false
        };

        if (typeof options === 'object') {
            return $.extend(opts, options);
        }

        if (typeof options === 'boolean') {
            opts.byRow = options;
        } else if (options === 'remove') {
            opts.remove = true;
        }

        return opts;
    };

    /*
    *  matchHeight
    *  plugin definition
    */

    var matchHeight = $.fn.matchHeight = function(options) {
        var opts = _parseOptions(options);

        // handle remove
        if (opts.remove) {
            var that = this;

            // remove fixed height from all selected elements
            this.css(opts.property, '');

            // remove selected elements from all groups
            $.each(matchHeight._groups, function(key, group) {
                group.elements = group.elements.not(that);
            });

            // TODO: cleanup empty groups

            return this;
        }

        if (this.length <= 1 && !opts.target) {
            return this;
        }

        // keep track of this group so we can re-apply later on load and resize events
        matchHeight._groups.push({
            elements: this,
            options: opts
        });

        // match each element's height to the tallest element in the selection
        matchHeight._apply(this, opts);

        return this;
    };

    /*
    *  plugin global options
    */

    matchHeight._groups = [];
    matchHeight._throttle = 80;
    matchHeight._maintainScroll = false;
    matchHeight._beforeUpdate = null;
    matchHeight._afterUpdate = null;
    matchHeight._rows = _rows;

    /*
    *  matchHeight._apply
    *  apply matchHeight to given elements
    */

    matchHeight._apply = function(elements, options) {
        var opts = _parseOptions(options),
            $elements = $(elements),
            rows = [$elements];

        // take note of scroll position
        var scrollTop = $(window).scrollTop(),
            htmlHeight = $('html').outerHeight(true);

        // get hidden parents
        var $hiddenParents = $elements.parents().filter(':hidden');

        // cache the original inline style
        $hiddenParents.each(function() {
            var $that = $(this);
            $that.data('style-cache', $that.attr('style'));
        });

        // temporarily must force hidden parents visible
        $hiddenParents.css('display', 'block');

        // get rows if using byRow, otherwise assume one row
        if (opts.byRow && !opts.target) {

            // must first force an arbitrary equal height so floating elements break evenly
            $elements.each(function() {
                var $that = $(this),
                    display = $that.css('display');

                // temporarily force a usable display value
                if (display !== 'inline-block' && display !== 'inline-flex') {
                    display = 'block';
                }

                // cache the original inline style
                $that.data('style-cache', $that.attr('style'));

                $that.css({
                    'display': display,
                    'padding-top': '0',
                    'padding-bottom': '0',
                    'margin-top': '0',
                    'margin-bottom': '0',
                    'border-top-width': '0',
                    'border-bottom-width': '0',
                    'height': '100px'
                });
            });

            // get the array of rows (based on element top position)
            rows = _rows($elements);

            // revert original inline styles
            $elements.each(function() {
                var $that = $(this);
                $that.attr('style', $that.data('style-cache') || '');
            });
        }

        $.each(rows, function(key, row) {
            var $row = $(row),
                targetHeight = 0;

            if (!opts.target) {
                // skip apply to rows with only one item
                if (opts.byRow && $row.length <= 1) {
                    $row.css(opts.property, '');
                    return;
                }

                // iterate the row and find the max height
                $row.each(function(){
                    var $that = $(this),
                        display = $that.css('display');

                    // temporarily force a usable display value
                    if (display !== 'inline-block' && display !== 'inline-flex') {
                        display = 'block';
                    }

                    // ensure we get the correct actual height (and not a previously set height value)
                    var css = { 'display': display };
                    css[opts.property] = '';
                    $that.css(css);

                    // find the max height (including padding, but not margin)
                    if ($that.outerHeight(false) > targetHeight) {
                        targetHeight = $that.outerHeight(false);
                    }

                    // revert display block
                    $that.css('display', '');
                });
            } else {
                // if target set, use the height of the target element
                targetHeight = opts.target.outerHeight(false);
            }

            // iterate the row and apply the height to all elements
            $row.each(function(){
                var $that = $(this),
                    verticalPadding = 0;

                // don't apply to a target
                if (opts.target && $that.is(opts.target)) {
                    return;
                }

                // handle padding and border correctly (required when not using border-box)
                if ($that.css('box-sizing') !== 'border-box') {
                    verticalPadding += _parse($that.css('border-top-width')) + _parse($that.css('border-bottom-width'));
                    verticalPadding += _parse($that.css('padding-top')) + _parse($that.css('padding-bottom'));
                }

                // set the height (accounting for padding and border)
                $that.css(opts.property, (targetHeight - verticalPadding) + 'px');
            });
        });

        // revert hidden parents
        $hiddenParents.each(function() {
            var $that = $(this);
            $that.attr('style', $that.data('style-cache') || null);
        });

        // restore scroll position if enabled
        if (matchHeight._maintainScroll) {
            $(window).scrollTop((scrollTop / htmlHeight) * $('html').outerHeight(true));
        }

        return this;
    };

    /*
    *  matchHeight._applyDataApi
    *  applies matchHeight to all elements with a data-match-height attribute
    */

    matchHeight._applyDataApi = function() {
        var groups = {};

        // generate groups by their groupId set by elements using data-match-height
        $('[data-match-height], [data-mh]').each(function() {
            var $this = $(this),
                groupId = $this.attr('data-mh') || $this.attr('data-match-height');

            if (groupId in groups) {
                groups[groupId] = groups[groupId].add($this);
            } else {
                groups[groupId] = $this;
            }
        });

        // apply matchHeight to each group
        $.each(groups, function() {
            this.matchHeight(true);
        });
    };

    /*
    *  matchHeight._update
    *  updates matchHeight on all current groups with their correct options
    */

    var _update = function(event) {
        if (matchHeight._beforeUpdate) {
            matchHeight._beforeUpdate(event, matchHeight._groups);
        }

        $.each(matchHeight._groups, function() {
            matchHeight._apply(this.elements, this.options);
        });

        if (matchHeight._afterUpdate) {
            matchHeight._afterUpdate(event, matchHeight._groups);
        }
    };

    matchHeight._update = function(throttle, event) {
        // prevent update if fired from a resize event
        // where the viewport width hasn't actually changed
        // fixes an event looping bug in IE8
        if (event && event.type === 'resize') {
            var windowWidth = $(window).width();
            if (windowWidth === _previousResizeWidth) {
                return;
            }
            _previousResizeWidth = windowWidth;
        }

        // throttle updates
        if (!throttle) {
            _update(event);
        } else if (_updateTimeout === -1) {
            _updateTimeout = setTimeout(function() {
                _update(event);
                _updateTimeout = -1;
            }, matchHeight._throttle);
        }
    };

    /*
    *  bind events
    */

    // apply on DOM ready event
    $(matchHeight._applyDataApi);

    // update heights on load and resize events
    $(window).bind('load', function(event) {
        matchHeight._update(false, event);
    });

    // throttled update heights on resize events
    $(window).bind('resize orientationchange', function(event) {
        matchHeight._update(true, event);
    });

})(jQuery);

/****** end css file: match_height.js ******/

/****** js file: ai_match_height.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/js/ai_match_height.js ******/
/****** last modified: 1468427004 (2016-07-13 11:23:24) ******/
/**
 *  Note: This depends on match_height.js
 *    
 *  usage:
 *  add class ai_match_height to containers to be matched
 *  add attribute match-group="group1"
 *  
 *  all containers with the same group will be grouped together    
*/

$(document).ready(function() {
	
	// apply matchHeight to each container with class 'ai_match_height'
	
	// build list of match-height groups
	var match_groups = [];
	$('.ai_match_height').each(function() {
		group = $(this).attr('match-group'); 
		if(group!=null && group!='' && $.inArray(group, match_groups)==-1 ) match_groups.push(group); 
	});
		
  //loop through the group array and run matchHeight on them
  $.each(match_groups,function(i,group){
		ops = {byRow:false};
		$('.ai_match_height[match-group="'+group+'"]').matchHeight(ops);
	});


});

/****** end css file: ai_match_height.js ******/
