/****** js combine: 24 total file(s) ******/

/****** js file: dynamic_areas.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/plugins/dynamic_areas/js/dynamic_areas.js ******/
/****** last modified: 1466605105 (2016-06-22 09:18:25) ******/
// JavaScript Document

var dyna_area_elements = [];
var edit_pencil_size = 20;
var fade_duration = 400;
var last_check_for_dyna_elements = 0;
var listener_delay = 1000;
var dyna_areas_on = "off";

$(document).ready(function() {

		// Track mouse move
		$("body").mousemove(function(e) {
			if(typeof current_edit_mode_state !== "undefined" && !current_edit_mode_state)return;//do not draw edit link if edit mode is disables
			listen_for_and_update_dynamic_areas();
			determine_which_dyna_areas_are_hovered(e.pageX,e.pageY);
		});

	// A delay of 100 seems to work realiably, but, wanted a bit of a guarantee.
	var delay_da_init = setTimeout(function() {
		build_dyna_area_elements();
		listen_for_and_update_dynamic_areas();
	}, 150);

	var resizeTimer;

	$(window).resize(function()
		{
			clearTimeout(resizeTimer);//reset the timer each time the function is called
			resizeTimer = setTimeout(function()
				{
					build_dyna_area_elements();
					listen_for_and_update_dynamic_areas();
				},250);//only resize the dynamic areas if it has been 250ms since the last resize
		});
});

function activate_all_dyna_areas() {

	dyna_areas_on = "on";
	for(elem = 0; elem < (dyna_area_elements.length - 1); elem++) {
		$("#dynamic_area_" + dyna_area_elements[elem].id).data('fading', true).css({"opacity":0}).animate({"opacity":1}, {
			duration: fade_duration,
			step: function(now) {
				var dyna = $(this).attr("rel");
				$("#" + dyna).css('outline-color','rgba(255,0,0,'+now+')');
			},
			complete: function(now) {
				$(this).data('fading', false);
				$(this).data('active', true);
			}
		});
	}
}

function deactivate_all_dyna_areas() {
	dyna_areas_on = "off";
	for(elem = 0; elem < (dyna_area_elements.length - 1); elem++) {
		$("#dynamic_area_" + dyna_area_elements[elem].id).data('fading', true).css({"opacity":1}).animate({"opacity":0}, {
			duration: fade_duration,
			step: function(now) {
				var dyna = $(this).attr("rel");
				$("#" + dyna).css('outline-color','rgba(255,0,0,'+now+')');
			},
			complete: function(now) {
				$(this).data('fading', false);
				$(this).data('active', false);
			}
		});
	}
}

function toggle_ai_edit() {
	if(dyna_areas_on == "on") {
		deactivate_all_dyna_areas();
	} else {
		activate_all_dyna_areas();
	}
}

function build_dyna_area_elements() {
	$("div.dynamic_area_content").each(function() {

		var dyna_area_id = $(this).attr("id");
		var dyna_area_position = $(this).offset();
		var dyna_area_width = $(this).width();
		var dyna_area_height = $(this).height();

		var data = {};
		data.id = dyna_area_id;
		data.top = dyna_area_position.top;
		data.left = dyna_area_position.left;
		data.bottom = dyna_area_position.top + dyna_area_height;
		data.right = dyna_area_position.left + dyna_area_width;

		// Determine the position of the edit pencil, for now, just position where it falls, we will rely on the updater to move it to be visible
		var edit_position_top = dyna_area_position.top;
		var edit_position_left = dyna_area_position.left;

		data.edit_top = edit_position_top;
		data.edit_left = edit_position_left;
		data.edit_bottom = (edit_position_top + edit_pencil_size);
		data.edit_right = (edit_position_left + edit_pencil_size);

		dyna_area_elements.push(data);
	});
}

function enable_all_dynamic_areas() {
	$(".dynamic_area_edit_link").each(function() {
		// This resets all dyanmic areas and then also removes the display: none;
		$(this).removeAttr("disabled").show(0);
	});
}

function enable_dynamic_area(area) {
	$("#" + area).removeAttr("disabled");
}

function disable_dynamic_area(area) {
	$("#" + area).attr("disabled","disabled");
}

function disable_all_dynamic_areas_not_part_of_jonbox() {
	$('div.dynamic_area_content:not(#jonbox_content .dynamic_area_content)').each(function() {
		disable_dynamic_area('dynamic_area_' + $(this).attr("id"));
	});
}

function update_dynamic_areas_NOW() {
	last_check_for_dyna_elements = 0;
	listen_for_and_update_dynamic_areas();
}

function listen_for_and_update_dynamic_areas() {
	
	var current_timestamp = new Date().getTime();
	if(last_check_for_dyna_elements <= (current_timestamp - listener_delay)) {
		var new_dyna_area_elements = [];
		
		// Check all active dynamic areas, build into array
		$('div.dynamic_area_content:not(#jonbox_content .dynamic_area_content)').each(function() {
			add_update_dyna_element(new_dyna_area_elements,this);
		});

		$('#jonbox_content .dynamic_area_content').each(function() {
			add_update_dyna_element(new_dyna_area_elements,this);
		});

		// Set the old obj to the newly built  one
		dyna_area_elements = [];
		dyna_area_elements = new_dyna_area_elements;

		last_check_for_dyna_elements = new Date().getTime();
	}
}

function add_update_dyna_element(new_dyna_area_elements,dyna) {

	var dyna_area_id = $(dyna).attr("id");
	var dyna_area_position = $(dyna).offset();
	var dyna_area_width = $(dyna).width();
	var dyna_area_height = $(dyna).height();

	// Check to see if this dynamic area already exists
	var key = dyna_area_id_exists(dyna_area_id);
	if(key > 0) {
		// Check to see if it is moved
		if(
			// Top
			dyna_area_position.top != dyna_area_elements[key].top
			// Left
			|| dyna_area_position.left != dyna_area_elements[key].left
			// Bottom
			|| (dyna_area_position.top + dyna_area_height) != dyna_area_elements[key].bottom
			// Right
			|| (dyna_area_position.left + dyna_area_width) != dyna_area_elements[key].right
		) {
			$("#dynamic_area_" + dyna_area_id).css({
				"top":dyna_area_position.top + "px",
				"left":dyna_area_position.left + "px"
			});
		}
	}

	// Check and see if the actual image for this dyna area exists
	if($("#dynamic_area_" + dyna_area_id).attr("id") != "dynamic_area_" + dyna_area_id) {
		var appended_div = $("<img />", {src: "images/dynamic_edit.14.png", id: "dynamic_area_" + dyna_area_id, css: {
			"cursor":"pointer",
			"width":edit_pencil_size + "px",
			"height":edit_pencil_size + "px",
			"min-width":edit_pencil_size + "px",
			"min-height":edit_pencil_size + "px",
			"max-width":edit_pencil_size + "px",
			"max-height":edit_pencil_size + "px",
			"position":"absolute",
			"top":dyna_area_position.top + "px",
			"left":dyna_area_position.left + "px"
		}, class: "dynamic_area_edit_link", attr: {"rel": dyna_area_id}});
		$("body").append(appended_div);
	}

	// Build the data object
	var data = {};
	data.id = dyna_area_id;
	data.top = dyna_area_position.top;
	data.left = dyna_area_position.left;
	data.bottom = dyna_area_position.top + dyna_area_height;
	data.right = dyna_area_position.left + dyna_area_width;

	// Set the edit pencil info
	data.edit_top = dyna_area_position.top;
	data.edit_left = dyna_area_position.left;
	data.edit_bottom = (dyna_area_position.top + edit_pencil_size);
	data.edit_right = (dyna_area_position.left + edit_pencil_size);

	// Determine the position of the edit pencil and override it if necessary
	for(elem = 0; elem < (dyna_area_elements.length - 1); elem++) {
		if(dyna_area_elements[elem].id != dyna_area_id && dyna_area_elements[elem].top >= dyna_area_position.top && dyna_area_elements[elem].top < (dyna_area_position.top + edit_pencil_size) && dyna_area_elements[elem].left >= dyna_area_position.left && dyna_area_elements[elem].left < (dyna_area_position.left + edit_pencil_size)) {
			var edit_position_top = (dyna_area_position.top - (edit_pencil_size/2));
			var edit_position_left = (dyna_area_position.left - (edit_pencil_size/2));
			// Go ahead and move it ;-)
			$("#dynamic_area_" + dyna_area_id).css({
				"top":edit_position_top + "px",
				"left":edit_position_left + "px"
			});
			data.edit_top = edit_position_top;
			data.edit_left = edit_position_left;
			data.edit_bottom = (edit_position_top + edit_pencil_size);
			data.edit_right = (edit_position_left + edit_pencil_size);
		}
	}

	new_dyna_area_elements.push(data);

}

function dyna_area_id_exists(dyna_area_id) {
	for(elem = 0; elem < (dyna_area_elements.length - 1); elem++) {
		if(dyna_area_elements[elem].id == dyna_area_id) {
			return elem;
		}
	}

	return 0;
}

function determine_which_dyna_areas_are_hovered(x,y) {
	
	if(dyna_areas_on == "on") { return; }

	// Special Logic for slider dynamic area
	$(".slider").each(function() {
		var id = $(this).attr("id");
		$("#" + id + " .dynamic_area_content").each(function() {
			var slide_id = $(this).attr("id");
			var active_id = $("#" + id + " .flex-active-slide .dynamic_area_content").attr("id");
			if(active_id != slide_id) {
				$("#dynamic_area_" + slide_id).attr("disabled","disabled");
			} else {
				$("#dynamic_area_" + active_id).show(0).removeAttr("disabled");
			}
		});
	});
	
	for(elem = 0; elem < dyna_area_elements.length; elem++) {
		if(
			// The main box
			y > dyna_area_elements[elem].top &&
			y < dyna_area_elements[elem].bottom &&
			x > dyna_area_elements[elem].left &&
			x < dyna_area_elements[elem].right
			||
			// The edit pencil box
			y > dyna_area_elements[elem].edit_top &&
			y < dyna_area_elements[elem].edit_bottom &&
			x > dyna_area_elements[elem].edit_left &&
			x < dyna_area_elements[elem].edit_right
		) {
			// If the dyna area is disabled, don't show it
			if($("#dynamic_area_" + dyna_area_elements[elem].id).attr("disabled") == "disabled") {
				$("#dynamic_area_" + dyna_area_elements[elem].id).fadeOut(0, function() {
					var dyna = $(this).attr("rel");
					$("#" + dyna).css('outline-color','rgba(255,0,0,0.00)');
				});
			} else {
				if(!$("#dynamic_area_" + dyna_area_elements[elem].id).data('fading') && !$("#dynamic_area_" + dyna_area_elements[elem].id).data('active')) {
					$("#dynamic_area_" + dyna_area_elements[elem].id).data('fading', true).animate({"opacity":1.0}, {
						duration: fade_duration,
						step: function(now) {
							var dyna = $(this).attr("rel");
							$("#" + dyna).css('outline-color','rgba(255,0,0,'+now+')');
						},
						complete: function(now) {
							$(this).data('fading', false);
							$(this).data('active', true);
						}
					});
				}
			}
		} else {
			if(!$("#dynamic_area_" + dyna_area_elements[elem].id).data('fading') && $("#dynamic_area_" + dyna_area_elements[elem].id).data('active')) {
				$("#dynamic_area_" + dyna_area_elements[elem].id).data('fading', true).css({"opacity":1}).animate({"opacity":0}, {
					duration: fade_duration,
					step: function(now) {
						var dyna = $(this).attr("rel");
						$("#" + dyna).css('outline-color','rgba(255,0,0,'+now+')');
					},
					complete: function(now) {
						$(this).data('fading', false);
						$(this).data('active', false);
					}
				});
			}
		}
	}
}

$(document).on('click','.dynamic_area_edit_link', function() {
	var id = $(this).attr("rel");
	var url = $("#" + id).data("href");
	if(url !== undefined) {
		var width = $("#" + id).data("width");
		var height = $("#" + id).data("height");
		var da_w = window.open(url,'ai_popup','location=0,status=0,scrollbars=1,resizable=1,width=' + width + ',height=' + height);
		if(!da_w){
			alert('Please, turn pop-ups on for this site.');
		} else {
			da_w.focus();
		}
	} else {
		var onclick = $("#" + id).data("onclick");
		var onclick_param_1 = $("#" + id).data("param1");
		if(onclick !== undefined) {
			window[onclick](onclick_param_1);
		}
	}
});

function init_style_mouseovers(element,element_type,id)
{

	$(element_type + element).css({"position":"relative"}).append('<div class="dynamic_styles_edit_link ai_edit_toggle" id="dynamic_styles_edit_' + id + '"></div>');
	if($('.dynamic_styles_edit_controls').length == 0) {
		$("HTML").append('<div class="dynamic_styles_edit_controls"></div>');
	}
	$(".dynamic_styles_edit_link").show(0);
	$(".status_saved_message").delay("2000").fadeOut("slow");
}

function close_dynamic_styles_popup()
{
	$(".dynamic_styles_edit_controls").empty();
	$(".dynamic_styles_edit_link").show(0);
	$(".status_saved_message").delay("2000").fadeOut("slow");
}

function init_history_jeditable(anchor_point,id)
{
	direction_class = "history_dropdown";
	direction_class_indentifier = "." + direction_class;

	// Add History icon, and click event
	var history_drop_point = $("<div />");

	var html = "";
	html += "<div id=\"view_history_" + id + "\" class=\"history_drop\">";
	html += "<img class=\"history\" src=\"includes/plugins/dynamic_areas/images/history.png\" />";
	html += "</div>";

	history_drop_point.html(html);
	history_drop_point.addClass('history_drop_point');

	$(anchor_point).append(history_drop_point);

	// Create placeholder for history
	var history_dropdown = $("<div />");
	history_dropdown.addClass(direction_class);
	$("#view_history_" + id).append(history_dropdown);

	var updated = false;
	$("#view_history_" + id + ".history_drop IMG.history").on('click',function(event) {
		if($("#view_history_" + id + " " + direction_class_indentifier).hasClass('dropped_down')) {
			$("#view_history_" + id + " " + direction_class_indentifier).removeClass('dropped_down').slideUp(125);
		} else {
			if($("#view_history_" + id + " " + direction_class_indentifier).hasClass('has_content')) {
				reset_history_page();
				$("#view_history_" + id + " " + direction_class_indentifier).addClass('dropped_down').slideDown(125);
			} else {
				$("#view_history_" + id + " IMG").attr("src","includes/plugins/dynamic_areas/images/loading_white_on_blue.gif");
				$.get("dynamic_area_history?ai_skin=full_page&te_class=dynamic_area_history&te_mode=ajax&ajax_cmd=lookup_history&hide_style=true&id=" + id, function(data) {
					$("#view_history_" + id + " " + direction_class_indentifier).html(data).addClass('dropped_down has_content').slideDown(125, function() {
						$("#view_history_" + id + " IMG").attr("src","includes/plugins/dynamic_areas/images/history.png");
					});

					$("#view_history_" + id + " " + direction_class_indentifier + " DIV").on('mouseover',function(event) {
						$(".history_content").hide(0);
						$(this).children('SPAN').show(0).on('mouseout',function(event) {
							$(this).hide(0);
						});
						$(this).children('SPAN').on('click','BUTTON',function(event) {
							event.preventDefault();
							var id = $(this).attr('rel');
							if(id > 0 && !updated) {
								var updated = true; // Causing issues with repeating, hence the flag
								var dynamic_id = $(".history_content_content_" + id).attr('rel');

								// Set the content
								$(".dynamic_area_" + dynamic_id + " FORM.jeditable_input INPUT").val( $('.history_content_content_' + id).html() );
								$(".dynamic_area_" + dynamic_id + " FORM.jeditable_input TEXTAREA").val( $('.history_content_content_' + id).html() );

								$("#view_history_" + dynamic_id + " " + direction_class_indentifier).removeClass('dropped_down').slideUp(125);
							}
						});
					});
				});
			}
		}
	});
}

function init_history(anchor_point,id)
{
	direction_class = "history_dropup";
	direction_class_indentifier = "." + direction_class;

	$(anchor_point).addClass('history_drop wysiwyg_history_drop_point').html("<img class=\"history\" src=\"includes/plugins/dynamic_areas/images/history.png\" />").attr("id","view_history_" + id);

	$('body').click( function(){$(".history_content").hide(0);} )
		.keyup( function(e){if(e.keyCode === 27)$(".history_content").hide(0);} );

	// Create placeholder for history
	var history_dropdown = $("<div />");
	history_dropdown.addClass(direction_class);
	$("#view_history_" + id).append(history_dropdown);

	var updated = false;
	$("#view_history_" + id + ".history_drop IMG.history").on('click',function(event) {
		if($("#view_history_" + id + " " + direction_class_indentifier).hasClass('dropped_down')) {
			$("#view_history_" + id + " " + direction_class_indentifier).removeClass('dropped_down').slideDown(125);
		} else {
			if($("#view_history_" + id + " " + direction_class_indentifier).hasClass('has_content')) {
				reset_history_page();
				$("#view_history_" + id + " " + direction_class_indentifier).addClass('dropped_down').slideUp(125);
			} else {
				$("#view_history_" + id + " IMG.history").attr("src","includes/plugins/dynamic_areas/images/loading_white_on_blue.gif");
				$.get("dynamic_area_history?ai_skin=full_page&te_class=dynamic_area_history&te_mode=ajax&ajax_cmd=lookup_history&hide_style=true&id=" + id, function(data) {
					$("#view_history_" + id + " " + direction_class_indentifier).html(data).slideDown(125, function() {
						//$("#view_history_" + id + " " + direction_class_indentifier).addClass('dropped_down');
						$("#view_history_" + id + " " + direction_class_indentifier).addClass('has_content');
						$("#view_history_" + id + " IMG.history").attr("src","includes/plugins/dynamic_areas/images/history.png");
					});

					$("#view_history_" + id + " " + direction_class_indentifier + " DIV").on('mouseover',function(event) {
						$(".history_content").hide(0);
						var $this = $(this);
						$this.children('SPAN').show(0);
						if($this.data('drawn') != 'true')
						{
							/* iframe = $("<iframe width=\"100%\" height=\"126\" frameborder=\"0\" src=\""
								 + "dynamic_area_history?ai_skin=full_page&te_class=dynamic_area_history&te_mode=ajax&ajax_cmd=reload_content&id=" + id + "&mode="
								 + "\"></iframe>").on('mouseout',function(event) {
								 $(this).hide(0);
								 });*/
							$(this).children('SPAN').on('click','BUTTON',function(event) {
								event.preventDefault();
								var id = $(this).attr('rel');
								if(id > 0 && !updated) {
									var updated = true; // Causing issues with repeating, hence the flag
									var dynamic_id = $(".history_content_content_" + id).attr('rel');

									o_content.value = $('.history_content_content_' + id).html();
									wysiwyg_doc_write( $('.history_content_content_' + id).html() );

									$("#view_history_" + dynamic_id + " " + direction_class_indentifier).removeClass('dropped_down').slideDown(125);
								}
							});
							//$this.find('.da_history_content_content').after(iframe);
							$this.data('drawn','true');
						}//else $(this).data('drawn') == true
					});//on mouseover
				});//get
			}//else $("#view_history_" + id + " " + direction_class_indentifier).hasClass('has_content')
		}//else $("#view_history_" + id + " " + direction_class_indentifier).hasClass('dropped_down')
	});// on(click)
}//init history

$(document).on("click","#history_next_page", function(event) {
	$("#history_next_page, #history_prev_page").show(0);

	var page = parseInt($("#history_page_indicator").text());
	var max_page = parseInt($("#history_page_total").text());

	$(".history_content").hide(0);
	$("#history_page_indicator").text(page + 1);
	$("#history_page_" + page).slideUp(125);
	$("#history_page_" + (page + 1)).slideDown(125);

	if((page + 1) == max_page) {
		$("#history_next_page").hide(0);
	}

});
$(document).on("click","#history_prev_page", function(event) {
	$("#history_next_page, #history_prev_page").show(0);

	var page = parseInt($("#history_page_indicator").text());
	var max_page = parseInt($("#history_page_total").text());

	$(".history_content").hide(0);
	$("#history_page_indicator").text(page - 1);
	$("#history_page_" + page).slideUp(125);
	$("#history_page_" + (page - 1)).slideDown(125);

	if((page - 1) == 1) {
		$("#history_prev_page").hide(0);
	}

});

function reset_history_page()
{
	$("#history_prev_page").hide(0);
	$(".history_content").hide(0);
	$("#history_page_indicator").text("1");
	$(".history_page").slideUp(125);
	$("#history_page_1").slideDown(125);
}

function display_link_table(id)
{
	$("#link_table_content_" + id).slideUp(125);
	$("#link_table_empty_" + id).slideUp(125);
	$("#link_table_" + id).slideDown(125);
	$("#upload_file_container_" + id).slideDown(125);
}

$('.wysiwyg_link_table BUTTON[type="submit"]').click(function(event) {
	event.preventDefault();
	var id = $(this).closest("div").attr("rel");
	$("#link_table_" + id + " IMG").show(0);

	var mode = $("#link_table_" + id + " #mode").val();
	var saved_url = $("#link_table_" + id + " #url").val();
	var text = $("#link_table_" + id + " #text").val();
	var target = $("#link_table_" + id + " #target").val();
	var original_content = $("#link_table_" + id + " #original_content").val();

	var url = "dynamic_areas?ai_skin=full_page&te_class=dynamic_areas&te_mode=ajax&ajax_cmd=inline_post_save";
	var data = {id: id, mode: mode, original_content: original_content, url: encodeURIComponent(saved_url), text: encodeURIComponent(text), target: encodeURIComponent(target)};

	$.post(url, data, function( response ) {
		$("#link_table_content_" + id).html(response).slideDown(125);
		$("#link_table_" + id + " IMG").hide(0);
		$("#link_table_" + id).slideUp(125);
		$("#upload_file_container_" + id).slideUp(125);
		enable_all_dynamic_areas();
	});
});

function close_table(id) {
	$("#link_table_" + id + " IMG").hide(0);
	$("#link_table_content_" + id).slideDown(125);
	$("#link_table_" + id + " IMG").hide(0);
	$("#link_table_" + id).slideUp(125);
	$("#upload_file_container_" + id).slideUp(125);
	enable_all_dynamic_areas();
}

/****** end css file: dynamic_areas.js ******/

/****** js file: prettify.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/core/js/prettify.js ******/
/****** last modified: 1360217436 (2013-02-07 00:10:36) ******/
var q=null;window.PR_SHOULD_USE_CONTINUATION=!0;
(function(){function L(a){function m(a){var f=a.charCodeAt(0);if(f!==92)return f;var b=a.charAt(1);return(f=r[b])?f:"0"<=b&&b<="7"?parseInt(a.substring(1),8):b==="u"||b==="x"?parseInt(a.substring(2),16):a.charCodeAt(1)}function e(a){if(a<32)return(a<16?"\\x0":"\\x")+a.toString(16);a=String.fromCharCode(a);if(a==="\\"||a==="-"||a==="["||a==="]")a="\\"+a;return a}function h(a){for(var f=a.substring(1,a.length-1).match(/\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\[0-3][0-7]{0,2}|\\[0-7]{1,2}|\\[\S\s]|[^\\]/g),a=
[],b=[],o=f[0]==="^",c=o?1:0,i=f.length;c<i;++c){var j=f[c];if(/\\[bdsw]/i.test(j))a.push(j);else{var j=m(j),d;c+2<i&&"-"===f[c+1]?(d=m(f[c+2]),c+=2):d=j;b.push([j,d]);d<65||j>122||(d<65||j>90||b.push([Math.max(65,j)|32,Math.min(d,90)|32]),d<97||j>122||b.push([Math.max(97,j)&-33,Math.min(d,122)&-33]))}}b.sort(function(a,f){return a[0]-f[0]||f[1]-a[1]});f=[];j=[NaN,NaN];for(c=0;c<b.length;++c)i=b[c],i[0]<=j[1]+1?j[1]=Math.max(j[1],i[1]):f.push(j=i);b=["["];o&&b.push("^");b.push.apply(b,a);for(c=0;c<
f.length;++c)i=f[c],b.push(e(i[0])),i[1]>i[0]&&(i[1]+1>i[0]&&b.push("-"),b.push(e(i[1])));b.push("]");return b.join("")}function y(a){for(var f=a.source.match(/\[(?:[^\\\]]|\\[\S\s])*]|\\u[\dA-Fa-f]{4}|\\x[\dA-Fa-f]{2}|\\\d+|\\[^\dux]|\(\?[!:=]|[()^]|[^()[\\^]+/g),b=f.length,d=[],c=0,i=0;c<b;++c){var j=f[c];j==="("?++i:"\\"===j.charAt(0)&&(j=+j.substring(1))&&j<=i&&(d[j]=-1)}for(c=1;c<d.length;++c)-1===d[c]&&(d[c]=++t);for(i=c=0;c<b;++c)j=f[c],j==="("?(++i,d[i]===void 0&&(f[c]="(?:")):"\\"===j.charAt(0)&&
(j=+j.substring(1))&&j<=i&&(f[c]="\\"+d[i]);for(i=c=0;c<b;++c)"^"===f[c]&&"^"!==f[c+1]&&(f[c]="");if(a.ignoreCase&&s)for(c=0;c<b;++c)j=f[c],a=j.charAt(0),j.length>=2&&a==="["?f[c]=h(j):a!=="\\"&&(f[c]=j.replace(/[A-Za-z]/g,function(a){a=a.charCodeAt(0);return"["+String.fromCharCode(a&-33,a|32)+"]"}));return f.join("")}for(var t=0,s=!1,l=!1,p=0,d=a.length;p<d;++p){var g=a[p];if(g.ignoreCase)l=!0;else if(/[a-z]/i.test(g.source.replace(/\\u[\da-f]{4}|\\x[\da-f]{2}|\\[^UXux]/gi,""))){s=!0;l=!1;break}}for(var r=
{b:8,t:9,n:10,v:11,f:12,r:13},n=[],p=0,d=a.length;p<d;++p){g=a[p];if(g.global||g.multiline)throw Error(""+g);n.push("(?:"+y(g)+")")}return RegExp(n.join("|"),l?"gi":"g")}function M(a){function m(a){switch(a.nodeType){case 1:if(e.test(a.className))break;for(var g=a.firstChild;g;g=g.nextSibling)m(g);g=a.nodeName;if("BR"===g||"LI"===g)h[s]="\n",t[s<<1]=y++,t[s++<<1|1]=a;break;case 3:case 4:g=a.nodeValue,g.length&&(g=p?g.replace(/\r\n?/g,"\n"):g.replace(/[\t\n\r ]+/g," "),h[s]=g,t[s<<1]=y,y+=g.length,
t[s++<<1|1]=a)}}var e=/(?:^|\s)nocode(?:\s|$)/,h=[],y=0,t=[],s=0,l;a.currentStyle?l=a.currentStyle.whiteSpace:window.getComputedStyle&&(l=document.defaultView.getComputedStyle(a,q).getPropertyValue("white-space"));var p=l&&"pre"===l.substring(0,3);m(a);return{a:h.join("").replace(/\n$/,""),c:t}}function B(a,m,e,h){m&&(a={a:m,d:a},e(a),h.push.apply(h,a.e))}function x(a,m){function e(a){for(var l=a.d,p=[l,"pln"],d=0,g=a.a.match(y)||[],r={},n=0,z=g.length;n<z;++n){var f=g[n],b=r[f],o=void 0,c;if(typeof b===
"string")c=!1;else{var i=h[f.charAt(0)];if(i)o=f.match(i[1]),b=i[0];else{for(c=0;c<t;++c)if(i=m[c],o=f.match(i[1])){b=i[0];break}o||(b="pln")}if((c=b.length>=5&&"lang-"===b.substring(0,5))&&!(o&&typeof o[1]==="string"))c=!1,b="src";c||(r[f]=b)}i=d;d+=f.length;if(c){c=o[1];var j=f.indexOf(c),k=j+c.length;o[2]&&(k=f.length-o[2].length,j=k-c.length);b=b.substring(5);B(l+i,f.substring(0,j),e,p);B(l+i+j,c,C(b,c),p);B(l+i+k,f.substring(k),e,p)}else p.push(l+i,b)}a.e=p}var h={},y;(function(){for(var e=a.concat(m),
l=[],p={},d=0,g=e.length;d<g;++d){var r=e[d],n=r[3];if(n)for(var k=n.length;--k>=0;)h[n.charAt(k)]=r;r=r[1];n=""+r;p.hasOwnProperty(n)||(l.push(r),p[n]=q)}l.push(/[\S\s]/);y=L(l)})();var t=m.length;return e}function u(a){var m=[],e=[];a.tripleQuotedStrings?m.push(["str",/^(?:'''(?:[^'\\]|\\[\S\s]|''?(?=[^']))*(?:'''|$)|"""(?:[^"\\]|\\[\S\s]|""?(?=[^"]))*(?:"""|$)|'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$))/,q,"'\""]):a.multiLineStrings?m.push(["str",/^(?:'(?:[^'\\]|\\[\S\s])*(?:'|$)|"(?:[^"\\]|\\[\S\s])*(?:"|$)|`(?:[^\\`]|\\[\S\s])*(?:`|$))/,
q,"'\"`"]):m.push(["str",/^(?:'(?:[^\n\r'\\]|\\.)*(?:'|$)|"(?:[^\n\r"\\]|\\.)*(?:"|$))/,q,"\"'"]);a.verbatimStrings&&e.push(["str",/^@"(?:[^"]|"")*(?:"|$)/,q]);var h=a.hashComments;h&&(a.cStyleComments?(h>1?m.push(["com",/^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/,q,"#"]):m.push(["com",/^#(?:(?:define|elif|else|endif|error|ifdef|include|ifndef|line|pragma|undef|warning)\b|[^\n\r]*)/,q,"#"]),e.push(["str",/^<(?:(?:(?:\.\.\/)*|\/?)(?:[\w-]+(?:\/[\w-]+)+)?[\w-]+\.h|[a-z]\w*)>/,q])):m.push(["com",/^#[^\n\r]*/,
q,"#"]));a.cStyleComments&&(e.push(["com",/^\/\/[^\n\r]*/,q]),e.push(["com",/^\/\*[\S\s]*?(?:\*\/|$)/,q]));a.regexLiterals&&e.push(["lang-regex",/^(?:^^\.?|[!+-]|!=|!==|#|%|%=|&|&&|&&=|&=|\(|\*|\*=|\+=|,|-=|->|\/|\/=|:|::|;|<|<<|<<=|<=|=|==|===|>|>=|>>|>>=|>>>|>>>=|[?@[^]|\^=|\^\^|\^\^=|{|\||\|=|\|\||\|\|=|~|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\s*(\/(?=[^*/])(?:[^/[\\]|\\[\S\s]|\[(?:[^\\\]]|\\[\S\s])*(?:]|$))+\/)/]);(h=a.types)&&e.push(["typ",h]);a=(""+a.keywords).replace(/^ | $/g,
"");a.length&&e.push(["kwd",RegExp("^(?:"+a.replace(/[\s,]+/g,"|")+")\\b"),q]);m.push(["pln",/^\s+/,q," \r\n\t\xa0"]);e.push(["lit",/^@[$_a-z][\w$@]*/i,q],["typ",/^(?:[@_]?[A-Z]+[a-z][\w$@]*|\w+_t\b)/,q],["pln",/^[$_a-z][\w$@]*/i,q],["lit",/^(?:0x[\da-f]+|(?:\d(?:_\d+)*\d*(?:\.\d*)?|\.\d\+)(?:e[+-]?\d+)?)[a-z]*/i,q,"0123456789"],["pln",/^\\[\S\s]?/,q],["pun",/^.[^\s\w"-$'./@\\`]*/,q]);return x(m,e)}function D(a,m){function e(a){switch(a.nodeType){case 1:if(k.test(a.className))break;if("BR"===a.nodeName)h(a),
a.parentNode&&a.parentNode.removeChild(a);else for(a=a.firstChild;a;a=a.nextSibling)e(a);break;case 3:case 4:if(p){var b=a.nodeValue,d=b.match(t);if(d){var c=b.substring(0,d.index);a.nodeValue=c;(b=b.substring(d.index+d[0].length))&&a.parentNode.insertBefore(s.createTextNode(b),a.nextSibling);h(a);c||a.parentNode.removeChild(a)}}}}function h(a){function b(a,d){var e=d?a.cloneNode(!1):a,f=a.parentNode;if(f){var f=b(f,1),g=a.nextSibling;f.appendChild(e);for(var h=g;h;h=g)g=h.nextSibling,f.appendChild(h)}return e}
for(;!a.nextSibling;)if(a=a.parentNode,!a)return;for(var a=b(a.nextSibling,0),e;(e=a.parentNode)&&e.nodeType===1;)a=e;d.push(a)}var k=/(?:^|\s)nocode(?:\s|$)/,t=/\r\n?|\n/,s=a.ownerDocument,l;a.currentStyle?l=a.currentStyle.whiteSpace:window.getComputedStyle&&(l=s.defaultView.getComputedStyle(a,q).getPropertyValue("white-space"));var p=l&&"pre"===l.substring(0,3);for(l=s.createElement("LI");a.firstChild;)l.appendChild(a.firstChild);for(var d=[l],g=0;g<d.length;++g)e(d[g]);m===(m|0)&&d[0].setAttribute("value",
m);var r=s.createElement("OL");r.className="linenums";for(var n=Math.max(0,m-1|0)||0,g=0,z=d.length;g<z;++g)l=d[g],l.className="L"+(g+n)%10,l.firstChild||l.appendChild(s.createTextNode("\xa0")),r.appendChild(l);a.appendChild(r)}function k(a,m){for(var e=m.length;--e>=0;){var h=m[e];A.hasOwnProperty(h)?window.console&&console.warn("cannot override language handler %s",h):A[h]=a}}function C(a,m){if(!a||!A.hasOwnProperty(a))a=/^\s*</.test(m)?"default-markup":"default-code";return A[a]}function E(a){var m=
a.g;try{var e=M(a.h),h=e.a;a.a=h;a.c=e.c;a.d=0;C(m,h)(a);var k=/\bMSIE\b/.test(navigator.userAgent),m=/\n/g,t=a.a,s=t.length,e=0,l=a.c,p=l.length,h=0,d=a.e,g=d.length,a=0;d[g]=s;var r,n;for(n=r=0;n<g;)d[n]!==d[n+2]?(d[r++]=d[n++],d[r++]=d[n++]):n+=2;g=r;for(n=r=0;n<g;){for(var z=d[n],f=d[n+1],b=n+2;b+2<=g&&d[b+1]===f;)b+=2;d[r++]=z;d[r++]=f;n=b}for(d.length=r;h<p;){var o=l[h+2]||s,c=d[a+2]||s,b=Math.min(o,c),i=l[h+1],j;if(i.nodeType!==1&&(j=t.substring(e,b))){k&&(j=j.replace(m,"\r"));i.nodeValue=
j;var u=i.ownerDocument,v=u.createElement("SPAN");v.className=d[a+1];var x=i.parentNode;x.replaceChild(v,i);v.appendChild(i);e<o&&(l[h+1]=i=u.createTextNode(t.substring(b,o)),x.insertBefore(i,v.nextSibling))}e=b;e>=o&&(h+=2);e>=c&&(a+=2)}}catch(w){"console"in window&&console.log(w&&w.stack?w.stack:w)}}var v=["break,continue,do,else,for,if,return,while"],w=[[v,"auto,case,char,const,default,double,enum,extern,float,goto,int,long,register,short,signed,sizeof,static,struct,switch,typedef,union,unsigned,void,volatile"],
"catch,class,delete,false,import,new,operator,private,protected,public,this,throw,true,try,typeof"],F=[w,"alignof,align_union,asm,axiom,bool,concept,concept_map,const_cast,constexpr,decltype,dynamic_cast,explicit,export,friend,inline,late_check,mutable,namespace,nullptr,reinterpret_cast,static_assert,static_cast,template,typeid,typename,using,virtual,where"],G=[w,"abstract,boolean,byte,extends,final,finally,implements,import,instanceof,null,native,package,strictfp,super,synchronized,throws,transient"],
H=[G,"as,base,by,checked,decimal,delegate,descending,dynamic,event,fixed,foreach,from,group,implicit,in,interface,internal,into,is,lock,object,out,override,orderby,params,partial,readonly,ref,sbyte,sealed,stackalloc,string,select,uint,ulong,unchecked,unsafe,ushort,var"],w=[w,"debugger,eval,export,function,get,null,set,undefined,var,with,Infinity,NaN"],I=[v,"and,as,assert,class,def,del,elif,except,exec,finally,from,global,import,in,is,lambda,nonlocal,not,or,pass,print,raise,try,with,yield,False,True,None"],
J=[v,"alias,and,begin,case,class,def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,rescue,retry,self,super,then,true,undef,unless,until,when,yield,BEGIN,END"],v=[v,"case,done,elif,esac,eval,fi,function,in,local,set,then,until"],K=/^(DIR|FILE|vector|(de|priority_)?queue|list|stack|(const_)?iterator|(multi)?(set|map)|bitset|u?(int|float)\d*)/,N=/\S/,O=u({keywords:[F,H,w,"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END"+
I,J,v],hashComments:!0,cStyleComments:!0,multiLineStrings:!0,regexLiterals:!0}),A={};k(O,["default-code"]);k(x([],[["pln",/^[^?<]+/],["dec",/^<!\w[^>]*(?:>|$)/],["com",/^<\!--[\S\s]*?(?:--\>|$)/],["lang-",/^<\?([\S\s]+?)(?:\?>|$)/],["lang-",/^<%([\S\s]+?)(?:%>|$)/],["pun",/^(?:<[%?]|[%?]>)/],["lang-",/^<xmp\b[^>]*>([\S\s]+?)<\/xmp\b[^>]*>/i],["lang-js",/^<script\b[^>]*>([\S\s]*?)(<\/script\b[^>]*>)/i],["lang-css",/^<style\b[^>]*>([\S\s]*?)(<\/style\b[^>]*>)/i],["lang-in.tag",/^(<\/?[a-z][^<>]*>)/i]]),
["default-markup","htm","html","mxml","xhtml","xml","xsl"]);k(x([["pln",/^\s+/,q," \t\r\n"],["atv",/^(?:"[^"]*"?|'[^']*'?)/,q,"\"'"]],[["tag",/^^<\/?[a-z](?:[\w-.:]*\w)?|\/?>$/i],["atn",/^(?!style[\s=]|on)[a-z](?:[\w:-]*\w)?/i],["lang-uq.val",/^=\s*([^\s"'>]*(?:[^\s"'/>]|\/(?=\s)))/],["pun",/^[/<->]+/],["lang-js",/^on\w+\s*=\s*"([^"]+)"/i],["lang-js",/^on\w+\s*=\s*'([^']+)'/i],["lang-js",/^on\w+\s*=\s*([^\s"'>]+)/i],["lang-css",/^style\s*=\s*"([^"]+)"/i],["lang-css",/^style\s*=\s*'([^']+)'/i],["lang-css",
/^style\s*=\s*([^\s"'>]+)/i]]),["in.tag"]);k(x([],[["atv",/^[\S\s]+/]]),["uq.val"]);k(u({keywords:F,hashComments:!0,cStyleComments:!0,types:K}),["c","cc","cpp","cxx","cyc","m"]);k(u({keywords:"null,true,false"}),["json"]);k(u({keywords:H,hashComments:!0,cStyleComments:!0,verbatimStrings:!0,types:K}),["cs"]);k(u({keywords:G,cStyleComments:!0}),["java"]);k(u({keywords:v,hashComments:!0,multiLineStrings:!0}),["bsh","csh","sh"]);k(u({keywords:I,hashComments:!0,multiLineStrings:!0,tripleQuotedStrings:!0}),
["cv","py"]);k(u({keywords:"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,goto,if,import,last,local,my,next,no,our,print,package,redo,require,sub,undef,unless,until,use,wantarray,while,BEGIN,END",hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["perl","pl","pm"]);k(u({keywords:J,hashComments:!0,multiLineStrings:!0,regexLiterals:!0}),["rb"]);k(u({keywords:w,cStyleComments:!0,regexLiterals:!0}),["js"]);k(u({keywords:"all,and,by,catch,class,else,extends,false,finally,for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,true,try,unless,until,when,while,yes",
hashComments:3,cStyleComments:!0,multilineStrings:!0,tripleQuotedStrings:!0,regexLiterals:!0}),["coffee"]);k(x([],[["str",/^[\S\s]+/]]),["regex"]);window.prettyPrintOne=function(a,m,e){var h=document.createElement("PRE");h.innerHTML=a;e&&D(h,e);E({g:m,i:e,h:h});return h.innerHTML};window.prettyPrint=function(a){function m(){for(var e=window.PR_SHOULD_USE_CONTINUATION?l.now()+250:Infinity;p<h.length&&l.now()<e;p++){var n=h[p],k=n.className;if(k.indexOf("prettyprint")>=0){var k=k.match(g),f,b;if(b=
!k){b=n;for(var o=void 0,c=b.firstChild;c;c=c.nextSibling)var i=c.nodeType,o=i===1?o?b:c:i===3?N.test(c.nodeValue)?b:o:o;b=(f=o===b?void 0:o)&&"CODE"===f.tagName}b&&(k=f.className.match(g));k&&(k=k[1]);b=!1;for(o=n.parentNode;o;o=o.parentNode)if((o.tagName==="pre"||o.tagName==="code"||o.tagName==="xmp")&&o.className&&o.className.indexOf("prettyprint")>=0){b=!0;break}b||((b=(b=n.className.match(/\blinenums\b(?::(\d+))?/))?b[1]&&b[1].length?+b[1]:!0:!1)&&D(n,b),d={g:k,h:n,i:b},E(d))}}p<h.length?setTimeout(m,
250):a&&a()}for(var e=[document.getElementsByTagName("pre"),document.getElementsByTagName("code"),document.getElementsByTagName("xmp")],h=[],k=0;k<e.length;++k)for(var t=0,s=e[k].length;t<s;++t)h.push(e[k][t]);var e=q,l=Date;l.now||(l={now:function(){return+new Date}});var p=0,d,g=/\blang(?:uage)?-([\w.]+)(?!\S)/;m()};window.PR={createSimpleLexer:x,registerLangHandler:k,sourceDecorator:u,PR_ATTRIB_NAME:"atn",PR_ATTRIB_VALUE:"atv",PR_COMMENT:"com",PR_DECLARATION:"dec",PR_KEYWORD:"kwd",PR_LITERAL:"lit",
PR_NOCODE:"nocode",PR_PLAIN:"pln",PR_PUNCTUATION:"pun",PR_SOURCE:"src",PR_STRING:"str",PR_TAG:"tag",PR_TYPE:"typ"}})();
/****** end css file: prettify.js ******/

/****** js file: aitips.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/plugins/tips/aitips.js ******/
/****** last modified: 1412887712 (2014-10-09 15:48:32) ******/
var drawn_fail_alert = false;
function get_next_matching_div($from_obj,selector,level){
	if(level==null) level=1;
	$found = $from_obj.next(selector);
	if($found.length>0) return $found;
	$from_obj = $from_obj.parent();
	if(level>4) { 
		if(!drawn_fail_alert) alert('failed to find associated tooltip');
		drawn_fail_alert=true;
		return false;
	}
	else return get_next_matching_div($from_obj,selector,level+1);
}
function set_tip_pos($source,$tipobj) {
	var position = $source.position();
	var xd = ($source.attr('tipx')>0? $source.attr('tipx'):0);
	var yd = ($source.attr('tipy')>0? $source.attr('tipy'):28);
	$tipobj.css({left:position.left+xd, top:position.top+yd});
}
function adjust_tip_pos($tipobj){
	if($tipobj.hasClass('noadjust')) reutrn;
	
	//get positions
	width = $tipobj.outerWidth();
	height = $tipobj.outerHeight();
	var position = $tipobj.position();
	pos_left = position.left;
	pos_right=(pos_left + width);
	pos_top = position.top;
	pos_bott =(pos_top + height);
	win_width = $(window).width();
	win_left = $(window).scrollLeft();
	win_right = $(window).scrollLeft()+$(window).width();
	win_top = $(window).scrollTop();
	win_bott = $(window).scrollTop()+$(window).height();
	//RESIZE IT?
	if(width > win_width) { $tipobj.width( (win_width>600? 600:win_width-20) ); $tipobj.css({"white-space":"normal"}); }
	
	//compute new left
	old_left=pos_left;
	if(pos_right > win_right-10) pos_left = win_right - width - 10;
	if(pos_left < win_left) pos_left = win_left+5;
	//compute new top
	old_top=pos_top;
	if(pos_bott > win_bott-10) { pos_top = win_bott - height - 10; }
	if(pos_top < win_top) { pos_top = win_top+5; }
	//MOVE
	if(pos_left!=old_left) $tipobj.css({left:pos_left});
  
	if(pos_top!=old_top) $tipobj.css({top:pos_top});

}

$(document).ready(function(){
	
	
	
	//AITIPS WORK ON FOCUS 
	$("body").delegate(".has_aitip", "focus", function(){
		var $obj = get_next_matching_div($(this),'div.aitip');
		set_tip_pos($(this),$obj);
		$obj.css({opacity:1, display:"none"}).fadeIn(200);
		//adjust_tip_pos($obj);
  });
	$("body").delegate(".has_aitip", "blur", function(){
		var $obj = get_next_matching_div($(this),'div.aitip');
    $obj.fadeOut(400);
  });
	
	
	
	
	//AIQTIPS WORK ON HOVER
	var $over_has_qtip=false;
	var $over_qtip=false;
	function check_clear_qtip($obj){
		if($over_qtip!==false && $over_qtip[0]==$obj[0]) return;
		if($over_has_qtip!==false && $over_has_qtip[0]==$obj[0]) return;
		$obj.fadeOut(400);
	}
	$("body").delegate(".has_aiqtip", "mouseover", function(){
		var $obj = get_next_matching_div($(this),'div.aiqtip');
		if($over_qtip!=false && $over_has_qtip[0]==$obj[0]) return;
		$over_has_qtip=$obj;
		set_tip_pos($(this),$obj);
		$obj.css({opacity:1, display:"none"}).fadeIn(200);
		adjust_tip_pos($obj);
  });
	$("body").delegate(".has_aiqtip", "mouseout", function(){
		$over_has_qtip = false;
		$obj = get_next_matching_div($(this),'div.aiqtip');
		setTimeout(function() { check_clear_qtip($obj); }, 30);
	});
	$("body").delegate(".aiqtip", "mouseover", function(){ $over_qtip = $(this); });
	$("body").delegate(".aiqtip", "mouseout", function(){
		$over_qtip = false;
		$obj = $(this);
		setTimeout(function() { check_clear_qtip($obj); }, 30);
	});



	//AICTIPS WORK ON CLICK
	var $open_ctip=false;
	var safeclick=0;
	function clear_ctip(){
		$open_ctip.fadeOut(400);
		$open_ctip=false;
	}
	$("body").delegate(".has_aictip", "click", function(){
		var $obj = get_next_matching_div($(this),'div.aictip');
		if($open_ctip!=false && $open_ctip[0]==$obj[0]) {safeclick=1; return; }
		if($open_ctip!=false) clear_ctip();
		set_tip_pos($(this),$obj);
		$obj.css({opacity:1, display:"none"}).fadeIn(200);
		adjust_tip_pos($obj);
		$open_ctip=$obj;
		safeclick = true;
  });
	$("body").delegate(".aictip", "click", function(){
		safeclick = true;
	});
	$("body").click(function(){
		if(!safeclick && $open_ctip!=false) {
			clear_ctip();
		}
		else if(safeclick) safeclick=false;
		return true; 
	});


});


/****** end css file: aitips.js ******/

/****** js file: mediaelement-and-player.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/js/mediaelement/build/mediaelement-and-player.js ******/
/****** last modified: 1468871880 (2016-07-18 14:58:00) ******/
/*!
 *
 * MediaElement.js
 * HTML5 <video> and <audio> shim and player
 * http://mediaelementjs.com/
 *
 * Creates a JavaScript object that mimics HTML5 MediaElement API
 * for browsers that don't understand HTML5 or can't play the provided codec
 * Can play MP4 (H.264), Ogg, WebM, FLV, WMV, WMA, ACC, and MP3
 *
 * Copyright 2010-2014, John Dyer (http://j.hn)
 * License: MIT
 *
 */
// Namespace
var mejs = mejs || {};

// version number
mejs.version = '2.21.2'; 


// player number (for missing, same id attr)
mejs.meIndex = 0;

// media types accepted by plugins
mejs.plugins = {
	silverlight: [
		{version: [3,0], types: ['video/mp4','video/m4v','video/mov','video/wmv','audio/wma','audio/m4a','audio/mp3','audio/wav','audio/mpeg']}
	],
	flash: [
		{version: [9,0,124], types: ['video/mp4','video/m4v','video/mov','video/flv','video/rtmp','video/x-flv','audio/flv','audio/x-flv','audio/mp3','audio/m4a','audio/mpeg', 'video/dailymotion', 'video/x-dailymotion', 'application/x-mpegURL']}
		// 'video/youtube', 'video/x-youtube', 
		// ,{version: [12,0], types: ['video/webm']} // for future reference (hopefully!)
	],
	youtube: [
		{version: null, types: ['video/youtube', 'video/x-youtube', 'audio/youtube', 'audio/x-youtube']}
	],
	vimeo: [
		{version: null, types: ['video/vimeo', 'video/x-vimeo']}
	]
};

/*
Utility methods
*/
mejs.Utility = {
	encodeUrl: function(url) {
		return encodeURIComponent(url); //.replace(/\?/gi,'%3F').replace(/=/gi,'%3D').replace(/&/gi,'%26');
	},
	escapeHTML: function(s) {
		return s.toString().split('&').join('&amp;').split('<').join('&lt;').split('"').join('&quot;');
	},
	absolutizeUrl: function(url) {
		var el = document.createElement('div');
		el.innerHTML = '<a href="' + this.escapeHTML(url) + '">x</a>';
		return el.firstChild.href;
	},
	getScriptPath: function(scriptNames) {
		var
			i = 0,
			j,
			codePath = '',
			testname = '',
			slashPos,
			filenamePos,
			scriptUrl,
			scriptPath,			
			scriptFilename,
			scripts = document.getElementsByTagName('script'),
			il = scripts.length,
			jl = scriptNames.length;
			
		// go through all <script> tags
		for (; i < il; i++) {
			scriptUrl = scripts[i].src;
			slashPos = scriptUrl.lastIndexOf('/');
			if (slashPos > -1) {
				scriptFilename = scriptUrl.substring(slashPos + 1);
				scriptPath = scriptUrl.substring(0, slashPos + 1);
			} else {
				scriptFilename = scriptUrl;
				scriptPath = '';			
			}
			
			// see if any <script> tags have a file name that matches the 
			for (j = 0; j < jl; j++) {
				testname = scriptNames[j];
				filenamePos = scriptFilename.indexOf(testname);
				if (filenamePos > -1) {
					codePath = scriptPath;
					break;
				}
			}
			
			// if we found a path, then break and return it
			if (codePath !== '') {
				break;
			}
		}
		
		// send the best path back
		return codePath;
	},
	/*
	 * Calculate the time format to use. We have a default format set in the
	 * options but it can be imcomplete. We ajust it according to the media
	 * duration.
	 *
	 * We support format like 'hh:mm:ss:ff'.
	 */
	calculateTimeFormat: function(time, options, fps) {
		if (time < 0) {
			time = 0;
		}

		if(typeof fps == 'undefined') {
		    fps = 25;
		}

		var format = options.timeFormat,
			firstChar = format[0],
			firstTwoPlaces = (format[1] == format[0]),
			separatorIndex = firstTwoPlaces? 2: 1,
			separator = ':',
			hours = Math.floor(time / 3600) % 24,
			minutes = Math.floor(time / 60) % 60,
			seconds = Math.floor(time % 60),
			frames = Math.floor(((time % 1)*fps).toFixed(3)),
			lis = [
				[frames, 'f'],
				[seconds, 's'],
				[minutes, 'm'],
				[hours, 'h']
			];

		// Try to get the separator from the format
		if (format.length < separatorIndex) {
			separator = format[separatorIndex];
		}

		var required = false;

		for (var i=0, len=lis.length; i < len; i++) {
			if (format.indexOf(lis[i][1]) !== -1) {
				required=true;
			}
			else if (required) {
				var hasNextValue = false;
				for (var j=i; j < len; j++) {
					if (lis[j][0] > 0) {
						hasNextValue = true;
						break;
					}
				}

				if (! hasNextValue) {
					break;
				}

				if (!firstTwoPlaces) {
					format = firstChar + format;
				}
				format = lis[i][1] + separator + format;
				if (firstTwoPlaces) {
					format = lis[i][1] + format;
				}
				firstChar = lis[i][1];
			}
		}
		options.currentTimeFormat = format;
	},
	/*
	 * Prefix the given number by zero if it is lower than 10.
	 */
	twoDigitsString: function(n) {
		if (n < 10) {
			return '0' + n;
		}
		return String(n);
	},
	secondsToTimeCode: function(time, options) {
		if (time < 0) {
			time = 0;
		}

		// Maintain backward compatibility with method signature before v2.18.
		if (typeof options !== 'object') {
			var format = 'm:ss';
			format = arguments[1] ? 'hh:mm:ss' : format; // forceHours
			format = arguments[2] ? format + ':ff' : format; // showFrameCount

			options = {
				currentTimeFormat: format,
				framesPerSecond: arguments[3] || 25
			};
		}

		var fps = options.framesPerSecond;
		if(typeof fps === 'undefined') {
			fps = 25;
		}

		var format = options.currentTimeFormat,
			hours = Math.floor(time / 3600) % 24,
			minutes = Math.floor(time / 60) % 60,
			seconds = Math.floor(time % 60),
			frames = Math.floor(((time % 1)*fps).toFixed(3));
			lis = [
				[frames, 'f'],
				[seconds, 's'],
				[minutes, 'm'],
				[hours, 'h']
			];

		var res = format;
		for (i=0,len=lis.length; i < len; i++) {
			res = res.replace(lis[i][1]+lis[i][1], this.twoDigitsString(lis[i][0]));
			res = res.replace(lis[i][1], lis[i][0]);
		}
		return res;
	},
	
	timeCodeToSeconds: function(hh_mm_ss_ff, forceHours, showFrameCount, fps){
		if (typeof showFrameCount == 'undefined') {
		    showFrameCount=false;
		} else if(typeof fps == 'undefined') {
		    fps = 25;
		}
	
		var tc_array = hh_mm_ss_ff.split(":"),
			tc_hh = parseInt(tc_array[0], 10),
			tc_mm = parseInt(tc_array[1], 10),
			tc_ss = parseInt(tc_array[2], 10),
			tc_ff = 0,
			tc_in_seconds = 0;
		
		if (showFrameCount) {
		    tc_ff = parseInt(tc_array[3])/fps;
		}
		
		tc_in_seconds = ( tc_hh * 3600 ) + ( tc_mm * 60 ) + tc_ss + tc_ff;
		
		return tc_in_seconds;
	},
	

	convertSMPTEtoSeconds: function (SMPTE) {
		if (typeof SMPTE != 'string') 
			return false;

		SMPTE = SMPTE.replace(',', '.');
		
		var secs = 0,
			decimalLen = (SMPTE.indexOf('.') != -1) ? SMPTE.split('.')[1].length : 0,
			multiplier = 1;
		
		SMPTE = SMPTE.split(':').reverse();
		
		for (var i = 0; i < SMPTE.length; i++) {
			multiplier = 1;
			if (i > 0) {
				multiplier = Math.pow(60, i); 
			}
			secs += Number(SMPTE[i]) * multiplier;
		}
		return Number(secs.toFixed(decimalLen));
	},	
	
	/* borrowed from SWFObject: http://code.google.com/p/swfobject/source/browse/trunk/swfobject/src/swfobject.js#474 */
	removeSwf: function(id) {
		var obj = document.getElementById(id);
		if (obj && /object|embed/i.test(obj.nodeName)) {
			if (mejs.MediaFeatures.isIE) {
				obj.style.display = "none";
				(function(){
					if (obj.readyState == 4) {
						mejs.Utility.removeObjectInIE(id);
					} else {
						setTimeout(arguments.callee, 10);
					}
				})();
			} else {
				obj.parentNode.removeChild(obj);
			}
		}
	},
	removeObjectInIE: function(id) {
		var obj = document.getElementById(id);
		if (obj) {
			for (var i in obj) {
				if (typeof obj[i] == "function") {
					obj[i] = null;
				}
			}
			obj.parentNode.removeChild(obj);
		}		
	},
    determineScheme: function(url) {
        if (url && url.indexOf("://") != -1) {
            return url.substr(0, url.indexOf("://")+3);
        }
        return "//"; // let user agent figure this out
    }
};


// Core detector, plugins are added below
mejs.PluginDetector = {

	// main public function to test a plug version number PluginDetector.hasPluginVersion('flash',[9,0,125]);
	hasPluginVersion: function(plugin, v) {
		var pv = this.plugins[plugin];
		v[1] = v[1] || 0;
		v[2] = v[2] || 0;
		return (pv[0] > v[0] || (pv[0] == v[0] && pv[1] > v[1]) || (pv[0] == v[0] && pv[1] == v[1] && pv[2] >= v[2])) ? true : false;
	},

	// cached values
	nav: window.navigator,
	ua: window.navigator.userAgent.toLowerCase(),

	// stored version numbers
	plugins: [],

	// runs detectPlugin() and stores the version number
	addPlugin: function(p, pluginName, mimeType, activeX, axDetect) {
		this.plugins[p] = this.detectPlugin(pluginName, mimeType, activeX, axDetect);
	},

	// get the version number from the mimetype (all but IE) or ActiveX (IE)
	detectPlugin: function(pluginName, mimeType, activeX, axDetect) {

		var version = [0,0,0],
			description,
			i,
			ax;

		// Firefox, Webkit, Opera
		if (typeof(this.nav.plugins) != 'undefined' && typeof this.nav.plugins[pluginName] == 'object') {
			description = this.nav.plugins[pluginName].description;
			if (description && !(typeof this.nav.mimeTypes != 'undefined' && this.nav.mimeTypes[mimeType] && !this.nav.mimeTypes[mimeType].enabledPlugin)) {
				version = description.replace(pluginName, '').replace(/^\s+/,'').replace(/\sr/gi,'.').split('.');
				for (i=0; i<version.length; i++) {
					version[i] = parseInt(version[i].match(/\d+/), 10);
				}
			}
		// Internet Explorer / ActiveX
		} else if (typeof(window.ActiveXObject) != 'undefined') {
			try {
				ax = new ActiveXObject(activeX);
				if (ax) {
					version = axDetect(ax);
				}
			}
			catch (e) { }
		}
		return version;
	}
};

// Add Flash detection
mejs.PluginDetector.addPlugin('flash','Shockwave Flash','application/x-shockwave-flash','ShockwaveFlash.ShockwaveFlash', function(ax) {
	// adapted from SWFObject
	var version = [],
		d = ax.GetVariable("$version");
	if (d) {
		d = d.split(" ")[1].split(",");
		version = [parseInt(d[0], 10), parseInt(d[1], 10), parseInt(d[2], 10)];
	}
	return version;
});

// Add Silverlight detection
mejs.PluginDetector.addPlugin('silverlight','Silverlight Plug-In','application/x-silverlight-2','AgControl.AgControl', function (ax) {
	// Silverlight cannot report its version number to IE
	// but it does have a isVersionSupported function, so we have to loop through it to get a version number.
	// adapted from http://www.silverlightversion.com/
	var v = [0,0,0,0],
		loopMatch = function(ax, v, i, n) {
			while(ax.isVersionSupported(v[0]+ "."+ v[1] + "." + v[2] + "." + v[3])){
				v[i]+=n;
			}
			v[i] -= n;
		};
	loopMatch(ax, v, 0, 1);
	loopMatch(ax, v, 1, 1);
	loopMatch(ax, v, 2, 10000); // the third place in the version number is usually 5 digits (4.0.xxxxx)
	loopMatch(ax, v, 2, 1000);
	loopMatch(ax, v, 2, 100);
	loopMatch(ax, v, 2, 10);
	loopMatch(ax, v, 2, 1);
	loopMatch(ax, v, 3, 1);

	return v;
});
// add adobe acrobat
/*
PluginDetector.addPlugin('acrobat','Adobe Acrobat','application/pdf','AcroPDF.PDF', function (ax) {
	var version = [],
		d = ax.GetVersions().split(',')[0].split('=')[1].split('.');

	if (d) {
		version = [parseInt(d[0], 10), parseInt(d[1], 10), parseInt(d[2], 10)];
	}
	return version;
});
*/
// necessary detection (fixes for <IE9)
mejs.MediaFeatures = {
	init: function() {
		var
			t = this,
			d = document,
			nav = mejs.PluginDetector.nav,
			ua = mejs.PluginDetector.ua.toLowerCase(),
			i,
			v,
			html5Elements = ['source','track','audio','video'];

		// detect browsers (only the ones that have some kind of quirk we need to work around)
		t.isiPad = (ua.match(/ipad/i) !== null);
		t.isiPhone = (ua.match(/iphone/i) !== null);
		t.isiOS = t.isiPhone || t.isiPad;
		t.isAndroid = (ua.match(/android/i) !== null);
		t.isBustedAndroid = (ua.match(/android 2\.[12]/) !== null);
		t.isBustedNativeHTTPS = (location.protocol === 'https:' && (ua.match(/android [12]\./) !== null || ua.match(/macintosh.* version.* safari/) !== null));
		t.isIE = (nav.appName.toLowerCase().indexOf("microsoft") != -1 || nav.appName.toLowerCase().match(/trident/gi) !== null);
		t.isChrome = (ua.match(/chrome/gi) !== null);
		t.isChromium = (ua.match(/chromium/gi) !== null);
		t.isFirefox = (ua.match(/firefox/gi) !== null);
		t.isWebkit = (ua.match(/webkit/gi) !== null);
		t.isGecko = (ua.match(/gecko/gi) !== null) && !t.isWebkit && !t.isIE;
		t.isOpera = (ua.match(/opera/gi) !== null);
		t.hasTouch = ('ontouchstart' in window); //  && window.ontouchstart != null); // this breaks iOS 7

		// Borrowed from `Modernizr.svgasimg`, sources:
		// - https://github.com/Modernizr/Modernizr/issues/687
		// - https://github.com/Modernizr/Modernizr/pull/1209/files
		t.svgAsImg = !!document.implementation.hasFeature('http://www.w3.org/TR/SVG11/feature#Image', '1.1');

		// create HTML5 media elements for IE before 9, get a <video> element for fullscreen detection
		for (i=0; i<html5Elements.length; i++) {
			v = document.createElement(html5Elements[i]);
		}

		t.supportsMediaTag = (typeof v.canPlayType !== 'undefined' || t.isBustedAndroid);

		// Fix for IE9 on Windows 7N / Windows 7KN (Media Player not installer)
		try{
			v.canPlayType("video/mp4");
		}catch(e){
			t.supportsMediaTag = false;
		}

		t.supportsPointerEvents = (function() {
			// TAKEN FROM MODERNIZR
			var element = document.createElement('x'),
				documentElement = document.documentElement,
				getComputedStyle = window.getComputedStyle,
				supports;
			if(!('pointerEvents' in element.style)){
				return false;
			}
			element.style.pointerEvents = 'auto';
			element.style.pointerEvents = 'x';
			documentElement.appendChild(element);
			supports = getComputedStyle &&
				getComputedStyle(element, '').pointerEvents === 'auto';
			documentElement.removeChild(element);
			return !!supports;
		})();


		 // Older versions of Firefox can't move plugins around without it resetting,
		t.hasFirefoxPluginMovingProblem = false;

		// detect native JavaScript fullscreen (Safari/Firefox only, Chrome still fails)

		// iOS
		t.hasiOSFullScreen = (typeof v.webkitEnterFullscreen !== 'undefined');

		// W3C
		t.hasNativeFullscreen = (typeof v.requestFullscreen !== 'undefined');

		// webkit/firefox/IE11+
		t.hasWebkitNativeFullScreen = (typeof v.webkitRequestFullScreen !== 'undefined');
		t.hasMozNativeFullScreen = (typeof v.mozRequestFullScreen !== 'undefined');
		t.hasMsNativeFullScreen = (typeof v.msRequestFullscreen !== 'undefined');

		t.hasTrueNativeFullScreen = (t.hasWebkitNativeFullScreen || t.hasMozNativeFullScreen || t.hasMsNativeFullScreen);
		t.nativeFullScreenEnabled = t.hasTrueNativeFullScreen;

		// Enabled?
		if (t.hasMozNativeFullScreen) {
			t.nativeFullScreenEnabled = document.mozFullScreenEnabled;
		} else if (t.hasMsNativeFullScreen) {
			t.nativeFullScreenEnabled = document.msFullscreenEnabled;
		}

		if (t.isChrome) {
			t.hasiOSFullScreen = false;
		}

		if (t.hasTrueNativeFullScreen) {

			t.fullScreenEventName = '';
			if (t.hasWebkitNativeFullScreen) {
				t.fullScreenEventName = 'webkitfullscreenchange';

			} else if (t.hasMozNativeFullScreen) {
				t.fullScreenEventName = 'mozfullscreenchange';

			} else if (t.hasMsNativeFullScreen) {
				t.fullScreenEventName = 'MSFullscreenChange';
			}

			t.isFullScreen = function() {
				if (t.hasMozNativeFullScreen) {
					return d.mozFullScreen;

				} else if (t.hasWebkitNativeFullScreen) {
					return d.webkitIsFullScreen;

				} else if (t.hasMsNativeFullScreen) {
					return d.msFullscreenElement !== null;
				}
			}

			t.requestFullScreen = function(el) {

				if (t.hasWebkitNativeFullScreen) {
					el.webkitRequestFullScreen();

				} else if (t.hasMozNativeFullScreen) {
					el.mozRequestFullScreen();

				} else if (t.hasMsNativeFullScreen) {
					el.msRequestFullscreen();

				}
			}

			t.cancelFullScreen = function() {
				if (t.hasWebkitNativeFullScreen) {
					document.webkitCancelFullScreen();

				} else if (t.hasMozNativeFullScreen) {
					document.mozCancelFullScreen();

				} else if (t.hasMsNativeFullScreen) {
					document.msExitFullscreen();

				}
			}

		}


		// OS X 10.5 can't do this even if it says it can :(
		if (t.hasiOSFullScreen && ua.match(/mac os x 10_5/i)) {
			t.hasNativeFullScreen = false;
			t.hasiOSFullScreen = false;
		}

	}
};
mejs.MediaFeatures.init();

/*
extension methods to <video> or <audio> object to bring it into parity with PluginMediaElement (see below)
*/
mejs.HtmlMediaElement = {
	pluginType: 'native',
	isFullScreen: false,

	setCurrentTime: function (time) {
		this.currentTime = time;
	},

	setMuted: function (muted) {
		this.muted = muted;
	},

	setVolume: function (volume) {
		this.volume = volume;
	},

	// for parity with the plugin versions
	stop: function () {
		this.pause();
	},

	// This can be a url string
	// or an array [{src:'file.mp4',type:'video/mp4'},{src:'file.webm',type:'video/webm'}]
	setSrc: function (url) {
		
		// Fix for IE9 which can't set .src when there are <source> elements. Awesome, right?
		var 
			existingSources = this.getElementsByTagName('source');
		while (existingSources.length > 0){
			this.removeChild(existingSources[0]);
		}
	
		if (typeof url == 'string') {
			this.src = url;
		} else {
			var i, media;

			for (i=0; i<url.length; i++) {
				media = url[i];
				if (this.canPlayType(media.type)) {
					this.src = media.src;
					break;
				}
			}
		}
	},

	setVideoSize: function (width, height) {
		this.width = width;
		this.height = height;
	}
};

/*
Mimics the <video/audio> element by calling Flash's External Interface or Silverlights [ScriptableMember]
*/
mejs.PluginMediaElement = function (pluginid, pluginType, mediaUrl) {
	this.id = pluginid;
	this.pluginType = pluginType;
	this.src = mediaUrl;
	this.events = {};
	this.attributes = {};
};

// JavaScript values and ExternalInterface methods that match HTML5 video properties methods
// http://www.adobe.com/livedocs/flash/9.0/ActionScriptLangRefV3/fl/video/FLVPlayback.html
// http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html
mejs.PluginMediaElement.prototype = {

	// special
	pluginElement: null,
	pluginType: '',
	isFullScreen: false,

	// not implemented :(
	playbackRate: -1,
	defaultPlaybackRate: -1,
	seekable: [],
	played: [],

	// HTML5 read-only properties
	paused: true,
	ended: false,
	seeking: false,
	duration: 0,
	error: null,
	tagName: '',

	// HTML5 get/set properties, but only set (updated by event handlers)
	muted: false,
	volume: 1,
	currentTime: 0,

	// HTML5 methods
	play: function () {
		if (this.pluginApi != null) {
			if (this.pluginType == 'youtube' || this.pluginType == 'vimeo') {
				this.pluginApi.playVideo();
			} else {
				this.pluginApi.playMedia();
			}
			this.paused = false;
		}
	},
	load: function () {
		if (this.pluginApi != null) {
			if (this.pluginType == 'youtube' || this.pluginType == 'vimeo') {
			} else {
				this.pluginApi.loadMedia();
			}
			
			this.paused = false;
		}
	},
	pause: function () {
		if (this.pluginApi != null) {
			if (this.pluginType == 'youtube' || this.pluginType == 'vimeo') {
		        if( this.pluginApi.getPlayerState() == 1 ) {
				    this.pluginApi.pauseVideo();
                }
			} else {
				this.pluginApi.pauseMedia();
			}			
			
			
			this.paused = true;
		}
	},
	stop: function () {
		if (this.pluginApi != null) {
			if (this.pluginType == 'youtube' || this.pluginType == 'vimeo') {
				this.pluginApi.stopVideo();
			} else {
				this.pluginApi.stopMedia();
			}	
			this.paused = true;
		}
	},
	canPlayType: function(type) {
		var i,
			j,
			pluginInfo,
			pluginVersions = mejs.plugins[this.pluginType];

		for (i=0; i<pluginVersions.length; i++) {
			pluginInfo = pluginVersions[i];

			// test if user has the correct plugin version
			if (mejs.PluginDetector.hasPluginVersion(this.pluginType, pluginInfo.version)) {

				// test for plugin playback types
				for (j=0; j<pluginInfo.types.length; j++) {
					// find plugin that can play the type
					if (type == pluginInfo.types[j]) {
						return 'probably';
					}
				}
			}
		}

		return '';
	},
	
	positionFullscreenButton: function(x,y,visibleAndAbove) {
		if (this.pluginApi != null && this.pluginApi.positionFullscreenButton) {
			this.pluginApi.positionFullscreenButton(Math.floor(x),Math.floor(y),visibleAndAbove);
		}
	},
	
	hideFullscreenButton: function() {
		if (this.pluginApi != null && this.pluginApi.hideFullscreenButton) {
			this.pluginApi.hideFullscreenButton();
		}		
	},	
	

	// custom methods since not all JavaScript implementations support get/set

	// This can be a url string
	// or an array [{src:'file.mp4',type:'video/mp4'},{src:'file.webm',type:'video/webm'}]
	setSrc: function (url) {
		if (typeof url == 'string') {
			this.pluginApi.setSrc(mejs.Utility.absolutizeUrl(url));
			this.src = mejs.Utility.absolutizeUrl(url);
		} else {
			var i, media;

			for (i=0; i<url.length; i++) {
				media = url[i];
				if (this.canPlayType(media.type)) {
					this.pluginApi.setSrc(mejs.Utility.absolutizeUrl(media.src));
					this.src = mejs.Utility.absolutizeUrl(media.src);
					break;
				}
			}
		}

	},
	setCurrentTime: function (time) {
		if (this.pluginApi != null) {
			if (this.pluginType == 'youtube' || this.pluginType == 'vimeo') {
				this.pluginApi.seekTo(time);
			} else {
				this.pluginApi.setCurrentTime(time);
			}				
			
			
			
			this.currentTime = time;
		}
	},
	setVolume: function (volume) {
		if (this.pluginApi != null) {
			// same on YouTube and MEjs
			if (this.pluginType == 'youtube') {
				this.pluginApi.setVolume(volume * 100);
			} else {
				this.pluginApi.setVolume(volume);
			}
			this.volume = volume;
		}
	},
	setMuted: function (muted) {
		if (this.pluginApi != null) {
			if (this.pluginType == 'youtube') {
				if (muted) {
					this.pluginApi.mute();
				} else {
					this.pluginApi.unMute();
				}
				this.muted = muted;
				this.dispatchEvent({type:'volumechange'});
			} else {
				this.pluginApi.setMuted(muted);
			}
			this.muted = muted;
		}
	},

	// additional non-HTML5 methods
	setVideoSize: function (width, height) {
		
		//if (this.pluginType == 'flash' || this.pluginType == 'silverlight') {
			if (this.pluginElement && this.pluginElement.style) {
				this.pluginElement.style.width = width + 'px';
				this.pluginElement.style.height = height + 'px';
			}
			if (this.pluginApi != null && this.pluginApi.setVideoSize) {
				this.pluginApi.setVideoSize(width, height);
			}
		//}
	},

	setFullscreen: function (fullscreen) {
		if (this.pluginApi != null && this.pluginApi.setFullscreen) {
			this.pluginApi.setFullscreen(fullscreen);
		}
	},
	
	enterFullScreen: function() {
		if (this.pluginApi != null && this.pluginApi.setFullscreen) {
			this.setFullscreen(true);
		}		
		
	},
	
	exitFullScreen: function() {
		if (this.pluginApi != null && this.pluginApi.setFullscreen) {
			this.setFullscreen(false);
		}
	},	

	// start: fake events
	addEventListener: function (eventName, callback, bubble) {
		this.events[eventName] = this.events[eventName] || [];
		this.events[eventName].push(callback);
	},
	removeEventListener: function (eventName, callback) {
		if (!eventName) { this.events = {}; return true; }
		var callbacks = this.events[eventName];
		if (!callbacks) return true;
		if (!callback) { this.events[eventName] = []; return true; }
		for (var i = 0; i < callbacks.length; i++) {
			if (callbacks[i] === callback) {
				this.events[eventName].splice(i, 1);
				return true;
			}
		}
		return false;
	},	
	dispatchEvent: function (event) {
		var i,
			args,
			callbacks = this.events[event.type];

		if (callbacks) {
			for (i = 0; i < callbacks.length; i++) {
				callbacks[i].apply(this, [event]);
			}
		}
	},
	// end: fake events
	
	// fake DOM attribute methods
	hasAttribute: function(name){
		return (name in this.attributes);  
	},
	removeAttribute: function(name){
		delete this.attributes[name];
	},
	getAttribute: function(name){
		if (this.hasAttribute(name)) {
			return this.attributes[name];
		}
		return '';
	},
	setAttribute: function(name, value){
		this.attributes[name] = value;
	},

	remove: function() {
		mejs.Utility.removeSwf(this.pluginElement.id);
		mejs.MediaPluginBridge.unregisterPluginElement(this.pluginElement.id);
	}
};

/*
Default options
*/
mejs.MediaElementDefaults = {
	// allows testing on HTML5, flash, silverlight
	// auto: attempts to detect what the browser can do
	// auto_plugin: prefer plugins and then attempt native HTML5
	// native: forces HTML5 playback
	// shim: disallows HTML5, will attempt either Flash or Silverlight
	// none: forces fallback view
	mode: 'auto',
	// remove or reorder to change plugin priority and availability
	plugins: ['flash','silverlight','youtube','vimeo'],
	// shows debug errors on screen
	enablePluginDebug: false,
	// use plugin for browsers that have trouble with Basic Authentication on HTTPS sites
	httpsBasicAuthSite: false,
	// overrides the type specified, useful for dynamic instantiation
	type: '',
	// path to Flash and Silverlight plugins
	pluginPath: mejs.Utility.getScriptPath(['mediaelement.js','mediaelement.min.js','mediaelement-and-player.js','mediaelement-and-player.min.js']),
	// name of flash file
	flashName: 'flashmediaelement.swf',
	// streamer for RTMP streaming
	flashStreamer: '',
	// set to 'always' for CDN version
	flashScriptAccess: 'sameDomain',	
	// turns on the smoothing filter in Flash
	enablePluginSmoothing: false,
	// enabled pseudo-streaming (seek) on .mp4 files
	enablePseudoStreaming: false,
	// start query parameter sent to server for pseudo-streaming
	pseudoStreamingStartQueryParam: 'start',
	// name of silverlight file
	silverlightName: 'silverlightmediaelement.xap',
	// default if the <video width> is not specified
	defaultVideoWidth: 480,
	// default if the <video height> is not specified
	defaultVideoHeight: 270,
	// overrides <video width>
	pluginWidth: -1,
	// overrides <video height>
	pluginHeight: -1,
	// additional plugin variables in 'key=value' form
	pluginVars: [],	
	// rate in milliseconds for Flash and Silverlight to fire the timeupdate event
	// larger number is less accurate, but less strain on plugin->JavaScript bridge
	timerRate: 250,
	// initial volume for player
	startVolume: 0.8,
	success: function () { },
	error: function () { }
};

/*
Determines if a browser supports the <video> or <audio> element
and returns either the native element or a Flash/Silverlight version that
mimics HTML5 MediaElement
*/
mejs.MediaElement = function (el, o) {
	return mejs.HtmlMediaElementShim.create(el,o);
};

mejs.HtmlMediaElementShim = {

	create: function(el, o) {
		var
			options = {},
			htmlMediaElement = (typeof(el) == 'string') ? document.getElementById(el) : el,
			tagName = htmlMediaElement.tagName.toLowerCase(),
			isMediaTag = (tagName === 'audio' || tagName === 'video'),
			src = (isMediaTag) ? htmlMediaElement.getAttribute('src') : htmlMediaElement.getAttribute('href'),
			poster = htmlMediaElement.getAttribute('poster'),
			autoplay =  htmlMediaElement.getAttribute('autoplay'),
			preload =  htmlMediaElement.getAttribute('preload'),
			controls =  htmlMediaElement.getAttribute('controls'),
			playback,
			prop;

		// extend options
		for (prop in mejs.MediaElementDefaults) {
			options[prop] = mejs.MediaElementDefaults[prop];
		}
		for (prop in o) {
			options[prop] = o[prop];
		}		
		

		// clean up attributes
		src = 		(typeof src == 'undefined' 	|| src === null || src == '') ? null : src;		
		poster =	(typeof poster == 'undefined' 	|| poster === null) ? '' : poster;
		preload = 	(typeof preload == 'undefined' 	|| preload === null || preload === 'false') ? 'none' : preload;
		autoplay = 	!(typeof autoplay == 'undefined' || autoplay === null || autoplay === 'false');
		controls = 	!(typeof controls == 'undefined' || controls === null || controls === 'false');

		// test for HTML5 and plugin capabilities
		playback = this.determinePlayback(htmlMediaElement, options, mejs.MediaFeatures.supportsMediaTag, isMediaTag, src);
		playback.url = (playback.url !== null) ? mejs.Utility.absolutizeUrl(playback.url) : '';
        playback.scheme = mejs.Utility.determineScheme(playback.url);

		if (playback.method == 'native') {
			// second fix for android
			if (mejs.MediaFeatures.isBustedAndroid) {
				htmlMediaElement.src = playback.url;
				htmlMediaElement.addEventListener('click', function() {
					htmlMediaElement.play();
				}, false);
			}
		
			// add methods to native HTMLMediaElement
			return this.updateNative(playback, options, autoplay, preload);
		} else if (playback.method !== '') {
			// create plugin to mimic HTMLMediaElement
			
			return this.createPlugin( playback,  options, poster, autoplay, preload, controls);
		} else {
			// boo, no HTML5, no Flash, no Silverlight.
			this.createErrorMessage( playback, options, poster );
			
			return this;
		}
	},
	
	determinePlayback: function(htmlMediaElement, options, supportsMediaTag, isMediaTag, src) {
		var
			mediaFiles = [],
			i,
			j,
			k,
			l,
			n,
			type,
			result = { method: '', url: '', htmlMediaElement: htmlMediaElement, isVideo: (htmlMediaElement.tagName.toLowerCase() != 'audio'), scheme: ''},
			pluginName,
			pluginVersions,
			pluginInfo,
			dummy,
			media;
			
		// STEP 1: Get URL and type from <video src> or <source src>

		// supplied type overrides <video type> and <source type>
		if (typeof options.type != 'undefined' && options.type !== '') {
			
			// accept either string or array of types
			if (typeof options.type == 'string') {
				mediaFiles.push({type:options.type, url:src});
			} else {
				
				for (i=0; i<options.type.length; i++) {
					mediaFiles.push({type:options.type[i], url:src});
				}
			}

		// test for src attribute first
		} else if (src !== null) {
			type = this.formatType(src, htmlMediaElement.getAttribute('type'));
			mediaFiles.push({type:type, url:src});

		// then test for <source> elements
		} else {
			// test <source> types to see if they are usable
			for (i = 0; i < htmlMediaElement.childNodes.length; i++) {
				n = htmlMediaElement.childNodes[i];
				if (n.nodeType == 1 && n.tagName.toLowerCase() == 'source') {
					src = n.getAttribute('src');
					type = this.formatType(src, n.getAttribute('type'));
					media = n.getAttribute('media');

					if (!media || !window.matchMedia || (window.matchMedia && window.matchMedia(media).matches)) {
						mediaFiles.push({type:type, url:src});
					}
				}
			}
		}
		
		// in the case of dynamicly created players
		// check for audio types
		if (!isMediaTag && mediaFiles.length > 0 && mediaFiles[0].url !== null && this.getTypeFromFile(mediaFiles[0].url).indexOf('audio') > -1) {
			result.isVideo = false;
		}
		

		// STEP 2: Test for playback method
		
		// special case for Android which sadly doesn't implement the canPlayType function (always returns '')
		if (mejs.MediaFeatures.isBustedAndroid) {
			htmlMediaElement.canPlayType = function(type) {
				return (type.match(/video\/(mp4|m4v)/gi) !== null) ? 'maybe' : '';
			};
		}		
		
		// special case for Chromium to specify natively supported video codecs (i.e. WebM and Theora) 
		if (mejs.MediaFeatures.isChromium) { 
			htmlMediaElement.canPlayType = function(type) { 
				return (type.match(/video\/(webm|ogv|ogg)/gi) !== null) ? 'maybe' : ''; 
			}; 
		}

		// test for native playback first
		if (supportsMediaTag && (options.mode === 'auto' || options.mode === 'auto_plugin' || options.mode === 'native')  && !(mejs.MediaFeatures.isBustedNativeHTTPS && options.httpsBasicAuthSite === true)) {
						
			if (!isMediaTag) {

				// create a real HTML5 Media Element 
				dummy = document.createElement( result.isVideo ? 'video' : 'audio');			
				htmlMediaElement.parentNode.insertBefore(dummy, htmlMediaElement);
				htmlMediaElement.style.display = 'none';
				
				// use this one from now on
				result.htmlMediaElement = htmlMediaElement = dummy;
			}
				
			for (i=0; i<mediaFiles.length; i++) {
				// normal check
				if (mediaFiles[i].type == "video/m3u8" || htmlMediaElement.canPlayType(mediaFiles[i].type).replace(/no/, '') !== ''
					// special case for Mac/Safari 5.0.3 which answers '' to canPlayType('audio/mp3') but 'maybe' to canPlayType('audio/mpeg')
					|| htmlMediaElement.canPlayType(mediaFiles[i].type.replace(/mp3/,'mpeg')).replace(/no/, '') !== ''
					// special case for m4a supported by detecting mp4 support
					|| htmlMediaElement.canPlayType(mediaFiles[i].type.replace(/m4a/,'mp4')).replace(/no/, '') !== '') {
					result.method = 'native';
					result.url = mediaFiles[i].url;
					break;
				}
			}			
			
			if (result.method === 'native') {
				if (result.url !== null) {
					htmlMediaElement.src = result.url;
				}
			
				// if `auto_plugin` mode, then cache the native result but try plugins.
				if (options.mode !== 'auto_plugin') {
					return result;
				}
			}
		}

		// if native playback didn't work, then test plugins
		if (options.mode === 'auto' || options.mode === 'auto_plugin' || options.mode === 'shim') {
			for (i=0; i<mediaFiles.length; i++) {
				type = mediaFiles[i].type;

				// test all plugins in order of preference [silverlight, flash]
				for (j=0; j<options.plugins.length; j++) {

					pluginName = options.plugins[j];
			
					// test version of plugin (for future features)
					pluginVersions = mejs.plugins[pluginName];				
					
					for (k=0; k<pluginVersions.length; k++) {
						pluginInfo = pluginVersions[k];
					
						// test if user has the correct plugin version
						
						// for youtube/vimeo
						if (pluginInfo.version == null || 
							
							mejs.PluginDetector.hasPluginVersion(pluginName, pluginInfo.version)) {

							// test for plugin playback types
							for (l=0; l<pluginInfo.types.length; l++) {
								// find plugin that can play the type
								if (type.toLowerCase() == pluginInfo.types[l].toLowerCase()) {
									result.method = pluginName;
									result.url = mediaFiles[i].url;
									return result;
								}
							}
						}
					}
				}
			}
		}
		
		// at this point, being in 'auto_plugin' mode implies that we tried plugins but failed.
		// if we have native support then return that.
		if (options.mode === 'auto_plugin' && result.method === 'native') {
			return result;
		}

		// what if there's nothing to play? just grab the first available
		if (result.method === '' && mediaFiles.length > 0) {
			result.url = mediaFiles[0].url;
		}

		return result;
	},

	formatType: function(url, type) {
		// if no type is supplied, fake it with the extension
		if (url && !type) {		
			return this.getTypeFromFile(url);
		} else {
			// only return the mime part of the type in case the attribute contains the codec
			// see http://www.whatwg.org/specs/web-apps/current-work/multipage/video.html#the-source-element
			// `video/mp4; codecs="avc1.42E01E, mp4a.40.2"` becomes `video/mp4`
			
			if (type && ~type.indexOf(';')) {
				return type.substr(0, type.indexOf(';')); 
			} else {
				return type;
			}
		}
	},
	
	getTypeFromFile: function(url) {
		url = url.split('?')[0];
		var
			ext = url.substring(url.lastIndexOf('.') + 1).toLowerCase(),
			av = /(mp4|m4v|ogg|ogv|m3u8|webm|webmv|flv|wmv|mpeg|mov)/gi.test(ext) ? 'video/' : 'audio/';
		return this.getTypeFromExtension(ext, av);
	},
	
	getTypeFromExtension: function(ext, av) {
		av = av || '';
		
		switch (ext) {
			case 'mp4':
			case 'm4v':
			case 'm4a':
			case 'f4v':
			case 'f4a':
				return av + 'mp4';
			case 'flv':
				return av + 'x-flv';
			case 'webm':
			case 'webma':
			case 'webmv':	
				return av + 'webm';
			case 'ogg':
			case 'oga':
			case 'ogv':	
				return av + 'ogg';
			case 'm3u8':
				return 'application/x-mpegurl';
			case 'ts':
				return av + 'mp2t';
			default:
				return av + ext;
		}
	},

	createErrorMessage: function(playback, options, poster) {
		var 
			htmlMediaElement = playback.htmlMediaElement,
			errorContainer = document.createElement('div'),
			errorContent = options.customError;
			
		errorContainer.className = 'me-cannotplay';

		try {
			errorContainer.style.width = htmlMediaElement.width + 'px';
			errorContainer.style.height = htmlMediaElement.height + 'px';
		} catch (e) {}

		if (!errorContent) {
			errorContent = '<a href="' + playback.url + '">';

			if (poster !== '') {
				errorContent += '<img src="' + poster + '" width="100%" height="100%" alt="" />';
			}

			errorContent += '<span>' + mejs.i18n.t('Download File') + '</span></a>';
		}

		errorContainer.innerHTML = errorContent;

		htmlMediaElement.parentNode.insertBefore(errorContainer, htmlMediaElement);
		htmlMediaElement.style.display = 'none';

		options.error(htmlMediaElement);
	},

	createPlugin:function(playback, options, poster, autoplay, preload, controls) {
		var 
			htmlMediaElement = playback.htmlMediaElement,
			width = 1,
			height = 1,
			pluginid = 'me_' + playback.method + '_' + (mejs.meIndex++),
			pluginMediaElement = new mejs.PluginMediaElement(pluginid, playback.method, playback.url),
			container = document.createElement('div'),
			specialIEContainer,
			node,
			initVars;

		// copy tagName from html media element
		pluginMediaElement.tagName = htmlMediaElement.tagName

		// copy attributes from html media element to plugin media element
		for (var i = 0; i < htmlMediaElement.attributes.length; i++) {
			var attribute = htmlMediaElement.attributes[i];
			if (attribute.specified) {
				pluginMediaElement.setAttribute(attribute.name, attribute.value);
			}
		}

		// check for placement inside a <p> tag (sometimes WYSIWYG editors do this)
		node = htmlMediaElement.parentNode;

		while (node !== null && node.tagName != null && node.tagName.toLowerCase() !== 'body' && 
				node.parentNode != null && node.parentNode.tagName != null && node.parentNode.constructor != null && node.parentNode.constructor.name === "ShadowRoot") {
			if (node.parentNode.tagName.toLowerCase() === 'p') {
				node.parentNode.parentNode.insertBefore(node, node.parentNode);
				break;
			}
			node = node.parentNode;
		}

		if (playback.isVideo) {
			width = (options.pluginWidth > 0) ? options.pluginWidth : (options.videoWidth > 0) ? options.videoWidth : (htmlMediaElement.getAttribute('width') !== null) ? htmlMediaElement.getAttribute('width') : options.defaultVideoWidth;
			height = (options.pluginHeight > 0) ? options.pluginHeight : (options.videoHeight > 0) ? options.videoHeight : (htmlMediaElement.getAttribute('height') !== null) ? htmlMediaElement.getAttribute('height') : options.defaultVideoHeight;
		
			// in case of '%' make sure it's encoded
			width = mejs.Utility.encodeUrl(width);
			height = mejs.Utility.encodeUrl(height);
		
		} else {
			if (options.enablePluginDebug) {
				width = 320;
				height = 240;
			}
		}

		// register plugin
		pluginMediaElement.success = options.success;
		
		// add container (must be added to DOM before inserting HTML for IE)
		container.className = 'me-plugin';
		container.id = pluginid + '_container';
		
		if (playback.isVideo) {
				htmlMediaElement.parentNode.insertBefore(container, htmlMediaElement);
		} else {
				document.body.insertBefore(container, document.body.childNodes[0]);
		}
		
		if (playback.method === 'flash' || playback.method === 'silverlight') {

			// flash/silverlight vars
			initVars = [
				'id=' + pluginid,
				'isvideo=' + ((playback.isVideo) ? "true" : "false"),
				'autoplay=' + ((autoplay) ? "true" : "false"),
				'preload=' + preload,
				'width=' + width,
				'startvolume=' + options.startVolume,
				'timerrate=' + options.timerRate,
				'flashstreamer=' + options.flashStreamer,
				'height=' + height,
				'pseudostreamstart=' + options.pseudoStreamingStartQueryParam];
	
			if (playback.url !== null) {
				if (playback.method == 'flash') {
					initVars.push('file=' + mejs.Utility.encodeUrl(playback.url));
				} else {
					initVars.push('file=' + playback.url);
				}
			}
			if (options.enablePluginDebug) {
				initVars.push('debug=true');
			}
			if (options.enablePluginSmoothing) {
				initVars.push('smoothing=true');
			}
			if (options.enablePseudoStreaming) {
				initVars.push('pseudostreaming=true');
			}
			if (controls) {
				initVars.push('controls=true'); // shows controls in the plugin if desired
			}
			if (options.pluginVars) {
				initVars = initVars.concat(options.pluginVars);
			}		
			
			// call from plugin
			window[pluginid + '_init'] = function() {
				switch (pluginMediaElement.pluginType) {
					case 'flash':
						pluginMediaElement.pluginElement = pluginMediaElement.pluginApi = document.getElementById(pluginid);
						break;
					case 'silverlight':
						pluginMediaElement.pluginElement = document.getElementById(pluginMediaElement.id);
						pluginMediaElement.pluginApi = pluginMediaElement.pluginElement.Content.MediaElementJS;
						break;
				}
	
				if (pluginMediaElement.pluginApi != null && pluginMediaElement.success) {
					pluginMediaElement.success(pluginMediaElement, htmlMediaElement);
				}
			}
			
			// event call from plugin
			window[pluginid + '_event'] = function(eventName, values) {
		
				var
					e,
					i,
					bufferedTime;
		        
				// fake event object to mimic real HTML media event.
				e = {
					type: eventName,
					target: pluginMediaElement
				};
		
				// attach all values to element and event object
				for (i in values) {
					pluginMediaElement[i] = values[i];
					e[i] = values[i];
				}
		
				// fake the newer W3C buffered TimeRange (loaded and total have been removed)
				bufferedTime = values.bufferedTime || 0;
		
				e.target.buffered = e.buffered = {
					start: function(index) {
						return 0;
					},
					end: function (index) {
						return bufferedTime;
					},
					length: 1
				};
		
				pluginMediaElement.dispatchEvent(e);
			}			
			
			
		}

		switch (playback.method) {
			case 'silverlight':
				container.innerHTML =
'<object data="data:application/x-silverlight-2," type="application/x-silverlight-2" id="' + pluginid + '" name="' + pluginid + '" width="' + width + '" height="' + height + '" class="mejs-shim">' +
'<param name="initParams" value="' + initVars.join(',') + '" />' +
'<param name="windowless" value="true" />' +
'<param name="background" value="black" />' +
'<param name="minRuntimeVersion" value="3.0.0.0" />' +
'<param name="autoUpgrade" value="true" />' +
'<param name="source" value="' + options.pluginPath + options.silverlightName + '" />' +
'</object>';
					break;

			case 'flash':

				if (mejs.MediaFeatures.isIE) {
					specialIEContainer = document.createElement('div');
					container.appendChild(specialIEContainer);
					specialIEContainer.outerHTML =
'<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="//download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab" ' +
'id="' + pluginid + '" width="' + width + '" height="' + height + '" class="mejs-shim">' +
'<param name="movie" value="' + options.pluginPath + options.flashName + '?' + (new Date().getTime()) + '" />' +
'<param name="flashvars" value="' + initVars.join('&amp;') + '" />' +
'<param name="quality" value="high" />' +
'<param name="bgcolor" value="#000000" />' +
'<param name="wmode" value="transparent" />' +
'<param name="allowScriptAccess" value="' + options.flashScriptAccess + '" />' +
'<param name="allowFullScreen" value="true" />' +
'<param name="scale" value="default" />' + 
'</object>';

				} else {

					container.innerHTML =
'<embed id="' + pluginid + '" name="' + pluginid + '" ' +
'play="true" ' +
'loop="false" ' +
'quality="high" ' +
'bgcolor="#000000" ' +
'wmode="transparent" ' +
'allowScriptAccess="' + options.flashScriptAccess + '" ' +
'allowFullScreen="true" ' +
'type="application/x-shockwave-flash" pluginspage="//www.macromedia.com/go/getflashplayer" ' +
'src="' + options.pluginPath + options.flashName + '" ' +
'flashvars="' + initVars.join('&') + '" ' +
'width="' + width + '" ' +
'height="' + height + '" ' +
'scale="default"' + 
'class="mejs-shim"></embed>';
				}
				break;
			
			case 'youtube':
			
				
				var videoId;
				// youtu.be url from share button
				if (playback.url.lastIndexOf("youtu.be") != -1) {
					videoId = playback.url.substr(playback.url.lastIndexOf('/')+1);
					if (videoId.indexOf('?') != -1) {
						videoId = videoId.substr(0, videoId.indexOf('?'));
					}
				}
				else {
					videoId = playback.url.substr(playback.url.lastIndexOf('=')+1);
				}
				youtubeSettings = {
						container: container,
						containerId: container.id,
						pluginMediaElement: pluginMediaElement,
						pluginId: pluginid,
						videoId: videoId,
						height: height,
						width: width,
                        scheme: playback.scheme
					};				
				
				// favor iframe version of YouTube
				if (window.postMessage) {
					mejs.YouTubeApi.enqueueIframe(youtubeSettings);		
				} else if (mejs.PluginDetector.hasPluginVersion('flash', [10,0,0]) ) {
					mejs.YouTubeApi.createFlash(youtubeSettings, options);
				}
				
				break;
			
			// DEMO Code. Does NOT work.
			case 'vimeo':
				var player_id = pluginid + "_player";
				pluginMediaElement.vimeoid = playback.url.substr(playback.url.lastIndexOf('/')+1);
				
				container.innerHTML ='<iframe src="' + playback.scheme + 'player.vimeo.com/video/' + pluginMediaElement.vimeoid + '?api=1&portrait=0&byline=0&title=0&player_id=' + player_id + '" width="' + width +'" height="' + height +'" frameborder="0" class="mejs-shim" id="' + player_id + '" webkitallowfullscreen mozallowfullscreen allowfullscreen></iframe>';
				if (typeof($f) == 'function') { // froogaloop available
					var player = $f(container.childNodes[0]),
						playerState = -1;
					
					player.addEvent('ready', function() {
		
						player.playVideo = function() {
							player.api( 'play' );
						} 
						player.stopVideo = function() {
							player.api( 'unload' );
						} 
						player.pauseVideo = function() {
							player.api( 'pause' );
						} 
						player.seekTo = function( seconds ) {
							player.api( 'seekTo', seconds );
						}
						player.setVolume = function( volume ) {
							player.api( 'setVolume', volume );
						}
						player.setMuted = function( muted ) {
							if( muted ) {
								player.lastVolume = player.api( 'getVolume' );
								player.api( 'setVolume', 0 );
							} else {
								player.api( 'setVolume', player.lastVolume );
								delete player.lastVolume;
							}
						}
						// parity with YT player
						player.getPlayerState = function() {
							return playerState;
						}			

						function createEvent(player, pluginMediaElement, eventName, e) {
							var event = {
								type: eventName,
								target: pluginMediaElement
							};
							if (eventName == 'timeupdate') {
								pluginMediaElement.currentTime = event.currentTime = e.seconds;
								pluginMediaElement.duration = event.duration = e.duration;
							}
							pluginMediaElement.dispatchEvent(event);
						}

						player.addEvent('play', function() {
							playerState = 1;
							createEvent(player, pluginMediaElement, 'play');
							createEvent(player, pluginMediaElement, 'playing');
						});

						player.addEvent('pause', function() {
							playerState = 2;							
							createEvent(player, pluginMediaElement, 'pause');
						});

						player.addEvent('finish', function() {
							playerState = 0;							
							createEvent(player, pluginMediaElement, 'ended');
						});

						player.addEvent('playProgress', function(e) {
							createEvent(player, pluginMediaElement, 'timeupdate', e);
						});
						
						player.addEvent('seek', function(e) {
							playerState = 3;
							createEvent(player, pluginMediaElement, 'seeked', e);
						});	
						
						player.addEvent('loadProgress', function(e) {
							playerState = 3;
							createEvent(player, pluginMediaElement, 'progress', e);
						});												

						pluginMediaElement.pluginElement = container;
						pluginMediaElement.pluginApi = player;

						pluginMediaElement.success(pluginMediaElement, pluginMediaElement.pluginElement);						
					});
				}
				else {
					console.warn("You need to include froogaloop for vimeo to work");
				}
				break;			
		}
		// hide original element
		htmlMediaElement.style.display = 'none';
		// prevent browser from autoplaying when using a plugin
		htmlMediaElement.removeAttribute('autoplay');
		
		return pluginMediaElement;
	},

	updateNative: function(playback, options, autoplay, preload) {
		
		var htmlMediaElement = playback.htmlMediaElement,
			m;
		
		
		// add methods to video object to bring it into parity with Flash Object
		for (m in mejs.HtmlMediaElement) {
			htmlMediaElement[m] = mejs.HtmlMediaElement[m];
		}

		/*
		Chrome now supports preload="none"
		if (mejs.MediaFeatures.isChrome) {
		
			// special case to enforce preload attribute (Chrome doesn't respect this)
			if (preload === 'none' && !autoplay) {
			
				// forces the browser to stop loading (note: fails in IE9)
				htmlMediaElement.src = '';
				htmlMediaElement.load();
				htmlMediaElement.canceledPreload = true;

				htmlMediaElement.addEventListener('play',function() {
					if (htmlMediaElement.canceledPreload) {
						htmlMediaElement.src = playback.url;
						htmlMediaElement.load();
						htmlMediaElement.play();
						htmlMediaElement.canceledPreload = false;
					}
				}, false);
			// for some reason Chrome forgets how to autoplay sometimes.
			} else if (autoplay) {
				htmlMediaElement.load();
				htmlMediaElement.play();
			}
		}
		*/

		// fire success code
		options.success(htmlMediaElement, htmlMediaElement);
		
		return htmlMediaElement;
	}
};

/*
 - test on IE (object vs. embed)
 - determine when to use iframe (Firefox, Safari, Mobile) vs. Flash (Chrome, IE)
 - fullscreen?
*/

// YouTube Flash and Iframe API
mejs.YouTubeApi = {
	isIframeStarted: false,
	isIframeLoaded: false,
	loadIframeApi: function(yt) {
		if (!this.isIframeStarted) {
			var tag = document.createElement('script');
			tag.src = yt.scheme + "www.youtube.com/player_api";
			var firstScriptTag = document.getElementsByTagName('script')[0];
			firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);
			this.isIframeStarted = true;
		}
	},
	iframeQueue: [],
	enqueueIframe: function(yt) {
		
		if (this.isLoaded) {
			this.createIframe(yt);
		} else {
			this.loadIframeApi(yt);
			this.iframeQueue.push(yt);
		}
	},
	createIframe: function(settings) {
		
		var
		pluginMediaElement = settings.pluginMediaElement,	
		player = new YT.Player(settings.containerId, {
			height: settings.height,
			width: settings.width,
			videoId: settings.videoId,
			playerVars: {controls:0,wmode:'transparent'},
			events: {
				'onReady': function() {
					
					// wrapper to match
					player.setVideoSize = function(width, height) {
						player.setSize(width, height);
					}
					
					// hook up iframe object to MEjs
					settings.pluginMediaElement.pluginApi = player;
					settings.pluginMediaElement.pluginElement = document.getElementById(settings.containerId);
					
					// init mejs
					pluginMediaElement.success(pluginMediaElement, pluginMediaElement.pluginElement);
					
					// create timer
					setInterval(function() {
						mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'timeupdate');
					}, 250);					
				},
				'onStateChange': function(e) {
					
					mejs.YouTubeApi.handleStateChange(e.data, player, pluginMediaElement);
					
				}
			}
		});
	},
	
	createEvent: function (player, pluginMediaElement, eventName) {
		var event = {
			type: eventName,
			target: pluginMediaElement
		};

		if (player && player.getDuration) {
			
			// time 
			pluginMediaElement.currentTime = event.currentTime = player.getCurrentTime();
			pluginMediaElement.duration = event.duration = player.getDuration();
			
			// state
			event.paused = pluginMediaElement.paused;
			event.ended = pluginMediaElement.ended;			
			
			// sound
			event.muted = player.isMuted();
			event.volume = player.getVolume() / 100;
			
			// progress
			event.bytesTotal = player.getVideoBytesTotal();
			event.bufferedBytes = player.getVideoBytesLoaded();
			
			// fake the W3C buffered TimeRange
			var bufferedTime = event.bufferedBytes / event.bytesTotal * event.duration;
			
			event.target.buffered = event.buffered = {
				start: function(index) {
					return 0;
				},
				end: function (index) {
					return bufferedTime;
				},
				length: 1
			};

		}
		
		// send event up the chain
		pluginMediaElement.dispatchEvent(event);
	},	
	
	iFrameReady: function() {
		
		this.isLoaded = true;
		this.isIframeLoaded = true;
		
		while (this.iframeQueue.length > 0) {
			var settings = this.iframeQueue.pop();
			this.createIframe(settings);
		}	
	},
	
	// FLASH!
	flashPlayers: {},
	createFlash: function(settings) {
		
		this.flashPlayers[settings.pluginId] = settings;
		
		/*
		settings.container.innerHTML =
			'<object type="application/x-shockwave-flash" id="' + settings.pluginId + '" data="' + settings.scheme + 'www.youtube.com/apiplayer?enablejsapi=1&amp;playerapiid=' + settings.pluginId  + '&amp;version=3&amp;autoplay=0&amp;controls=0&amp;modestbranding=1&loop=0" ' +
				'width="' + settings.width + '" height="' + settings.height + '" style="visibility: visible; " class="mejs-shim">' +
				'<param name="allowScriptAccess" value="sameDomain">' +
				'<param name="wmode" value="transparent">' +
			'</object>';
		*/

		var specialIEContainer,
			youtubeUrl = settings.scheme + 'www.youtube.com/apiplayer?enablejsapi=1&amp;playerapiid=' + settings.pluginId  + '&amp;version=3&amp;autoplay=0&amp;controls=0&amp;modestbranding=1&loop=0';
			
		if (mejs.MediaFeatures.isIE) {
			
			specialIEContainer = document.createElement('div');
			settings.container.appendChild(specialIEContainer);
			specialIEContainer.outerHTML = '<object classid="clsid:D27CDB6E-AE6D-11cf-96B8-444553540000" codebase="' + settings.scheme + 'download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab" ' +
'id="' + settings.pluginId + '" width="' + settings.width + '" height="' + settings.height + '" class="mejs-shim">' +
	'<param name="movie" value="' + youtubeUrl + '" />' +
	'<param name="wmode" value="transparent" />' +
	'<param name="allowScriptAccess" value="' + options.flashScriptAccess + '" />' +
	'<param name="allowFullScreen" value="true" />' +
'</object>';
		} else {
		settings.container.innerHTML =
			'<object type="application/x-shockwave-flash" id="' + settings.pluginId + '" data="' + youtubeUrl + '" ' +
				'width="' + settings.width + '" height="' + settings.height + '" style="visibility: visible; " class="mejs-shim">' +
				'<param name="allowScriptAccess" value="' + options.flashScriptAccess + '">' +
				'<param name="wmode" value="transparent">' +
			'</object>';
		}		
		
	},
	
	flashReady: function(id) {
		var
			settings = this.flashPlayers[id],
			player = document.getElementById(id),
			pluginMediaElement = settings.pluginMediaElement;
		
		// hook up and return to MediaELementPlayer.success	
		pluginMediaElement.pluginApi = 
		pluginMediaElement.pluginElement = player;
		
		settings.success(pluginMediaElement, pluginMediaElement.pluginElement);
		
		// load the youtube video
		player.cueVideoById(settings.videoId);
		
		var callbackName = settings.containerId + '_callback';
		
		window[callbackName] = function(e) {
			mejs.YouTubeApi.handleStateChange(e, player, pluginMediaElement);
		}
		
		player.addEventListener('onStateChange', callbackName);
		
		setInterval(function() {
			mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'timeupdate');
		}, 250);
		
		mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'canplay');
	},
	
	handleStateChange: function(youTubeState, player, pluginMediaElement) {
		switch (youTubeState) {
			case -1: // not started
				pluginMediaElement.paused = true;
				pluginMediaElement.ended = true;
				mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'loadedmetadata');
				//createYouTubeEvent(player, pluginMediaElement, 'loadeddata');
				break;
			case 0:
				pluginMediaElement.paused = false;
				pluginMediaElement.ended = true;
				mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'ended');
				break;
			case 1:
				pluginMediaElement.paused = false;
				pluginMediaElement.ended = false;				
				mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'play');
				mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'playing');
				break;
			case 2:
				pluginMediaElement.paused = true;
				pluginMediaElement.ended = false;				
				mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'pause');
				break;
			case 3: // buffering
				mejs.YouTubeApi.createEvent(player, pluginMediaElement, 'progress');
				break;
			case 5:
				// cued?
				break;						
			
		}			
		
	}
}
// IFRAME
window.onYouTubePlayerAPIReady = function() {
	mejs.YouTubeApi.iFrameReady();
};
// FLASH
window.onYouTubePlayerReady = function(id) {
	mejs.YouTubeApi.flashReady(id);
};

window.mejs = mejs;
window.MediaElement = mejs.MediaElement;

/*
 * Adds Internationalization and localization to mediaelement.
 *
 * This file does not contain translations, you have to add them manually.
 * The schema is always the same: me-i18n-locale-[IETF-language-tag].js
 *
 * Examples are provided both for german and chinese translation.
 *
 *
 * What is the concept beyond i18n?
 *   http://en.wikipedia.org/wiki/Internationalization_and_localization
 *
 * What langcode should i use?
 *   http://en.wikipedia.org/wiki/IETF_language_tag
 *   https://tools.ietf.org/html/rfc5646
 *
 *
 * License?
 *
 *   The i18n file uses methods from the Drupal project (drupal.js):
 *     - i18n.methods.t() (modified)
 *     - i18n.methods.checkPlain() (full copy)
 *
 *   The Drupal project is (like mediaelementjs) licensed under GPLv2.
 *    - http://drupal.org/licensing/faq/#q1
 *    - https://github.com/johndyer/mediaelement
 *    - http://www.gnu.org/licenses/old-licenses/gpl-2.0.html
 *
 *
 * @author
 *   Tim Latz (latz.tim@gmail.com)
 *
 *
 * @params
 *  - context - document, iframe ..
 *  - exports - CommonJS, window ..
 *
 */
;(function(context, exports, undefined) {
    "use strict";

    var i18n = {
        "locale": {
            // Ensure previous values aren't overwritten.
            "language" : (exports.i18n && exports.i18n.locale.language) || '',
            "strings" : (exports.i18n && exports.i18n.locale.strings) || {}
        },
        "ietf_lang_regex" : /^(x\-)?[a-z]{2,}(\-\w{2,})?(\-\w{2,})?$/,
        "methods" : {}
    };
// start i18n


    /**
     * Get language, fallback to browser's language if empty
     *
     * IETF: RFC 5646, https://tools.ietf.org/html/rfc5646
     * Examples: en, zh-CN, cmn-Hans-CN, sr-Latn-RS, es-419, x-private
     */
    i18n.getLanguage = function () {
        var language = i18n.locale.language || window.navigator.userLanguage || window.navigator.language;
        return i18n.ietf_lang_regex.exec(language) ? language : null;

        //(WAS: convert to iso 639-1 (2-letters, lower case))
        //return language.substr(0, 2).toLowerCase();
    };

    // i18n fixes for compatibility with WordPress
    if ( typeof mejsL10n != 'undefined' ) {
        i18n.locale.language = mejsL10n.language;
    }



    /**
     * Encode special characters in a plain-text string for display as HTML.
     */
    i18n.methods.checkPlain = function (str) {
        var character, regex,
        replace = {
            '&': '&amp;',
            '"': '&quot;',
            '<': '&lt;',
            '>': '&gt;'
        };
        str = String(str);
        for (character in replace) {
            if (replace.hasOwnProperty(character)) {
                regex = new RegExp(character, 'g');
                str = str.replace(regex, replace[character]);
            }
        }
        return str;
    };

    /**
     * Translate strings to the page language or a given language.
     *
     *
     * @param str
     *   A string containing the English string to translate.
     *
     * @param options
     *   - 'context' (defaults to the default context): The context the source string
     *     belongs to.
     *
     * @return
     *   The translated string, escaped via i18n.methods.checkPlain()
     */
    i18n.methods.t = function (str, options) {

        // Fetch the localized version of the string.
        if (i18n.locale.strings && i18n.locale.strings[options.context] && i18n.locale.strings[options.context][str]) {
            str = i18n.locale.strings[options.context][str];
        }

        return i18n.methods.checkPlain(str);
    };


    /**
     * Wrapper for i18n.methods.t()
     *
     * @see i18n.methods.t()
     * @throws InvalidArgumentException
     */
    i18n.t = function(str, options) {

        if (typeof str === 'string' && str.length > 0) {

            // check every time due language can change for
            // different reasons (translation, lang switcher ..)
            var language = i18n.getLanguage();

            options = options || {
                "context" : language
            };

            return i18n.methods.t(str, options);
        }
        else {
            throw {
                "name" : 'InvalidArgumentException',
                "message" : 'First argument is either not a string or empty.'
            };
        }
    };

// end i18n
    exports.i18n = i18n;
}(document, mejs));

// i18n fixes for compatibility with WordPress
;(function(exports, undefined) {

    "use strict";

    if ( typeof mejsL10n != 'undefined' ) {
        exports[mejsL10n.language] = mejsL10n.strings;
    }

}(mejs.i18n.locale.strings));

/*!
 *
 * MediaElementPlayer
 * http://mediaelementjs.com/
 *
 * Creates a controller bar for HTML5 <video> add <audio> tags
 * using jQuery and MediaElement.js (HTML5 Flash/Silverlight wrapper)
 *
 * Copyright 2010-2013, John Dyer (http://j.hn/)
 * License: MIT
 *
 */
if (typeof jQuery != 'undefined') {
	mejs.$ = jQuery;
} else if (typeof Zepto != 'undefined') {
	mejs.$ = Zepto;

	// define `outerWidth` method which has not been realized in Zepto
	Zepto.fn.outerWidth = function(includeMargin) {
		var width = $(this).width();
		if (includeMargin) {
			width += parseInt($(this).css('margin-right'), 10);
			width += parseInt($(this).css('margin-left'), 10);
		}
		return width
	}

} else if (typeof ender != 'undefined') {
	mejs.$ = ender;
}
(function ($) {

	// default player values
	mejs.MepDefaults = {
		// url to poster (to fix iOS 3.x)
		poster: '',
		// When the video is ended, we can show the poster.
		showPosterWhenEnded: false,
		// default if the <video width> is not specified
		defaultVideoWidth: 480,
		// default if the <video height> is not specified
		defaultVideoHeight: 270,
		// if set, overrides <video width>
		videoWidth: -1,
		// if set, overrides <video height>
		videoHeight: -1,
		// default if the user doesn't specify
		defaultAudioWidth: 400,
		// default if the user doesn't specify
		defaultAudioHeight: 30,

		// default amount to move back when back key is pressed
		defaultSeekBackwardInterval: function(media) {
			return (media.duration * 0.05);
		},
		// default amount to move forward when forward key is pressed
		defaultSeekForwardInterval: function(media) {
			return (media.duration * 0.05);
		},

		// set dimensions via JS instead of CSS
		setDimensions: true,

		// width of audio player
		audioWidth: -1,
		// height of audio player
		audioHeight: -1,
		// initial volume when the player starts (overrided by user cookie)
		startVolume: 0.8,
		// useful for <audio> player loops
		loop: false,
		// rewind to beginning when media ends
                autoRewind: true,
		// resize to media dimensions
		enableAutosize: true,

		/*
		 * Time format to use. Default: 'mm:ss'
		 * Supported units:
		 *   h: hour
		 *   m: minute
		 *   s: second
		 *   f: frame count
		 * When using 'hh', 'mm', 'ss' or 'ff' we always display 2 digits.
		 * If you use 'h', 'm', 's' or 'f' we display 1 digit if possible.
		 *
		 * Example to display 75 seconds:
		 * Format 'mm:ss': 01:15
		 * Format 'm:ss': 1:15
		 * Format 'm:s': 1:15
		 */
		timeFormat: '',
		// forces the hour marker (##:00:00)
		alwaysShowHours: false,
		// show framecount in timecode (##:00:00:00)
		showTimecodeFrameCount: false,
		// used when showTimecodeFrameCount is set to true
		framesPerSecond: 25,

		// automatically calculate the width of the progress bar based on the sizes of other elements
		autosizeProgress : true,
		// Hide controls when playing and mouse is not over the video
		alwaysShowControls: false,
		// Display the video control
		hideVideoControlsOnLoad: false,
		// Enable click video element to toggle play/pause
		clickToPlayPause: true,
		// force iPad's native controls
		iPadUseNativeControls: false,
		// force iPhone's native controls
		iPhoneUseNativeControls: false,
		// force Android's native controls
		AndroidUseNativeControls: false,
		// features to show
		features: ['playpause','current','progress','duration','tracks','volume','fullscreen'],
		// only for dynamic
		isVideo: true,

		// turns keyboard support on and off for this instance
		enableKeyboard: true,

		// whenthis player starts, it will pause other players
		pauseOtherPlayers: true,

		// array of keyboard actions such as play pause
		keyActions: [
				{
						keys: [
								32, // SPACE
								179 // GOOGLE play/pause button
							  ],
						action: function(player, media) {
								if (media.paused || media.ended) {
										media.play();
								} else {
										media.pause();
								}
						}
				},
				{
						keys: [38], // UP
						action: function(player, media) {
								player.container.find('.mejs-volume-slider').css('display','block');
								if (player.isVideo) {
										player.showControls();
										player.startControlsTimer();
								}

								var newVolume = Math.min(media.volume + 0.1, 1);
								media.setVolume(newVolume);
						}
				},
				{
						keys: [40], // DOWN
						action: function(player, media) {
								player.container.find('.mejs-volume-slider').css('display','block');
								if (player.isVideo) {
										player.showControls();
										player.startControlsTimer();
								}

								var newVolume = Math.max(media.volume - 0.1, 0);
								media.setVolume(newVolume);
						}
				},
				{
						keys: [
								37, // LEFT
								227 // Google TV rewind
						],
						action: function(player, media) {
								if (!isNaN(media.duration) && media.duration > 0) {
										if (player.isVideo) {
												player.showControls();
												player.startControlsTimer();
										}

										// 5%
										var newTime = Math.max(media.currentTime - player.options.defaultSeekBackwardInterval(media), 0);
										media.setCurrentTime(newTime);
								}
						}
				},
				{
						keys: [
								39, // RIGHT
								228 // Google TV forward
						],
						action: function(player, media) {
								if (!isNaN(media.duration) && media.duration > 0) {
										if (player.isVideo) {
												player.showControls();
												player.startControlsTimer();
										}

										// 5%
										var newTime = Math.min(media.currentTime + player.options.defaultSeekForwardInterval(media), media.duration);
										media.setCurrentTime(newTime);
								}
						}
				},
				{
						keys: [70], // F
						action: function(player, media) {
								if (typeof player.enterFullScreen != 'undefined') {
										if (player.isFullScreen) {
												player.exitFullScreen();
										} else {
												player.enterFullScreen();
										}
								}
						}
				},
				{
						keys: [77], // M
						action: function(player, media) {
								player.container.find('.mejs-volume-slider').css('display','block');
								if (player.isVideo) {
										player.showControls();
										player.startControlsTimer();
								}
								if (player.media.muted) {
										player.setMuted(false);
								} else {
										player.setMuted(true);
								}
						}
				}
		]
	};

	mejs.mepIndex = 0;

	mejs.players = {};

	// wraps a MediaElement object in player controls
	mejs.MediaElementPlayer = function(node, o) {
		// enforce object, even without "new" (via John Resig)
		if ( !(this instanceof mejs.MediaElementPlayer) ) {
			return new mejs.MediaElementPlayer(node, o);
		}

		var t = this;

		// these will be reset after the MediaElement.success fires
		t.$media = t.$node = $(node);
		t.node = t.media = t.$media[0];

		if(!t.node) {
			return
		}

		// check for existing player
		if (typeof t.node.player != 'undefined') {
			return t.node.player;
		}


		// try to get options from data-mejsoptions
		if (typeof o == 'undefined') {
			o = t.$node.data('mejsoptions');
		}

		// extend default options
		t.options = $.extend({},mejs.MepDefaults,o);

		if (!t.options.timeFormat) {
			// Generate the time format according to options
			t.options.timeFormat = 'mm:ss';
			if (t.options.alwaysShowHours) {
				t.options.timeFormat = 'hh:mm:ss';
			}
			if (t.options.showTimecodeFrameCount) {
				t.options.timeFormat += ':ff';
			}
		}

		mejs.Utility.calculateTimeFormat(0, t.options, t.options.framesPerSecond || 25);

		// unique ID
		t.id = 'mep_' + mejs.mepIndex++;

		// add to player array (for focus events)
		mejs.players[t.id] = t;

		// start up
		t.init();

		return t;
	};

	// actual player
	mejs.MediaElementPlayer.prototype = {

		hasFocus: false,

		controlsAreVisible: true,

		init: function() {

			var
				t = this,
				mf = mejs.MediaFeatures,
				// options for MediaElement (shim)
				meOptions = $.extend(true, {}, t.options, {
					success: function(media, domNode) { t.meReady(media, domNode); },
					error: function(e) { t.handleError(e);}
				}),
				tagName = t.media.tagName.toLowerCase();

			t.isDynamic = (tagName !== 'audio' && tagName !== 'video');

			if (t.isDynamic) {
				// get video from src or href?
				t.isVideo = t.options.isVideo;
			} else {
				t.isVideo = (tagName !== 'audio' && t.options.isVideo);
			}

			// use native controls in iPad, iPhone, and Android
			if ((mf.isiPad && t.options.iPadUseNativeControls) || (mf.isiPhone && t.options.iPhoneUseNativeControls)) {

				// add controls and stop
				t.$media.attr('controls', 'controls');

				// attempt to fix iOS 3 bug
				//t.$media.removeAttr('poster');
                                // no Issue found on iOS3 -ttroxell

				// override Apple's autoplay override for iPads
				if (mf.isiPad && t.media.getAttribute('autoplay') !== null) {
					t.play();
				}

			} else if (mf.isAndroid && t.options.AndroidUseNativeControls) {

				// leave default player

			} else {

				// DESKTOP: use MediaElementPlayer controls

				// remove native controls
				t.$media.removeAttr('controls');
				var videoPlayerTitle = t.isVideo ?
					mejs.i18n.t('Video Player') : mejs.i18n.t('Audio Player');
				// insert description for screen readers
				$('<span class="mejs-offscreen">' + videoPlayerTitle + '</span>').insertBefore(t.$media);
				// build container
				t.container =
					$('<div id="' + t.id + '" class="mejs-container ' + (mejs.MediaFeatures.svgAsImg ? 'svg' : 'no-svg') +
					  '" tabindex="0" role="application" aria-label="' + videoPlayerTitle + '">'+
						'<div class="mejs-inner">'+
							'<div class="mejs-mediaelement"></div>'+
							'<div class="mejs-layers"></div>'+
							'<div class="mejs-controls"></div>'+
							'<div class="mejs-clear"></div>'+
						'</div>' +
					'</div>')
					.addClass(t.$media[0].className)
					.insertBefore(t.$media)
					.focus(function ( e ) {
						if( !t.controlsAreVisible ) {
							t.showControls(true);
							var playButton = t.container.find('.mejs-playpause-button > button');
							playButton.focus();
						}
					});

				// add classes for user and content
				t.container.addClass(
					(mf.isAndroid ? 'mejs-android ' : '') +
					(mf.isiOS ? 'mejs-ios ' : '') +
					(mf.isiPad ? 'mejs-ipad ' : '') +
					(mf.isiPhone ? 'mejs-iphone ' : '') +
					(t.isVideo ? 'mejs-video ' : 'mejs-audio ')
				);


				// move the <video/video> tag into the right spot
				t.container.find('.mejs-mediaelement').append(t.$media);

				// needs to be assigned here, after iOS remap
				t.node.player = t;

				// find parts
				t.controls = t.container.find('.mejs-controls');
				t.layers = t.container.find('.mejs-layers');

				// determine the size

				/* size priority:
					(1) videoWidth (forced),
					(2) style="width;height;"
					(3) width attribute,
					(4) defaultVideoWidth (for unspecified cases)
				*/

				var tagType = (t.isVideo ? 'video' : 'audio'),
					capsTagName = tagType.substring(0,1).toUpperCase() + tagType.substring(1);



				if (t.options[tagType + 'Width'] > 0 || t.options[tagType + 'Width'].toString().indexOf('%') > -1) {
					t.width = t.options[tagType + 'Width'];
				} else if (t.media.style.width !== '' && t.media.style.width !== null) {
					t.width = t.media.style.width;
				} else if (t.media.getAttribute('width') !== null) {
					t.width = t.$media.attr('width');
				} else {
					t.width = t.options['default' + capsTagName + 'Width'];
				}

				if (t.options[tagType + 'Height'] > 0 || t.options[tagType + 'Height'].toString().indexOf('%') > -1) {
					t.height = t.options[tagType + 'Height'];
				} else if (t.media.style.height !== '' && t.media.style.height !== null) {
					t.height = t.media.style.height;
				} else if (t.$media[0].getAttribute('height') !== null) {
					t.height = t.$media.attr('height');
				} else {
					t.height = t.options['default' + capsTagName + 'Height'];
				}

				// set the size, while we wait for the plugins to load below
				t.setPlayerSize(t.width, t.height);

				// create MediaElementShim
				meOptions.pluginWidth = t.width;
				meOptions.pluginHeight = t.height;
			}

			// create MediaElement shim
			mejs.MediaElement(t.$media[0], meOptions);

			if (typeof(t.container) != 'undefined' && t.controlsAreVisible){
				// controls are shown when loaded
				t.container.trigger('controlsshown');
			}
		},

		showControls: function(doAnimation) {
			var t = this;

			doAnimation = typeof doAnimation == 'undefined' || doAnimation;

			if (t.controlsAreVisible)
				return;

			if (doAnimation) {
				t.controls
					.removeClass('mejs-offscreen')
					.stop(true, true).fadeIn(200, function() {
						t.controlsAreVisible = true;
						t.container.trigger('controlsshown');
					});

				// any additional controls people might add and want to hide
				t.container.find('.mejs-control')
					.removeClass('mejs-offscreen')
					.stop(true, true).fadeIn(200, function() {t.controlsAreVisible = true;});

			} else {
				t.controls
					.removeClass('mejs-offscreen')
					.css('display','block');

				// any additional controls people might add and want to hide
				t.container.find('.mejs-control')
					.removeClass('mejs-offscreen')
					.css('display','block');

				t.controlsAreVisible = true;
				t.container.trigger('controlsshown');
			}

			t.setControlsSize();

		},

		hideControls: function(doAnimation) {
			var t = this;

			doAnimation = typeof doAnimation == 'undefined' || doAnimation;

			if (!t.controlsAreVisible || t.options.alwaysShowControls || t.keyboardAction)
				return;

			if (doAnimation) {
				// fade out main controls
				t.controls.stop(true, true).fadeOut(200, function() {
					$(this)
						.addClass('mejs-offscreen')
						.css('display','block');

					t.controlsAreVisible = false;
					t.container.trigger('controlshidden');
				});

				// any additional controls people might add and want to hide
				t.container.find('.mejs-control').stop(true, true).fadeOut(200, function() {
					$(this)
						.addClass('mejs-offscreen')
						.css('display','block');
				});
			} else {

				// hide main controls
				t.controls
					.addClass('mejs-offscreen')
					.css('display','block');

				// hide others
				t.container.find('.mejs-control')
					.addClass('mejs-offscreen')
					.css('display','block');

				t.controlsAreVisible = false;
				t.container.trigger('controlshidden');
			}
		},

		controlsTimer: null,

		startControlsTimer: function(timeout) {

			var t = this;

			timeout = typeof timeout != 'undefined' ? timeout : 1500;

			t.killControlsTimer('start');

			t.controlsTimer = setTimeout(function() {
				//
				t.hideControls();
				t.killControlsTimer('hide');
			}, timeout);
		},

		killControlsTimer: function(src) {

			var t = this;

			if (t.controlsTimer !== null) {
				clearTimeout(t.controlsTimer);
				delete t.controlsTimer;
				t.controlsTimer = null;
			}
		},

		controlsEnabled: true,

		disableControls: function() {
			var t= this;

			t.killControlsTimer();
			t.hideControls(false);
			this.controlsEnabled = false;
		},

		enableControls: function() {
			var t= this;

			t.showControls(false);

			t.controlsEnabled = true;
		},


		// Sets up all controls and events
		meReady: function(media, domNode) {


			var t = this,
				mf = mejs.MediaFeatures,
				autoplayAttr = domNode.getAttribute('autoplay'),
				autoplay = !(typeof autoplayAttr == 'undefined' || autoplayAttr === null || autoplayAttr === 'false'),
				featureIndex,
				feature;

			// make sure it can't create itself again if a plugin reloads
			if (t.created) {
				return;
			} else {
				t.created = true;
			}

			t.media = media;
			t.domNode = domNode;

			if (!(mf.isAndroid && t.options.AndroidUseNativeControls) && !(mf.isiPad && t.options.iPadUseNativeControls) && !(mf.isiPhone && t.options.iPhoneUseNativeControls)) {

				// two built in features
				t.buildposter(t, t.controls, t.layers, t.media);
				t.buildkeyboard(t, t.controls, t.layers, t.media);
				t.buildoverlays(t, t.controls, t.layers, t.media);

				// grab for use by features
				t.findTracks();

				// add user-defined features/controls
				for (featureIndex in t.options.features) {
					feature = t.options.features[featureIndex];
					if (t['build' + feature]) {
						try {
							t['build' + feature](t, t.controls, t.layers, t.media);
						} catch (e) {
							// TODO: report control error
							//throw e;
							
							
						}
					}
				}

				t.container.trigger('controlsready');

				// reset all layers and controls
				t.setPlayerSize(t.width, t.height);
				t.setControlsSize();


				// controls fade
				if (t.isVideo) {

					if (mejs.MediaFeatures.hasTouch) {

						// for touch devices (iOS, Android)
						// show/hide without animation on touch

						t.$media.bind('touchstart', function() {


							// toggle controls
							if (t.controlsAreVisible) {
								t.hideControls(false);
							} else {
								if (t.controlsEnabled) {
									t.showControls(false);
								}
							}
						});

					} else {

						// create callback here since it needs access to current
						// MediaElement object
						t.clickToPlayPauseCallback = function() {
							//

							if (t.options.clickToPlayPause) {
								if (t.media.paused) {
									t.play();
								} else {
									t.pause();
								}
							}
						};

						// click to play/pause
						t.media.addEventListener('click', t.clickToPlayPauseCallback, false);

						// show/hide controls
						t.container
							.bind('mouseenter', function () {
								if (t.controlsEnabled) {
									if (!t.options.alwaysShowControls ) {
										t.killControlsTimer('enter');
										t.showControls();
										t.startControlsTimer(2500);
									}
								}
							})
							.bind('mousemove', function() {
								if (t.controlsEnabled) {
									if (!t.controlsAreVisible) {
										t.showControls();
									}
									if (!t.options.alwaysShowControls) {
										t.startControlsTimer(2500);
									}
								}
							})
							.bind('mouseleave', function () {
								if (t.controlsEnabled) {
									if (!t.media.paused && !t.options.alwaysShowControls) {
										t.startControlsTimer(1000);
									}
								}
							});
					}

					if(t.options.hideVideoControlsOnLoad) {
						t.hideControls(false);
					}

					// check for autoplay
					if (autoplay && !t.options.alwaysShowControls) {
						t.hideControls();
					}

					// resizer
					if (t.options.enableAutosize) {
						t.media.addEventListener('loadedmetadata', function(e) {
							// if the <video height> was not set and the options.videoHeight was not set
							// then resize to the real dimensions
							if (t.options.videoHeight <= 0 && t.domNode.getAttribute('height') === null && !isNaN(e.target.videoHeight)) {
								t.setPlayerSize(e.target.videoWidth, e.target.videoHeight);
								t.setControlsSize();
								t.media.setVideoSize(e.target.videoWidth, e.target.videoHeight);
							}
						}, false);
					}
				}

				// EVENTS

				// FOCUS: when a video starts playing, it takes focus from other players (possibily pausing them)
				media.addEventListener('play', function() {
					var playerIndex;

					// go through all other players
					for (playerIndex in mejs.players) {
						var p = mejs.players[playerIndex];
						if (p.id != t.id && t.options.pauseOtherPlayers && !p.paused && !p.ended) {
							p.pause();
						}
						p.hasFocus = false;
					}

					t.hasFocus = true;
				},false);


				// ended for all
				t.media.addEventListener('ended', function (e) {
					if(t.options.autoRewind) {
						try{
							t.media.setCurrentTime(0);
                            // Fixing an Android stock browser bug, where "seeked" isn't fired correctly after ending the video and jumping to the beginning
                            window.setTimeout(function(){
                                $(t.container).find('.mejs-overlay-loading').parent().hide();
                            }, 20);
						} catch (exp) {

						}
					}
					t.media.pause();

					if (t.setProgressRail) {
						t.setProgressRail();
					}
					if (t.setCurrentRail) {
						t.setCurrentRail();
					}

					if (t.options.loop) {
						t.play();
					} else if (!t.options.alwaysShowControls && t.controlsEnabled) {
						t.showControls();
					}
				}, false);

				// resize on the first play
				t.media.addEventListener('loadedmetadata', function(e) {
					if (t.updateDuration) {
						t.updateDuration();
					}
					if (t.updateCurrent) {
						t.updateCurrent();
					}

					if (!t.isFullScreen) {
						t.setPlayerSize(t.width, t.height);
						t.setControlsSize();
					}
				}, false);

				// Only change the time format when necessary
				var duration = null;
				t.media.addEventListener('timeupdate',function() {
					if (duration !== this.duration) {
						duration = this.duration;
						mejs.Utility.calculateTimeFormat(duration, t.options, t.options.framesPerSecond || 25);
						
						// make sure to fill in and resize the controls (e.g., 00:00 => 01:13:15
						if (t.updateDuration) {
							t.updateDuration();
						}
						if (t.updateCurrent) {
							t.updateCurrent();
						}
						t.setControlsSize();
						
					}
				}, false);

				t.container.focusout(function (e) {
					if( e.relatedTarget ) { //FF is working on supporting focusout https://bugzilla.mozilla.org/show_bug.cgi?id=687787
						var $target = $(e.relatedTarget);
						if (t.keyboardAction && $target.parents('.mejs-container').length === 0) {
							t.keyboardAction = false;
							t.hideControls(true);
						}
					}
				});

				// webkit has trouble doing this without a delay
				setTimeout(function () {
					t.setPlayerSize(t.width, t.height);
					t.setControlsSize();
				}, 50);

				// adjust controls whenever window sizes (used to be in fullscreen only)
				t.globalBind('resize', function() {

					// don't resize for fullscreen mode
					if ( !(t.isFullScreen || (mejs.MediaFeatures.hasTrueNativeFullScreen && document.webkitIsFullScreen)) ) {
						t.setPlayerSize(t.width, t.height);
					}

					// always adjust controls
					t.setControlsSize();
				});

				// This is a work-around for a bug in the YouTube iFrame player, which means
				//  we can't use the play() API for the initial playback on iOS or Android;
				//  user has to start playback directly by tapping on the iFrame.
				if (t.media.pluginType == 'youtube' && ( mf.isiOS || mf.isAndroid ) ) {
					t.container.find('.mejs-overlay-play').hide();
                    t.container.find('.mejs-poster').hide();
				}
			}

			// force autoplay for HTML5
			if (autoplay && media.pluginType == 'native') {
				t.play();
			}


			if (t.options.success) {

				if (typeof t.options.success == 'string') {
					window[t.options.success](t.media, t.domNode, t);
				} else {
					t.options.success(t.media, t.domNode, t);
				}
			}
		},

		handleError: function(e) {
			var t = this;

			if (t.controls) {
				t.controls.hide();
			}

			// Tell user that the file cannot be played
			if (t.options.error) {
				t.options.error(e);
			}
		},

		setPlayerSize: function(width,height) {
			var t = this;

			if( !t.options.setDimensions ) {
				return false;
			}

			if (typeof width != 'undefined') {
				t.width = width;
			}

			if (typeof height != 'undefined') {
				t.height = height;
			}

			// detect 100% mode - use currentStyle for IE since css() doesn't return percentages
			if (t.height.toString().indexOf('%') > 0 || (t.$node.css('max-width') !== 'none' && t.$node.css('max-width') !== 't.width') || (t.$node[0].currentStyle && t.$node[0].currentStyle.maxWidth === '100%')) {

				// do we have the native dimensions yet?
				var nativeWidth = (function() {
					if (t.isVideo) {
						if (t.media.videoWidth && t.media.videoWidth > 0) {
							return t.media.videoWidth;
						} else if (t.media.getAttribute('width') !== null) {
							return t.media.getAttribute('width');
						} else {
							return t.options.defaultVideoWidth;
						}
					} else {
						return t.options.defaultAudioWidth;
					}
				})();

				var nativeHeight = (function() {
					if (t.isVideo) {
						if (t.media.videoHeight && t.media.videoHeight > 0) {
							return t.media.videoHeight;
						} else if (t.media.getAttribute('height') !== null) {
							return t.media.getAttribute('height');
						} else {
							return t.options.defaultVideoHeight;
						}
					} else {
						return t.options.defaultAudioHeight;
					}
				})();

				var
					parentWidth = t.container.parent().closest(':visible').width(),
					parentHeight = t.container.parent().closest(':visible').height(),
					newHeight = t.isVideo || !t.options.autosizeProgress ? parseInt(parentWidth * nativeHeight/nativeWidth, 10) : nativeHeight;

				// When we use percent, the newHeight can't be calculated so we get the container height
				if (isNaN(newHeight)) {
					newHeight = parentHeight;
				}

				if (t.container.parent().length > 0 && t.container.parent()[0].tagName.toLowerCase() === 'body') { // && t.container.siblings().count == 0) {
					parentWidth = $(window).width();
					newHeight = $(window).height();
				}

				if ( newHeight && parentWidth ) {

					// set outer container size
					t.container
						.width(parentWidth)
						.height(newHeight);

					// set native <video> or <audio> and shims
					t.$media.add(t.container.find('.mejs-shim'))
						.width('100%')
						.height('100%');

					// if shim is ready, send the size to the embeded plugin
					if (t.isVideo) {
						if (t.media.setVideoSize) {
							t.media.setVideoSize(parentWidth, newHeight);
						}
					}

					// set the layers
					t.layers.children('.mejs-layer')
						.width('100%')
						.height('100%');
				}


			} else {

				t.container
					.width(t.width)
					.height(t.height);

				t.layers.children('.mejs-layer')
					.width(t.width)
					.height(t.height);

			}

		},

		setControlsSize: function() {
			var t = this,
				usedWidth = 0,
				railWidth = 0,
				rail = t.controls.find('.mejs-time-rail'),
				total = t.controls.find('.mejs-time-total'),
				others = rail.siblings(),
				lastControl = others.last(),
				lastControlPosition = null;

			// skip calculation if hidden
			if (!t.container.is(':visible') || !rail.length || !rail.is(':visible')) {
				return;
			}


			// allow the size to come from custom CSS
			if (t.options && !t.options.autosizeProgress) {
				// Also, frontends devs can be more flexible
				// due the opportunity of absolute positioning.
				railWidth = parseInt(rail.css('width'), 10);
			}

			// attempt to autosize
			if (railWidth === 0 || !railWidth) {

				// find the size of all the other controls besides the rail
				others.each(function() {
					var $this = $(this);
					if ($this.css('position') != 'absolute' && $this.is(':visible')) {
						usedWidth += $(this).outerWidth(true);
					}
				});

				// fit the rail into the remaining space
				railWidth = t.controls.width() - usedWidth - (rail.outerWidth(true) - rail.width());
			}

			// resize the rail,
			// but then check if the last control (say, the fullscreen button) got pushed down
			// this often happens when zoomed
			do {
				// outer area
				rail.width(railWidth);
				// dark space
				total.width(railWidth - (total.outerWidth(true) - total.width()));

				if (lastControl.css('position') != 'absolute') {
					lastControlPosition = lastControl.length ? lastControl.position() : null;
					railWidth--;
				}
			} while (lastControlPosition !== null && lastControlPosition.top.toFixed(2) > 0 && railWidth > 0);

			t.container.trigger('controlsresize');
		},


		buildposter: function(player, controls, layers, media) {
			var t = this,
				poster =
				$('<div class="mejs-poster mejs-layer">' +
				'</div>')
					.appendTo(layers),
				posterUrl = player.$media.attr('poster');

			// prioriy goes to option (this is useful if you need to support iOS 3.x (iOS completely fails with poster)
			if (player.options.poster !== '') {
				posterUrl = player.options.poster;
			}

			// second, try the real poster
			if ( posterUrl ) {
				t.setPoster(posterUrl);
			} else {
				poster.hide();
			}

			media.addEventListener('play',function() {
				poster.hide();
			}, false);

			if(player.options.showPosterWhenEnded && player.options.autoRewind){
				media.addEventListener('ended',function() {
					poster.show();
				}, false);
			}
		},

		setPoster: function(url) {
			var t = this,
				posterDiv = t.container.find('.mejs-poster'),
				posterImg = posterDiv.find('img');

			if (posterImg.length === 0) {
				posterImg = $('<img width="100%" height="100%" alt="" />').appendTo(posterDiv);
			}

			posterImg.attr('src', url);
			posterDiv.css({'background-image' : 'url(' + url + ')'});
		},

		buildoverlays: function(player, controls, layers, media) {
            var t = this;
			if (!player.isVideo)
				return;

			var
			loading =
				$('<div class="mejs-overlay mejs-layer">'+
					'<div class="mejs-overlay-loading"><span></span></div>'+
				'</div>')
				.hide() // start out hidden
				.appendTo(layers),
			error =
				$('<div class="mejs-overlay mejs-layer">'+
					'<div class="mejs-overlay-error"></div>'+
				'</div>')
				.hide() // start out hidden
				.appendTo(layers),
			// this needs to come last so it's on top
			bigPlay =
				$('<div class="mejs-overlay mejs-layer mejs-overlay-play">'+
					'<div class="mejs-overlay-button"></div>'+
				'</div>')
				.appendTo(layers)
				.bind('click', function() {  // Removed 'touchstart' due issues on Samsung Android devices where a tap on bigPlay started and immediately stopped the video
					if (t.options.clickToPlayPause) {
						if (media.paused) {
							media.play();
						}
					}
				});

			/*
			if (mejs.MediaFeatures.isiOS || mejs.MediaFeatures.isAndroid) {
				bigPlay.remove();
				loading.remove();
			}
			*/


			// show/hide big play button
			media.addEventListener('play',function() {
				bigPlay.hide();
				loading.hide();
				controls.find('.mejs-time-buffering').hide();
				error.hide();
			}, false);

			media.addEventListener('playing', function() {
				bigPlay.hide();
				loading.hide();
				controls.find('.mejs-time-buffering').hide();
				error.hide();
			}, false);

			media.addEventListener('seeking', function() {
				loading.show();
				controls.find('.mejs-time-buffering').show();
			}, false);

			media.addEventListener('seeked', function() {
				loading.hide();
				controls.find('.mejs-time-buffering').hide();
			}, false);

			media.addEventListener('pause',function() {
				if (!mejs.MediaFeatures.isiPhone) {
					bigPlay.show();
				}
			}, false);

			media.addEventListener('waiting', function() {
				loading.show();
				controls.find('.mejs-time-buffering').show();
			}, false);


			// show/hide loading
			media.addEventListener('loadeddata',function() {
				// for some reason Chrome is firing this event
				//if (mejs.MediaFeatures.isChrome && media.getAttribute && media.getAttribute('preload') === 'none')
				//	return;

				loading.show();
				controls.find('.mejs-time-buffering').show();
                // Firing the 'canplay' event after a timeout which isn't getting fired on some Android 4.1 devices (https://github.com/johndyer/mediaelement/issues/1305)
                if (mejs.MediaFeatures.isAndroid) {
                    media.canplayTimeout = window.setTimeout(
                        function() {
                            if (document.createEvent) {
                                var evt = document.createEvent('HTMLEvents');
                                evt.initEvent('canplay', true, true);
                                return media.dispatchEvent(evt);
                            }
                        }, 300
                    );
                }
			}, false);
			media.addEventListener('canplay',function() {
				loading.hide();
				controls.find('.mejs-time-buffering').hide();
                clearTimeout(media.canplayTimeout); // Clear timeout inside 'loadeddata' to prevent 'canplay' to fire twice
			}, false);

			// error handling
			media.addEventListener('error',function(e) {
				t.handleError(e);
				loading.hide();
				bigPlay.hide();
				error.show();
				error.find('.mejs-overlay-error').html("Error loading this resource");
			}, false);

			media.addEventListener('keydown', function(e) {
				t.onkeydown(player, media, e);
			}, false);
		},

		buildkeyboard: function(player, controls, layers, media) {

				var t = this;

				t.container.keydown(function () {
					t.keyboardAction = true;
				});

				// listen for key presses
				t.globalBind('keydown', function(event) {
					player.hasFocus = $(event.target).closest('.mejs-container').length !== 0
						&& $(event.target).closest('.mejs-container').attr('id') === player.$media.closest('.mejs-container').attr('id');
					return t.onkeydown(player, media, event);
				});


				// check if someone clicked outside a player region, then kill its focus
				t.globalBind('click', function(event) {
					player.hasFocus = $(event.target).closest('.mejs-container').length !== 0;
				});

		},
		onkeydown: function(player, media, e) {
			if (player.hasFocus && player.options.enableKeyboard) {
				// find a matching key
				for (var i = 0, il = player.options.keyActions.length; i < il; i++) {
					var keyAction = player.options.keyActions[i];

					for (var j = 0, jl = keyAction.keys.length; j < jl; j++) {
						if (e.keyCode == keyAction.keys[j]) {
							if (typeof(e.preventDefault) == "function") e.preventDefault();
							keyAction.action(player, media, e.keyCode, e);
							return false;
						}
					}
				}
			}

			return true;
		},

		findTracks: function() {
			var t = this,
				tracktags = t.$media.find('track');

			// store for use by plugins
			t.tracks = [];
			tracktags.each(function(index, track) {

				track = $(track);

				t.tracks.push({
					srclang: (track.attr('srclang')) ? track.attr('srclang').toLowerCase() : '',
					src: track.attr('src'),
					kind: track.attr('kind'),
					label: track.attr('label') || '',
					entries: [],
					isLoaded: false
				});
			});
		},
		changeSkin: function(className) {
			this.container[0].className = 'mejs-container ' + className;
			this.setPlayerSize(this.width, this.height);
			this.setControlsSize();
		},
		play: function() {
			this.load();
			this.media.play();
		},
		pause: function() {
			try {
				this.media.pause();
			} catch (e) {}
		},
		load: function() {
			if (!this.isLoaded) {
				this.media.load();
			}

			this.isLoaded = true;
		},
		setMuted: function(muted) {
			this.media.setMuted(muted);
		},
		setCurrentTime: function(time) {
			this.media.setCurrentTime(time);
		},
		getCurrentTime: function() {
			return this.media.currentTime;
		},
		setVolume: function(volume) {
			this.media.setVolume(volume);
		},
		getVolume: function() {
			return this.media.volume;
		},
		setSrc: function(src) {
			this.media.setSrc(src);
		},
		remove: function() {
			var t = this, featureIndex, feature;

			t.container.prev('.mejs-offscreen').remove();

			// invoke features cleanup
			for (featureIndex in t.options.features) {
				feature = t.options.features[featureIndex];
				if (t['clean' + feature]) {
					try {
						t['clean' + feature](t);
					} catch (e) {
						// TODO: report control error
						//throw e;
						//
						//
					}
				}
			}

			// grab video and put it back in place
			if (!t.isDynamic) {
				t.$media.prop('controls', true);
				// detach events from the video
				// TODO: detach event listeners better than this;
				//       also detach ONLY the events attached by this plugin!
				t.$node.clone().insertBefore(t.container).show();
				t.$node.remove();
			} else {
				t.$node.insertBefore(t.container);
			}

			if (t.media.pluginType !== 'native') {
				t.media.remove();
			}

			// Remove the player from the mejs.players object so that pauseOtherPlayers doesn't blow up when trying to pause a non existance flash api.
			delete mejs.players[t.id];

			if (typeof t.container == 'object') {
				t.container.remove();
			}
			t.globalUnbind();
			delete t.node.player;
		},
		rebuildtracks: function(){
			var t = this;
			t.findTracks();
			t.buildtracks(t, t.controls, t.layers, t.media);
		},
		resetSize: function(){
			var t = this;
			// webkit has trouble doing this without a delay
			setTimeout(function () {
				//
				t.setPlayerSize(t.width, t.height);
				t.setControlsSize();
			}, 50);
		}
	};

	(function(){
		var rwindow = /^((after|before)print|(before)?unload|hashchange|message|o(ff|n)line|page(hide|show)|popstate|resize|storage)\b/;

		function splitEvents(events, id) {
			// add player ID as an event namespace so it's easier to unbind them all later
			var ret = {d: [], w: []};
			$.each((events || '').split(' '), function(k, v){
				var eventname = v + '.' + id;
				if (eventname.indexOf('.') === 0) {
					ret.d.push(eventname);
					ret.w.push(eventname);
				}
				else {
					ret[rwindow.test(v) ? 'w' : 'd'].push(eventname);
				}
			});
			ret.d = ret.d.join(' ');
			ret.w = ret.w.join(' ');
			return ret;
		}

		mejs.MediaElementPlayer.prototype.globalBind = function(events, data, callback) {
    		var t = this;
			var doc = t.node ? t.node.ownerDocument : document;

			events = splitEvents(events, t.id);
			if (events.d) $(doc).bind(events.d, data, callback);
			if (events.w) $(window).bind(events.w, data, callback);
		};

		mejs.MediaElementPlayer.prototype.globalUnbind = function(events, callback) {
			var t = this;
			var doc = t.node ? t.node.ownerDocument : document;

			events = splitEvents(events, t.id);
			if (events.d) $(doc).unbind(events.d, callback);
			if (events.w) $(window).unbind(events.w, callback);
		};
	})();

	// turn into jQuery plugin
	if (typeof $ != 'undefined') {
		$.fn.mediaelementplayer = function (options) {
			if (options === false) {
				this.each(function () {
					var player = $(this).data('mediaelementplayer');
					if (player) {
						player.remove();
					}
					$(this).removeData('mediaelementplayer');
				});
			}
			else {
				this.each(function () {
					$(this).data('mediaelementplayer', new mejs.MediaElementPlayer(this, options));
				});
			}
			return this;
		};


		$(document).ready(function() {
			// auto enable using JSON attribute
			$('.mejs-player').mediaelementplayer();
		});
	}

	// push out to window
	window.MediaElementPlayer = mejs.MediaElementPlayer;

})(mejs.$);

(function($) {

	$.extend(mejs.MepDefaults, {
		playText: mejs.i18n.t('Play'),
		pauseText: mejs.i18n.t('Pause')
	});

	// PLAY/pause BUTTON
	$.extend(MediaElementPlayer.prototype, {
		buildplaypause: function(player, controls, layers, media) {
			var 
				t = this,
				op = t.options,
				play = 
				$('<div class="mejs-button mejs-playpause-button mejs-play" >' +
					'<button type="button" aria-controls="' + t.id + '" title="' + op.playText + '" aria-label="' + op.playText + '"></button>' +
				'</div>')
				.appendTo(controls)
				.click(function(e) {
					e.preventDefault();
				
					if (media.paused) {
						media.play();
					} else {
						media.pause();
					}
					
					return false;
				}),
				play_btn = play.find('button');


			function togglePlayPause(which) {
				if ('play' === which) {
					play.removeClass('mejs-play').addClass('mejs-pause');
					play_btn.attr({
						'title': op.pauseText,
						'aria-label': op.pauseText
					});
				} else {
					play.removeClass('mejs-pause').addClass('mejs-play');
					play_btn.attr({
						'title': op.playText,
						'aria-label': op.playText
					});
				}
			};
			togglePlayPause('pse');


			media.addEventListener('play',function() {
				togglePlayPause('play');
			}, false);
			media.addEventListener('playing',function() {
				togglePlayPause('play');
			}, false);


			media.addEventListener('pause',function() {
				togglePlayPause('pse');
			}, false);
			media.addEventListener('paused',function() {
				togglePlayPause('pse');
			}, false);
		}
	});
	
})(mejs.$);

(function($) {

	$.extend(mejs.MepDefaults, {
		stopText: 'Stop'
	});

	// STOP BUTTON
	$.extend(MediaElementPlayer.prototype, {
		buildstop: function(player, controls, layers, media) {
			var t = this;

			$('<div class="mejs-button mejs-stop-button mejs-stop">' +
					'<button type="button" aria-controls="' + t.id + '" title="' + t.options.stopText + '" aria-label="' + t.options.stopText + '"></button>' +
				'</div>')
				.appendTo(controls)
				.click(function() {
					if (!media.paused) {
						media.pause();
					}
					if (media.currentTime > 0) {
						media.setCurrentTime(0);
                        media.pause();
						controls.find('.mejs-time-current').width('0px');
						controls.find('.mejs-time-handle').css('left', '0px');
						controls.find('.mejs-time-float-current').html( mejs.Utility.secondsToTimeCode(0, player.options));
						controls.find('.mejs-currenttime').html( mejs.Utility.secondsToTimeCode(0, player.options));
						layers.find('.mejs-poster').show();
					}
				});
		}
	});
	
})(mejs.$);

(function($) {

	$.extend(mejs.MepDefaults, {
		progessHelpText: mejs.i18n.t(
		'Use Left/Right Arrow keys to advance one second, Up/Down arrows to advance ten seconds.')
	});

	// progress/loaded bar
	$.extend(MediaElementPlayer.prototype, {
		buildprogress: function(player, controls, layers, media) {

			$('<div class="mejs-time-rail">' +
				'<span  class="mejs-time-total mejs-time-slider">' +
				//'<span class="mejs-offscreen">' + this.options.progessHelpText + '</span>' +
					'<span class="mejs-time-buffering"></span>' +
					'<span class="mejs-time-loaded"></span>' +
					'<span class="mejs-time-current"></span>' +
					'<span class="mejs-time-handle"></span>' +
					'<span class="mejs-time-float">' +
						'<span class="mejs-time-float-current">00:00</span>' +
						'<span class="mejs-time-float-corner"></span>' +
					'</span>' +
				'</span>' +
			'</div>')
				.appendTo(controls);
			controls.find('.mejs-time-buffering').hide();

			var 
				t = this,
				total = controls.find('.mejs-time-total'),
				loaded  = controls.find('.mejs-time-loaded'),
				current  = controls.find('.mejs-time-current'),
				handle  = controls.find('.mejs-time-handle'),
				timefloat  = controls.find('.mejs-time-float'),
				timefloatcurrent  = controls.find('.mejs-time-float-current'),
                slider = controls.find('.mejs-time-slider'),
				handleMouseMove = function (e) {
					
                    var offset = total.offset(),
						width = total.width(),
						percentage = 0,
						newTime = 0,
						pos = 0,
                        x;
                    
                    // mouse or touch position relative to the object
					if (e.originalEvent && e.originalEvent.changedTouches) {
						x = e.originalEvent.changedTouches[0].pageX;
					} else if (e.changedTouches) { // for Zepto
						x = e.changedTouches[0].pageX;
					} else {
						x = e.pageX;
					}

					if (media.duration) {
						if (x < offset.left) {
							x = offset.left;
						} else if (x > width + offset.left) {
							x = width + offset.left;
						}
						
						pos = x - offset.left;
						percentage = (pos / width);
						newTime = (percentage <= 0.02) ? 0 : percentage * media.duration;

						// seek to where the mouse is
						if (mouseIsDown && newTime !== media.currentTime) {
							media.setCurrentTime(newTime);
						}

						// position floating time box
						if (!mejs.MediaFeatures.hasTouch) {
								timefloat.css('left', pos);
								timefloatcurrent.html( mejs.Utility.secondsToTimeCode(newTime, player.options) );
								timefloat.show();
						}
					}
				},
				mouseIsDown = false,
				mouseIsOver = false,
				lastKeyPressTime = 0,
				startedPaused = false,
				autoRewindInitial = player.options.autoRewind;
            // Accessibility for slider
            var updateSlider = function (e) {

				var seconds = media.currentTime,
					timeSliderText = mejs.i18n.t('Time Slider'),
					time = mejs.Utility.secondsToTimeCode(seconds, player.options),
					duration = media.duration;

				slider.attr({
					'aria-label': timeSliderText,
					'aria-valuemin': 0,
					'aria-valuemax': duration,
					'aria-valuenow': seconds,
					'aria-valuetext': time,
					'role': 'slider',
					'tabindex': 0
				});

			};

				var restartPlayer = function () {
				var now = new Date();
				if (now - lastKeyPressTime >= 1000) {
					media.play();
				}
			};

			slider.bind('focus', function (e) {
				player.options.autoRewind = false;
			});

			slider.bind('blur', function (e) {
				player.options.autoRewind = autoRewindInitial;
			});

			slider.bind('keydown', function (e) {

				if ((new Date() - lastKeyPressTime) >= 1000) {
					startedPaused = media.paused;
				}

				var keyCode = e.keyCode,
					duration = media.duration,
					seekTime = media.currentTime,
					seekForward  = player.options.defaultSeekForwardInterval(duration),
					seekBackward = player.options.defaultSeekBackwardInterval(duration);

				switch (keyCode) {
				case 37: // left
				case 40: // Down
					seekTime -= seekBackward;
					break;
				case 39: // Right
				case 38: // Up
					seekTime += seekForward;
					break;
				case 36: // Home
					seekTime = 0;
					break;
				case 35: // end
					seekTime = duration;
					break;
				case 32: // space
				case 13: // enter
					media.paused ? media.play() : media.pause();
					return;
				default:
					return;
				}

				seekTime = seekTime < 0 ? 0 : (seekTime >= duration ? duration : Math.floor(seekTime));
				lastKeyPressTime = new Date();
				if (!startedPaused) {
					media.pause();
				}

				if (seekTime < media.duration && !startedPaused) {
					setTimeout(restartPlayer, 1100);
				}

				media.setCurrentTime(seekTime);

				e.preventDefault();
				e.stopPropagation();
				return false;
			});


			// handle clicks
			//controls.find('.mejs-time-rail').delegate('span', 'click', handleMouseMove);
			total
				.bind('mousedown touchstart', function (e) {
					// only handle left clicks or touch
					if (e.which === 1 || e.which === 0) {
						mouseIsDown = true;
						handleMouseMove(e);
						t.globalBind('mousemove.dur touchmove.dur', function(e) {
							handleMouseMove(e);
						});
						t.globalBind('mouseup.dur touchend.dur', function (e) {
							mouseIsDown = false;
							timefloat.hide();
							t.globalUnbind('.dur');
						});
					}
				})
				.bind('mouseenter', function(e) {
					mouseIsOver = true;
					t.globalBind('mousemove.dur', function(e) {
						handleMouseMove(e);
					});
					if (!mejs.MediaFeatures.hasTouch) {
						timefloat.show();
					}
				})
				.bind('mouseleave',function(e) {
					mouseIsOver = false;
					if (!mouseIsDown) {
						t.globalUnbind('.dur');
						timefloat.hide();
					}
				});

			// loading
			media.addEventListener('progress', function (e) {
				player.setProgressRail(e);
				player.setCurrentRail(e);
			}, false);

			// current time
			media.addEventListener('timeupdate', function(e) {
				player.setProgressRail(e);
				player.setCurrentRail(e);
				updateSlider(e);
			}, false);
			
			t.container.on('controlsresize', function() {
				player.setProgressRail();
				player.setCurrentRail();
			});
			
			// store for later use
			t.loaded = loaded;
			t.total = total;
			t.current = current;
			t.handle = handle;
		},
		setProgressRail: function(e) {

			var
				t = this,
				target = (e !== undefined) ? e.target : t.media,
				percent = null;

			// newest HTML5 spec has buffered array (FF4, Webkit)
			if (target && target.buffered && target.buffered.length > 0 && target.buffered.end && target.duration) {
				// account for a real array with multiple values - always read the end of the last buffer
				percent = target.buffered.end(target.buffered.length - 1) / target.duration;
			} 
			// Some browsers (e.g., FF3.6 and Safari 5) cannot calculate target.bufferered.end()
			// to be anything other than 0. If the byte count is available we use this instead.
			// Browsers that support the else if do not seem to have the bufferedBytes value and
			// should skip to there. Tested in Safari 5, Webkit head, FF3.6, Chrome 6, IE 7/8.
			else if (target && target.bytesTotal !== undefined && target.bytesTotal > 0 && target.bufferedBytes !== undefined) {
				percent = target.bufferedBytes / target.bytesTotal;
			}
			// Firefox 3 with an Ogg file seems to go this way
			else if (e && e.lengthComputable && e.total !== 0) {
				percent = e.loaded / e.total;
			}

			// finally update the progress bar
			if (percent !== null) {
				percent = Math.min(1, Math.max(0, percent));
				// update loaded bar
				if (t.loaded && t.total) {
					t.loaded.width(t.total.width() * percent);
				}
			}
		},
		setCurrentRail: function() {

			var t = this;
		
			if (t.media.currentTime !== undefined && t.media.duration) {

				// update bar and handle
				if (t.total && t.handle) {
					var 
						newWidth = Math.round(t.total.width() * t.media.currentTime / t.media.duration),
						handlePos = newWidth - Math.round(t.handle.outerWidth(true) / 2);

					t.current.width(newWidth);
					t.handle.css('left', handlePos);
				}
			}

		}
	});
})(mejs.$);

(function($) {
	
	// options
	$.extend(mejs.MepDefaults, {
		duration: -1,
		timeAndDurationSeparator: '<span> | </span>'
	});


	// current and duration 00:00 / 00:00
	$.extend(MediaElementPlayer.prototype, {
		buildcurrent: function(player, controls, layers, media) {
			var t = this;
			
			$('<div class="mejs-time" role="timer" aria-live="off">' +
					'<span class="mejs-currenttime">' + 
						mejs.Utility.secondsToTimeCode(0, player.options) +
                    '</span>'+
				'</div>')
			.appendTo(controls);
			
			t.currenttime = t.controls.find('.mejs-currenttime');

			media.addEventListener('timeupdate',function() {
				player.updateCurrent();
			}, false);
		},


		buildduration: function(player, controls, layers, media) {
			var t = this;
			
			if (controls.children().last().find('.mejs-currenttime').length > 0) {
				$(t.options.timeAndDurationSeparator +
					'<span class="mejs-duration">' + 
						mejs.Utility.secondsToTimeCode(t.options.duration, t.options) +
					'</span>')
					.appendTo(controls.find('.mejs-time'));
			} else {

				// add class to current time
				controls.find('.mejs-currenttime').parent().addClass('mejs-currenttime-container');
				
				$('<div class="mejs-time mejs-duration-container">'+
					'<span class="mejs-duration">' + 
						mejs.Utility.secondsToTimeCode(t.options.duration, t.options) +
					'</span>' +
				'</div>')
				.appendTo(controls);
			}
			
			t.durationD = t.controls.find('.mejs-duration');

			media.addEventListener('timeupdate',function() {
				player.updateDuration();
			}, false);
		},
		
		updateCurrent:  function() {
			var t = this;
			
			var currentTime = t.media.currentTime;
			
			if (isNaN(currentTime)) {
				currentTime = 0;
			}

			if (t.currenttime) {
				t.currenttime.html(mejs.Utility.secondsToTimeCode(currentTime, t.options));
			}
		},
		
		updateDuration: function() {
			var t = this;
			
			var duration = t.media.duration;
			if (t.options.duration > 0) {
				duration = t.options.duration;
			}
			
			if (isNaN(duration)) {
				duration = 0;
			}

			//Toggle the long video class if the video is longer than an hour.
			t.container.toggleClass("mejs-long-video", duration > 3600);
			
			if (t.durationD && duration > 0) {
				t.durationD.html(mejs.Utility.secondsToTimeCode(duration, t.options));
			}		
		}
	});

})(mejs.$);

(function($) {

	$.extend(mejs.MepDefaults, {
		muteText: mejs.i18n.t('Mute Toggle'),
        allyVolumeControlText: mejs.i18n.t('Use Up/Down Arrow keys to increase or decrease volume.'),
		hideVolumeOnTouchDevices: true,
		
		audioVolume: 'horizontal',
		videoVolume: 'vertical'
	});

	$.extend(MediaElementPlayer.prototype, {
		buildvolume: function(player, controls, layers, media) {
				
			// Android and iOS don't support volume controls
			if ((mejs.MediaFeatures.isAndroid || mejs.MediaFeatures.isiOS) && this.options.hideVolumeOnTouchDevices)
				return;
			
			var t = this,
				mode = (t.isVideo) ? t.options.videoVolume : t.options.audioVolume,
				mute = (mode == 'horizontal') ?
				
				// horizontal version
				$('<div class="mejs-button mejs-volume-button mejs-mute">' +
					'<button type="button" aria-controls="' + t.id + 
						'" title="' + t.options.muteText + 
						'" aria-label="' + t.options.muteText +
					'"></button>'+
				'</div>' +
                  '<a href="javascript:void(0);" class="mejs-horizontal-volume-slider">' + // outer background
					'<span class="mejs-offscreen">' + t.options.allyVolumeControlText + '</span>' +
					'<div class="mejs-horizontal-volume-total"></div>'+ // line background
					'<div class="mejs-horizontal-volume-current"></div>'+ // current volume
					'<div class="mejs-horizontal-volume-handle"></div>'+ // handle
				'</a>'
				)
					.appendTo(controls) :
				
				// vertical version
				$('<div class="mejs-button mejs-volume-button mejs-mute">'+
					'<button type="button" aria-controls="' + t.id + 
						'" title="' + t.options.muteText + 
						'" aria-label="' + t.options.muteText + 
					'"></button>'+
					'<a href="javascript:void(0);" class="mejs-volume-slider">'+ // outer background
						'<span class="mejs-offscreen">' + t.options.allyVolumeControlText + '</span>' +                  
						'<div class="mejs-volume-total"></div>'+ // line background
						'<div class="mejs-volume-current"></div>'+ // current volume
						'<div class="mejs-volume-handle"></div>'+ // handle
					'</a>'+
				'</div>')
					.appendTo(controls),
			volumeSlider = t.container.find('.mejs-volume-slider, .mejs-horizontal-volume-slider'),
			volumeTotal = t.container.find('.mejs-volume-total, .mejs-horizontal-volume-total'),
			volumeCurrent = t.container.find('.mejs-volume-current, .mejs-horizontal-volume-current'),
			volumeHandle = t.container.find('.mejs-volume-handle, .mejs-horizontal-volume-handle'),

			positionVolumeHandle = function(volume, secondTry) {

				if (!volumeSlider.is(':visible') && typeof secondTry == 'undefined') {
					volumeSlider.show();
					positionVolumeHandle(volume, true);
					volumeSlider.hide();
					return;
				}

				// correct to 0-1
				volume = Math.max(0,volume);
				volume = Math.min(volume,1);

				// ajust mute button style
				if (volume === 0) {
					mute.removeClass('mejs-mute').addClass('mejs-unmute');
					mute.children('button').attr('title', mejs.i18n.t('Unmute')).attr('aria-label', mejs.i18n.t('Unmute'));
				} else {
					mute.removeClass('mejs-unmute').addClass('mejs-mute');
					mute.children('button').attr('title', mejs.i18n.t('Mute')).attr('aria-label', mejs.i18n.t('Mute'));
				}

                // top/left of full size volume slider background
                var totalPosition = volumeTotal.position();
				// position slider 
				if (mode == 'vertical') {
					var
                    // height of the full size volume slider background
						totalHeight = volumeTotal.height(),

                        // the new top position based on the current volume
						// 70% volume on 100px height == top:30px
						newTop = totalHeight - (totalHeight * volume);
	
					// handle
					volumeHandle.css('top', Math.round(totalPosition.top + newTop - (volumeHandle.height() / 2)));
	
					// show the current visibility
					volumeCurrent.height(totalHeight - newTop );
					volumeCurrent.css('top', totalPosition.top + newTop);
				} else {
                    var
						// height of the full size volume slider background
						totalWidth = volumeTotal.width(),
						
						// the new left position based on the current volume
						newLeft = totalWidth * volume;
	
					// handle
					volumeHandle.css('left', Math.round(totalPosition.left + newLeft - (volumeHandle.width() / 2)));
	
					// rezize the current part of the volume bar
					volumeCurrent.width( Math.round(newLeft) );
				}
			},
			handleVolumeMove = function(e) {
				
				var volume = null,
					totalOffset = volumeTotal.offset();
				
				// calculate the new volume based on the moust position
				if (mode === 'vertical') {
				
					var
						railHeight = volumeTotal.height(),
						newY = e.pageY - totalOffset.top;
						
					volume = (railHeight - newY) / railHeight;
						
					// the controls just hide themselves (usually when mouse moves too far up)
					if (totalOffset.top === 0 || totalOffset.left === 0) {
						return;
                    }
					
				} else {
					var
						railWidth = volumeTotal.width(),
						newX = e.pageX - totalOffset.left;
						
					volume = newX / railWidth;
				}
				
				// ensure the volume isn't outside 0-1
				volume = Math.max(0,volume);
				volume = Math.min(volume,1);
				
				// position the slider and handle
				positionVolumeHandle(volume);
				
				// set the media object (this will trigger the volumechanged event)
				if (volume === 0) {
					media.setMuted(true);
				} else {
					media.setMuted(false);
				}
				media.setVolume(volume);
			},
			mouseIsDown = false,
			mouseIsOver = false;

			// SLIDER
			
			mute
				.hover(function() {
					volumeSlider.show();
					mouseIsOver = true;
				}, function() {
					mouseIsOver = false;
						
					if (!mouseIsDown && mode == 'vertical')	{
						volumeSlider.hide();
					}
				});
            
            var updateVolumeSlider = function (e) {

                var volume = Math.floor(media.volume*100);

				volumeSlider.attr({
					'aria-label': mejs.i18n.t('Volume Slider'),
					'aria-valuemin': 0,
					'aria-valuemax': 100,
					'aria-valuenow': volume,
					'aria-valuetext': volume+'%',
					'role': 'slider',
					'tabindex': 0
				});

			};
			
			volumeSlider
				.bind('mouseover', function() {
					mouseIsOver = true;	
				})
				.bind('mousedown', function (e) {
					handleVolumeMove(e);
					t.globalBind('mousemove.vol', function(e) {
						handleVolumeMove(e);
					});
					t.globalBind('mouseup.vol', function () {
						mouseIsDown = false;
						t.globalUnbind('.vol');

						if (!mouseIsOver && mode == 'vertical') {
							volumeSlider.hide();
						}
					});
					mouseIsDown = true;
						
					return false;
				})
				.bind('keydown', function (e) {
					var keyCode = e.keyCode;
					var volume = media.volume;
					switch (keyCode) {
                        case 38: // Up
                            volume = Math.min(volume + 0.1, 1);
                            break;
                        case 40: // Down
                            volume = Math.max(0, volume - 0.1);
                            break;
                        default:
                            return true;
                    }

					mouseIsDown = false;
					positionVolumeHandle(volume);
					media.setVolume(volume);
					return false;
				});

			// MUTE button
			mute.find('button').click(function() {
				media.setMuted( !media.muted );
			});
            
            //Keyboard input
            mute.find('button').bind('focus', function () {
				volumeSlider.show();
			});

			// listen for volume change events from other sources
			media.addEventListener('volumechange', function(e) {
				if (!mouseIsDown) {
					if (media.muted) {
						positionVolumeHandle(0);
						mute.removeClass('mejs-mute').addClass('mejs-unmute');
					} else {
						positionVolumeHandle(media.volume);
						mute.removeClass('mejs-unmute').addClass('mejs-mute');
					}
				}
				updateVolumeSlider(e);
			}, false);
			
			// mutes the media and sets the volume icon muted if the initial volume is set to 0
			if (player.options.startVolume === 0) {
				media.setMuted(true);
			}
			
			// shim gets the startvolume as a parameter, but we have to set it on the native <video> and <audio> elements
			if (media.pluginType === 'native') {
				media.setVolume(player.options.startVolume);
			}
			
			t.container.on('controlsresize', function() {
				positionVolumeHandle(media.volume);
			});
		}
	});
	
})(mejs.$);

(function($) {

	$.extend(mejs.MepDefaults, {
		usePluginFullScreen: true,
		newWindowCallback: function() { return '';},
		fullscreenText: mejs.i18n.t('Fullscreen')
	});

	$.extend(MediaElementPlayer.prototype, {

		isFullScreen: false,

		isNativeFullScreen: false,

		isInIframe: false,
							
		// Possible modes
		// (1) 'native-native' 	HTML5 video  + browser fullscreen (IE10+, etc.)
		// (2) 'plugin-native' 	plugin video + browser fullscreen (fails in some versions of Firefox)
		// (3) 'fullwindow' 	Full window (retains all UI)
		// usePluginFullScreen = true
		// (4) 'plugin-click' 	Flash 1 - click through with pointer events
		// (5) 'plugin-hover' 	Flash 2 - hover popup in flash (IE6-8)		
		fullscreenMode: '',

		buildfullscreen: function(player, controls, layers, media) {

			if (!player.isVideo)
				return;
				
			player.isInIframe = (window.location != window.parent.location);	
		
			// detect on start
			media.addEventListener('play', function() { player.detectFullscreenMode(); });
				
			// build button
			var t = this,
				hideTimeout = null,
				fullscreenBtn =
					$('<div class="mejs-button mejs-fullscreen-button">' +
						'<button type="button" aria-controls="' + t.id + '" title="' + t.options.fullscreenText + '" aria-label="' + t.options.fullscreenText + '"></button>' +
					'</div>')
					.appendTo(controls)
					.on('click', function() {
						
						// toggle fullscreen
						var isFullScreen = (mejs.MediaFeatures.hasTrueNativeFullScreen && mejs.MediaFeatures.isFullScreen()) || player.isFullScreen;
	
						if (isFullScreen) {
							player.exitFullScreen();
						} else {
							player.enterFullScreen();
						}
					})										
					.on('mouseover', function() {
						
						// very old browsers with a plugin
						if (t.fullscreenMode == 'plugin-hover') {						
							if (hideTimeout !== null) {
								clearTimeout(hideTimeout);
								delete hideTimeout;
							}
	
							var buttonPos = fullscreenBtn.offset(),
								containerPos = player.container.offset();
	
							media.positionFullscreenButton(buttonPos.left - containerPos.left, buttonPos.top - containerPos.top, true);
						}

					})
					.on('mouseout', function() {

						if (t.fullscreenMode == 'plugin-hover') {						
							if (hideTimeout !== null) {
								clearTimeout(hideTimeout);
								delete hideTimeout;
							}
	
							hideTimeout = setTimeout(function() {
								media.hideFullscreenButton();
							}, 1500);
						}

					});

					

			player.fullscreenBtn = fullscreenBtn;

			t.globalBind('keydown',function (e) {
				if (e.keyCode == 27 && ((mejs.MediaFeatures.hasTrueNativeFullScreen && mejs.MediaFeatures.isFullScreen()) || t.isFullScreen)) {
					player.exitFullScreen();
				}
			});
			
			t.normalHeight = 0;
			t.normalWidth = 0;					
					
			// setup native fullscreen event
			if (mejs.MediaFeatures.hasTrueNativeFullScreen) {

				// chrome doesn't alays fire this in an iframe
				var fullscreenChanged = function(e) {
					if (player.isFullScreen) {
						if (mejs.MediaFeatures.isFullScreen()) {
							player.isNativeFullScreen = true;
							// reset the controls once we are fully in full screen
							player.setControlsSize();
						} else {
							player.isNativeFullScreen = false;
							// when a user presses ESC
							// make sure to put the player back into place
							player.exitFullScreen();
						}
					}
				};

				player.globalBind(mejs.MediaFeatures.fullScreenEventName, fullscreenChanged);
			}

		},
		
		detectFullscreenMode: function() {
			
			var t = this,
				mode = '',
				features = mejs.MediaFeatures;
			
			if (features.hasTrueNativeFullScreen && t.media.pluginType === 'native') {
				mode = 'native-native';
			} else if (features.hasTrueNativeFullScreen && t.media.pluginType !== 'native' && !features.hasFirefoxPluginMovingProblem) {
				mode = 'plugin-native';					
			} else if (t.usePluginFullScreen) { 
				if (mejs.MediaFeatures.supportsPointerEvents) {
					mode = 'plugin-click';
					// this needs some special setup
					t.createPluginClickThrough();				
				} else { 
					mode = 'plugin-hover';
				}
				
			} else {
				mode = 'fullwindow';
			}
			
			
			t.fullscreenMode = mode;		
			return mode;
		},
		
		isPluginClickThroughCreated: false,
		
		createPluginClickThrough: function() {
				
			var t = this;
			
			// don't build twice
			if (t.isPluginClickThroughCreated) {
				return;
			}	

			// allows clicking through the fullscreen button and controls down directly to Flash

			/*
			 When a user puts his mouse over the fullscreen button, we disable the controls so that mouse events can go down to flash (pointer-events)
			 We then put a divs over the video and on either side of the fullscreen button
			 to capture mouse movement and restore the controls once the mouse moves outside of the fullscreen button
			*/

			var fullscreenIsDisabled = false,
				restoreControls = function() {
					if (fullscreenIsDisabled) {
						// hide the hovers
						for (var i in hoverDivs) {
							hoverDivs[i].hide();
						}

						// restore the control bar
						t.fullscreenBtn.css('pointer-events', '');
						t.controls.css('pointer-events', '');

						// prevent clicks from pausing video
						t.media.removeEventListener('click', t.clickToPlayPauseCallback);

						// store for later
						fullscreenIsDisabled = false;
					}
				},
				hoverDivs = {},
				hoverDivNames = ['top', 'left', 'right', 'bottom'],
				i, len,
				positionHoverDivs = function() {
					var fullScreenBtnOffsetLeft = fullscreenBtn.offset().left - t.container.offset().left,
						fullScreenBtnOffsetTop = fullscreenBtn.offset().top - t.container.offset().top,
						fullScreenBtnWidth = fullscreenBtn.outerWidth(true),
						fullScreenBtnHeight = fullscreenBtn.outerHeight(true),
						containerWidth = t.container.width(),
						containerHeight = t.container.height();

					for (i in hoverDivs) {
						hoverDivs[i].css({position: 'absolute', top: 0, left: 0}); //, backgroundColor: '#f00'});
					}

					// over video, but not controls
					hoverDivs['top']
						.width( containerWidth )
						.height( fullScreenBtnOffsetTop );

					// over controls, but not the fullscreen button
					hoverDivs['left']
						.width( fullScreenBtnOffsetLeft )
						.height( fullScreenBtnHeight )
						.css({top: fullScreenBtnOffsetTop});

					// after the fullscreen button
					hoverDivs['right']
						.width( containerWidth - fullScreenBtnOffsetLeft - fullScreenBtnWidth )
						.height( fullScreenBtnHeight )
						.css({top: fullScreenBtnOffsetTop,
							 left: fullScreenBtnOffsetLeft + fullScreenBtnWidth});

					// under the fullscreen button
					hoverDivs['bottom']
						.width( containerWidth )
						.height( containerHeight - fullScreenBtnHeight - fullScreenBtnOffsetTop )
						.css({top: fullScreenBtnOffsetTop + fullScreenBtnHeight});
				};

			t.globalBind('resize', function() {
				positionHoverDivs();
			});

			for (i = 0, len = hoverDivNames.length; i < len; i++) {
				hoverDivs[hoverDivNames[i]] = $('<div class="mejs-fullscreen-hover" />').appendTo(t.container).mouseover(restoreControls).hide();
			}

			// on hover, kill the fullscreen button's HTML handling, allowing clicks down to Flash
			fullscreenBtn.on('mouseover',function() {

				if (!t.isFullScreen) {

					var buttonPos = fullscreenBtn.offset(),
						containerPos = player.container.offset();

					// move the button in Flash into place
					media.positionFullscreenButton(buttonPos.left - containerPos.left, buttonPos.top - containerPos.top, false);

					// allows click through
					t.fullscreenBtn.css('pointer-events', 'none');
					t.controls.css('pointer-events', 'none');

					// restore click-to-play
					t.media.addEventListener('click', t.clickToPlayPauseCallback);

					// show the divs that will restore things
					for (i in hoverDivs) {
						hoverDivs[i].show();
					}

					positionHoverDivs();

					fullscreenIsDisabled = true;
				}

			});

			// restore controls anytime the user enters or leaves fullscreen
			media.addEventListener('fullscreenchange', function(e) {
				t.isFullScreen = !t.isFullScreen;
				// don't allow plugin click to pause video - messes with
				// plugin's controls
				if (t.isFullScreen) {
					t.media.removeEventListener('click', t.clickToPlayPauseCallback);
				} else {
					t.media.addEventListener('click', t.clickToPlayPauseCallback);
				}
				restoreControls();
			});


			// the mouseout event doesn't work on the fullscren button, because we already killed the pointer-events
			// so we use the document.mousemove event to restore controls when the mouse moves outside the fullscreen button

			t.globalBind('mousemove', function(e) {

				// if the mouse is anywhere but the fullsceen button, then restore it all
				if (fullscreenIsDisabled) {

					var fullscreenBtnPos = fullscreenBtn.offset();


					if (e.pageY < fullscreenBtnPos.top || e.pageY > fullscreenBtnPos.top + fullscreenBtn.outerHeight(true) ||
						e.pageX < fullscreenBtnPos.left || e.pageX > fullscreenBtnPos.left + fullscreenBtn.outerWidth(true)
						) {

						fullscreenBtn.css('pointer-events', '');
						t.controls.css('pointer-events', '');

						fullscreenIsDisabled = false;
					}
				}
			});


			t.isPluginClickThroughCreated = true;
		},		

		cleanfullscreen: function(player) {
			player.exitFullScreen();
		},

        containerSizeTimeout: null,

		enterFullScreen: function() {

			var t = this;

			if (mejs.MediaFeatures.hasiOSFullScreen) {
				t.media.webkitEnterFullscreen();
				return;
			}

			// set it to not show scroll bars so 100% will work
            $(document.documentElement).addClass('mejs-fullscreen');

			// store sizing
			t.normalHeight = t.container.height();
			t.normalWidth = t.container.width();



			// attempt to do true fullscreen
			if (t.fullscreenMode === 'native-native' || t.fullscreenMode === 'plugin-native') {

				mejs.MediaFeatures.requestFullScreen(t.container[0]);
				//return;

				if (t.isInIframe) {
					// sometimes exiting from fullscreen doesn't work
					// notably in Chrome <iframe>. Fixed in version 17
					setTimeout(function checkFullscreen() {

						if (t.isNativeFullScreen) {
							var percentErrorMargin = 0.002, // 0.2%
								windowWidth = $(window).width(),
								screenWidth = screen.width,
								absDiff = Math.abs(screenWidth - windowWidth),
								marginError = screenWidth * percentErrorMargin;

							// check if the video is suddenly not really fullscreen
							if (absDiff > marginError) {
								// manually exit
								t.exitFullScreen();
							} else {
								// test again
								setTimeout(checkFullscreen, 500);
							}
						}
						
					}, 1000);
				}
				
			} else if (t.fullscreeMode == 'fullwindow') {				
				// move into position
				
			}			
			
			// make full size
			t.container
				.addClass('mejs-container-fullscreen')
				.width('100%')
				.height('100%');
				//.css({position: 'fixed', left: 0, top: 0, right: 0, bottom: 0, overflow: 'hidden', width: '100%', height: '100%', 'z-index': 1000});

			// Only needed for safari 5.1 native full screen, can cause display issues elsewhere
			// Actually, it seems to be needed for IE8, too
			//if (mejs.MediaFeatures.hasTrueNativeFullScreen) {
				t.containerSizeTimeout = setTimeout(function() {
					t.container.css({width: '100%', height: '100%'});
					t.setControlsSize();
				}, 500);
			//}

			if (t.media.pluginType === 'native') {
				t.$media
					.width('100%')
					.height('100%');
			} else {
				t.container.find('.mejs-shim')
					.width('100%')
					.height('100%');	
				
				setTimeout(function() {
					var win = $(window),
						winW = win.width(),
						winH = win.height();
							
					t.media.setVideoSize(winW,winH);			
				}, 500);
			}

			t.layers.children('div')
				.width('100%')
				.height('100%');

			if (t.fullscreenBtn) {
				t.fullscreenBtn
					.removeClass('mejs-fullscreen')
					.addClass('mejs-unfullscreen');
			}

			t.setControlsSize();
			t.isFullScreen = true;

			t.container.find('.mejs-captions-text').css('font-size', screen.width / t.width * 1.00 * 100 + '%');
			t.container.find('.mejs-captions-position').css('bottom', '45px');

			t.container.trigger('enteredfullscreen');
		},

		exitFullScreen: function() {

			var t = this;

            // Prevent container from attempting to stretch a second time
            clearTimeout(t.containerSizeTimeout);

			// firefox can't adjust plugins
			/*
			if (t.media.pluginType !== 'native' && mejs.MediaFeatures.isFirefox) {
				t.media.setFullscreen(false);
				//player.isFullScreen = false;
				return;
			}
			*/

			// come out of native fullscreen
			if (mejs.MediaFeatures.hasTrueNativeFullScreen && (mejs.MediaFeatures.isFullScreen() || t.isFullScreen)) {
				mejs.MediaFeatures.cancelFullScreen();
			}

			// restore scroll bars to document
            $(document.documentElement).removeClass('mejs-fullscreen');

			t.container
				.removeClass('mejs-container-fullscreen')
				.width(t.normalWidth)
				.height(t.normalHeight);

			if (t.media.pluginType === 'native') {
				t.$media
					.width(t.normalWidth)
					.height(t.normalHeight);
			} else {
				t.container.find('.mejs-shim')
					.width(t.normalWidth)
					.height(t.normalHeight);

				t.media.setVideoSize(t.normalWidth, t.normalHeight);
			}

			t.layers.children('div')
				.width(t.normalWidth)
				.height(t.normalHeight);

			t.fullscreenBtn
				.removeClass('mejs-unfullscreen')
				.addClass('mejs-fullscreen');

			t.setControlsSize();
			t.isFullScreen = false;

			t.container.find('.mejs-captions-text').css('font-size','');
			t.container.find('.mejs-captions-position').css('bottom', '');

			t.container.trigger('exitedfullscreen');
		}
	});

})(mejs.$);

(function($) {

	// Speed
	$.extend(mejs.MepDefaults, {

		// We also support to pass object like this:
		// [{name: 'Slow', value: '0.75'}, {name: 'Normal', value: '1.00'}, ...]
		speeds: ['2.00', '1.50', '1.25', '1.00', '0.75'],

		defaultSpeed: '1.00',
		
		speedChar: 'x'

	});

	$.extend(MediaElementPlayer.prototype, {

		buildspeed: function(player, controls, layers, media) {
			var t = this;

			if (t.media.pluginType == 'native') {
				var 
					speedButton = null,
					speedSelector = null,
					playbackSpeed = null,
					inputId = null;

				var speeds = [];
				var defaultInArray = false;
				for (var i=0, len=t.options.speeds.length; i < len; i++) {
					var s = t.options.speeds[i];
					if (typeof(s) === 'string'){
						speeds.push({
							name: s + t.options.speedChar,
							value: s
						});
						if(s === t.options.defaultSpeed) {
							defaultInArray = true;
						}
					}
					else {
						speeds.push(s);
						if(s.value === t.options.defaultSpeed) {
							defaultInArray = true;
						}
					}
				}

				if (!defaultInArray) {
					speeds.push({
						name: t.options.defaultSpeed + t.options.speedChar,
						value: t.options.defaultSpeed
					});
				}

				speeds.sort(function(a, b) {
					return parseFloat(b.value) - parseFloat(a.value);
				});

				var getSpeedNameFromValue = function(value) {
					for(i=0,len=speeds.length; i <len; i++) {
						if (speeds[i].value === value) {
							return speeds[i].name;
						}
					}
				};

				var html = '<div class="mejs-button mejs-speed-button">' +
							'<button type="button">' + getSpeedNameFromValue(t.options.defaultSpeed) + '</button>' +
							'<div class="mejs-speed-selector">' +
							'<ul>';

				for (i = 0, il = speeds.length; i<il; i++) {
					inputId = t.id + '-speed-' + speeds[i].value;
					html += '<li>' + 
								'<input type="radio" name="speed" ' + 
											'value="' + speeds[i].value + '" ' +
											'id="' + inputId + '" ' +
											(speeds[i].value === t.options.defaultSpeed ? ' checked' : '') +
											' />' +
								'<label for="' + inputId + '" ' +
											(speeds[i].value === t.options.defaultSpeed ? ' class="mejs-speed-selected"' : '') +
											'>' + speeds[i].name + '</label>' +
							'</li>';
				}
				html += '</ul></div></div>';

				speedButton = $(html).appendTo(controls);
				speedSelector = speedButton.find('.mejs-speed-selector');

				playbackSpeed = t.options.defaultSpeed;

				media.addEventListener('loadedmetadata', function(e) {
					if (playbackSpeed) {
						media.playbackRate = parseFloat(playbackSpeed);
					}
				}, true);

				speedSelector
					.on('click', 'input[type="radio"]', function() {
						var newSpeed = $(this).attr('value');
						playbackSpeed = newSpeed;
						media.playbackRate = parseFloat(newSpeed);
						speedButton.find('button').html(getSpeedNameFromValue(newSpeed));
						speedButton.find('.mejs-speed-selected').removeClass('mejs-speed-selected');
						speedButton.find('input[type="radio"]:checked').next().addClass('mejs-speed-selected');
					});
				speedButton
					.one( 'mouseenter focusin', function() {
						speedSelector
							.height(
								speedButton.find('.mejs-speed-selector ul').outerHeight(true) +
								speedButton.find('.mejs-speed-translations').outerHeight(true))
							.css('top', (-1 * speedSelector.height()) + 'px');
					});
			}
		}
	});

})(mejs.$);

(function($) {

	// add extra default options
	$.extend(mejs.MepDefaults, {
		// this will automatically turn on a <track>
		startLanguage: '',

		tracksText: mejs.i18n.t('Captions/Subtitles'),

		// By default, no WAI-ARIA live region - don't make a
		// screen reader speak captions over an audio track.
		tracksAriaLive: false,

		// option to remove the [cc] button when no <track kind="subtitles"> are present
		hideCaptionsButtonWhenEmpty: true,

		// If true and we only have one track, change captions to popup
		toggleCaptionsButtonWhenOnlyOne: false,

		// #id or .class
		slidesSelector: ''
	});

	$.extend(MediaElementPlayer.prototype, {

		hasChapters: false,

		cleartracks: function(player, controls, layers, media){
			if(player) {
				if(player.captions) player.captions.remove();
				if(player.chapters) player.chapters.remove();
				if(player.captionsText) player.captionsText.remove();
				if(player.captionsButton) player.captionsButton.remove();
			}
		},
		buildtracks: function(player, controls, layers, media) {
			if (player.tracks.length === 0)
				return;

			var t = this,
				attr = t.options.tracksAriaLive ?
					'role="log" aria-live="assertive" aria-atomic="false"' : '',
				i;

			if (t.domNode.textTracks) { // if browser will do native captions, prefer mejs captions, loop through tracks and hide
				for (i = t.domNode.textTracks.length - 1; i >= 0; i--) {
					t.domNode.textTracks[i].mode = "hidden";
				}
			}
			t.cleartracks(player, controls, layers, media);
			player.chapters =
					$('<div class="mejs-chapters mejs-layer"></div>')
						.prependTo(layers).hide();
			player.captions =
					$('<div class="mejs-captions-layer mejs-layer"><div class="mejs-captions-position mejs-captions-position-hover" ' +
					attr + '><span class="mejs-captions-text"></span></div></div>')
						.prependTo(layers).hide();
			player.captionsText = player.captions.find('.mejs-captions-text');
			player.captionsButton =
					$('<div class="mejs-button mejs-captions-button">'+
						'<button type="button" aria-controls="' + t.id + '" title="' + t.options.tracksText + '" aria-label="' + t.options.tracksText + '"></button>'+
						'<div class="mejs-captions-selector">'+
							'<ul>'+
								'<li>'+
									'<input type="radio" name="' + player.id + '_captions" id="' + player.id + '_captions_none" value="none" checked="checked" />' +
									'<label for="' + player.id + '_captions_none">' + mejs.i18n.t('None') +'</label>'+
								'</li>'	+
							'</ul>'+
						'</div>'+
					'</div>')
						.appendTo(controls);


			var subtitleCount = 0;
			for (i=0; i<player.tracks.length; i++) {
				if (player.tracks[i].kind == 'subtitles') {
					subtitleCount++;
				}
			}

			// if only one language then just make the button a toggle
			if (t.options.toggleCaptionsButtonWhenOnlyOne && subtitleCount == 1){
				// click
				player.captionsButton.on('click',function() {
					if (player.selectedTrack === null) {
						lang = player.tracks[0].srclang;
					} else {
						lang = 'none';
					}
					player.setTrack(lang);
				});
			} else {
				// hover or keyboard focus
				player.captionsButton.on( 'mouseenter focusin', function() {
					$(this).find('.mejs-captions-selector').removeClass('mejs-offscreen');
				})

				// handle clicks to the language radio buttons
				.on('click','input[type=radio]',function() {
					lang = this.value;
					player.setTrack(lang);
				});

				player.captionsButton.on( 'mouseleave focusout', function() {
					$(this).find(".mejs-captions-selector").addClass("mejs-offscreen");
				});

			}

			if (!player.options.alwaysShowControls) {
				// move with controls
				player.container
					.bind('controlsshown', function () {
						// push captions above controls
						player.container.find('.mejs-captions-position').addClass('mejs-captions-position-hover');

					})
					.bind('controlshidden', function () {
						if (!media.paused) {
							// move back to normal place
							player.container.find('.mejs-captions-position').removeClass('mejs-captions-position-hover');
						}
					});
			} else {
				player.container.find('.mejs-captions-position').addClass('mejs-captions-position-hover');
			}

			player.trackToLoad = -1;
			player.selectedTrack = null;
			player.isLoadingTrack = false;

			// add to list
			for (i=0; i<player.tracks.length; i++) {
				if (player.tracks[i].kind == 'subtitles') {
					player.addTrackButton(player.tracks[i].srclang, player.tracks[i].label);
				}
			}

			// start loading tracks
			player.loadNextTrack();

			media.addEventListener('timeupdate',function(e) {
				player.displayCaptions();
			}, false);

			if (player.options.slidesSelector !== '') {
				player.slidesContainer = $(player.options.slidesSelector);

				media.addEventListener('timeupdate',function(e) {
					player.displaySlides();
				}, false);

			}

			media.addEventListener('loadedmetadata', function(e) {
				player.displayChapters();
			}, false);

			player.container.hover(
				function () {
					// chapters
					if (player.hasChapters) {
						player.chapters.removeClass('mejs-offscreen');
						player.chapters.fadeIn(200).height(player.chapters.find('.mejs-chapter').outerHeight());
					}
				},
				function () {
					if (player.hasChapters && !media.paused) {
						player.chapters.fadeOut(200, function() {
							$(this).addClass('mejs-offscreen');
							$(this).css('display','block');
						});
					}
				});

			t.container.on('controlsresize', function() {
				t.adjustLanguageBox();
			});

			// check for autoplay
			if (player.node.getAttribute('autoplay') !== null) {
				player.chapters.addClass('mejs-offscreen');
			}
		},

		setTrack: function(lang){

			var t = this,
				i;

			if (lang == 'none') {
				t.selectedTrack = null;
				t.captionsButton.removeClass('mejs-captions-enabled');
			} else {
				for (i=0; i<t.tracks.length; i++) {
					if (t.tracks[i].srclang == lang) {
						if (t.selectedTrack === null)
							t.captionsButton.addClass('mejs-captions-enabled');
						t.selectedTrack = t.tracks[i];
						t.captions.attr('lang', t.selectedTrack.srclang);
						t.displayCaptions();
						break;
					}
				}
			}
		},

		loadNextTrack: function() {
			var t = this;

			t.trackToLoad++;
			if (t.trackToLoad < t.tracks.length) {
				t.isLoadingTrack = true;
				t.loadTrack(t.trackToLoad);
			} else {
				// add done?
				t.isLoadingTrack = false;

				t.checkForTracks();
			}
		},

		loadTrack: function(index){
			var
				t = this,
				track = t.tracks[index],
				after = function() {

					track.isLoaded = true;

					t.enableTrackButton(track.srclang, track.label);

					t.loadNextTrack();

				};


			$.ajax({
				url: track.src,
				dataType: "text",
				success: function(d) {

					// parse the loaded file
					if (typeof d == "string" && (/<tt\s+xml/ig).exec(d)) {
						track.entries = mejs.TrackFormatParser.dfxp.parse(d);
					} else {
						track.entries = mejs.TrackFormatParser.webvtt.parse(d);
					}

					after();

					if (track.kind == 'chapters') {
						t.media.addEventListener('play', function(e) {
							if (t.media.duration > 0) {
								t.displayChapters(track);
							}
						}, false);
					}

					if (track.kind == 'slides') {
						t.setupSlides(track);
					}
				},
				error: function() {
					t.removeTrackButton(track.srclang);
					t.loadNextTrack();
				}
			});
		},

		enableTrackButton: function(lang, label) {
			var t = this;

			if (label === '') {
				label = mejs.language.codes[lang] || lang;
			}

			t.captionsButton
				.find('input[value=' + lang + ']')
					.prop('disabled',false)
				.siblings('label')
					.html( label );

			// auto select
			if (t.options.startLanguage == lang) {
				$('#' + t.id + '_captions_' + lang).prop('checked', true).trigger('click');
			}

			t.adjustLanguageBox();
		},

		removeTrackButton: function(lang) {
			var t = this;

			t.captionsButton.find('input[value=' + lang + ']').closest('li').remove();

			t.adjustLanguageBox();
		},

		addTrackButton: function(lang, label) {
			var t = this;
			if (label === '') {
				label = mejs.language.codes[lang] || lang;
			}

			t.captionsButton.find('ul').append(
				$('<li>'+
					'<input type="radio" name="' + t.id + '_captions" id="' + t.id + '_captions_' + lang + '" value="' + lang + '" disabled="disabled" />' +
					'<label for="' + t.id + '_captions_' + lang + '">' + label + ' (loading)' + '</label>'+
				'</li>')
			);

			t.adjustLanguageBox();

			// remove this from the dropdownlist (if it exists)
			t.container.find('.mejs-captions-translations option[value=' + lang + ']').remove();
		},

		adjustLanguageBox:function() {
			var t = this;
			// adjust the size of the outer box
			t.captionsButton.find('.mejs-captions-selector').height(
				t.captionsButton.find('.mejs-captions-selector ul').outerHeight(true) +
				t.captionsButton.find('.mejs-captions-translations').outerHeight(true)
			);
		},

		checkForTracks: function() {
			var
				t = this,
				hasSubtitles = false;

			// check if any subtitles
			if (t.options.hideCaptionsButtonWhenEmpty) {
				for (i=0; i<t.tracks.length; i++) {
					if (t.tracks[i].kind == 'subtitles' && t.tracks[i].isLoaded) {
						hasSubtitles = true;
						break;
					}
				}

				if (!hasSubtitles) {
					t.captionsButton.hide();
					t.setControlsSize();
				}
			}
		},

		displayCaptions: function() {

			if (typeof this.tracks == 'undefined')
				return;

			var
				t = this,
				i,
				track = t.selectedTrack;

			if (track !== null && track.isLoaded) {
				for (i=0; i<track.entries.times.length; i++) {
					if (t.media.currentTime >= track.entries.times[i].start && t.media.currentTime <= track.entries.times[i].stop) {
						// Set the line before the timecode as a class so the cue can be targeted if needed
						t.captionsText.html(track.entries.text[i]).attr('class', 'mejs-captions-text ' + (track.entries.times[i].identifier || ''));
						t.captions.show().height(0);
						return; // exit out if one is visible;
					}
				}
				t.captions.hide();
			} else {
				t.captions.hide();
			}
		},

		setupSlides: function(track) {
			var t = this;

			t.slides = track;
			t.slides.entries.imgs = [t.slides.entries.text.length];
			t.showSlide(0);

		},

		showSlide: function(index) {
			if (typeof this.tracks == 'undefined' || typeof this.slidesContainer == 'undefined') {
				return;
			}

			var t = this,
				url = t.slides.entries.text[index],
				img = t.slides.entries.imgs[index];

			if (typeof img == 'undefined' || typeof img.fadeIn == 'undefined') {

				t.slides.entries.imgs[index] = img = $('<img src="' + url + '">')
						.on('load', function() {
							img.appendTo(t.slidesContainer)
								.hide()
								.fadeIn()
								.siblings(':visible')
									.fadeOut();

						});

			} else {

				if (!img.is(':visible') && !img.is(':animated')) {

					//

					img.fadeIn()
						.siblings(':visible')
							.fadeOut();
				}
			}

		},

		displaySlides: function() {

			if (typeof this.slides == 'undefined')
				return;

			var
				t = this,
				slides = t.slides,
				i;

			for (i=0; i<slides.entries.times.length; i++) {
				if (t.media.currentTime >= slides.entries.times[i].start && t.media.currentTime <= slides.entries.times[i].stop){

					t.showSlide(i);

					return; // exit out if one is visible;
				}
			}
		},

		displayChapters: function() {
			var
				t = this,
				i;

			for (i=0; i<t.tracks.length; i++) {
				if (t.tracks[i].kind == 'chapters' && t.tracks[i].isLoaded) {
					t.drawChapters(t.tracks[i]);
					t.hasChapters = true;
					break;
				}
			}
		},

		drawChapters: function(chapters) {
			var
				t = this,
				i,
				dur,
				//width,
				//left,
				percent = 0,
				usedPercent = 0;

			t.chapters.empty();

			for (i=0; i<chapters.entries.times.length; i++) {
				dur = chapters.entries.times[i].stop - chapters.entries.times[i].start;
				percent = Math.floor(dur / t.media.duration * 100);
				if (percent + usedPercent > 100 || // too large
					i == chapters.entries.times.length-1 && percent + usedPercent < 100) // not going to fill it in
					{
					percent = 100 - usedPercent;
				}
				//width = Math.floor(t.width * dur / t.media.duration);
				//left = Math.floor(t.width * chapters.entries.times[i].start / t.media.duration);
				//if (left + width > t.width) {
				//	width = t.width - left;
				//}

				t.chapters.append( $(
					'<div class="mejs-chapter" rel="' + chapters.entries.times[i].start + '" style="left: ' + usedPercent.toString() + '%;width: ' + percent.toString() + '%;">' +
						'<div class="mejs-chapter-block' + ((i==chapters.entries.times.length-1) ? ' mejs-chapter-block-last' : '') + '">' +
							'<span class="ch-title">' + chapters.entries.text[i] + '</span>' +
							'<span class="ch-time">' + mejs.Utility.secondsToTimeCode(chapters.entries.times[i].start, t.options) + '&ndash;' + mejs.Utility.secondsToTimeCode(chapters.entries.times[i].stop, t.options) + '</span>' +
						'</div>' +
					'</div>'));
				usedPercent += percent;
			}

			t.chapters.find('div.mejs-chapter').click(function() {
				t.media.setCurrentTime( parseFloat( $(this).attr('rel') ) );
				if (t.media.paused) {
					t.media.play();
				}
			});

			t.chapters.show();
		}
	});



	mejs.language = {
		codes:  {
			af:'Afrikaans',
			sq:'Albanian',
			ar:'Arabic',
			be:'Belarusian',
			bg:'Bulgarian',
			ca:'Catalan',
			zh:'Chinese',
			'zh-cn':'Chinese Simplified',
			'zh-tw':'Chinese Traditional',
			hr:'Croatian',
			cs:'Czech',
			da:'Danish',
			nl:'Dutch',
			en:'English',
			et:'Estonian',
			fl:'Filipino',
			fi:'Finnish',
			fr:'French',
			gl:'Galician',
			de:'German',
			el:'Greek',
			ht:'Haitian Creole',
			iw:'Hebrew',
			hi:'Hindi',
			hu:'Hungarian',
			is:'Icelandic',
			id:'Indonesian',
			ga:'Irish',
			it:'Italian',
			ja:'Japanese',
			ko:'Korean',
			lv:'Latvian',
			lt:'Lithuanian',
			mk:'Macedonian',
			ms:'Malay',
			mt:'Maltese',
			no:'Norwegian',
			fa:'Persian',
			pl:'Polish',
			pt:'Portuguese',
			// 'pt-pt':'Portuguese (Portugal)',
			ro:'Romanian',
			ru:'Russian',
			sr:'Serbian',
			sk:'Slovak',
			sl:'Slovenian',
			es:'Spanish',
			sw:'Swahili',
			sv:'Swedish',
			tl:'Tagalog',
			th:'Thai',
			tr:'Turkish',
			uk:'Ukrainian',
			vi:'Vietnamese',
			cy:'Welsh',
			yi:'Yiddish'
		}
	};

	/*
	Parses WebVTT format which should be formatted as
	================================
	WEBVTT

	1
	00:00:01,1 --> 00:00:05,000
	A line of text

	2
	00:01:15,1 --> 00:02:05,000
	A second line of text

	===============================

	Adapted from: http://www.delphiki.com/html5/playr
	*/
	mejs.TrackFormatParser = {
		webvtt: {
			pattern_timecode: /^((?:[0-9]{1,2}:)?[0-9]{2}:[0-9]{2}([,.][0-9]{1,3})?) --\> ((?:[0-9]{1,2}:)?[0-9]{2}:[0-9]{2}([,.][0-9]{3})?)(.*)$/,

			parse: function(trackText) {
				var
					i = 0,
					lines = mejs.TrackFormatParser.split2(trackText, /\r?\n/),
					entries = {text:[], times:[]},
					timecode,
					text,
					identifier;
				for(; i<lines.length; i++) {
					timecode = this.pattern_timecode.exec(lines[i]);

					if (timecode && i<lines.length) {
						if ((i - 1) >= 0 && lines[i - 1] !== '') {
							identifier = lines[i - 1];
						}
						i++;
						// grab all the (possibly multi-line) text that follows
						text = lines[i];
						i++;
						while(lines[i] !== '' && i<lines.length){
							text = text + '\n' + lines[i];
							i++;
						}
						text = $.trim(text).replace(/(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig, "<a href='$1' target='_blank'>$1</a>");
						// Text is in a different array so I can use .join
						entries.text.push(text);
						entries.times.push(
						{
							identifier: identifier,
							start: (mejs.Utility.convertSMPTEtoSeconds(timecode[1]) === 0) ? 0.200 : mejs.Utility.convertSMPTEtoSeconds(timecode[1]),
							stop: mejs.Utility.convertSMPTEtoSeconds(timecode[3]),
							settings: timecode[5]
						});
					}
					identifier = '';
				}
				return entries;
			}
		},
		// Thanks to Justin Capella: https://github.com/johndyer/mediaelement/pull/420
		dfxp: {
			parse: function(trackText) {
				trackText = $(trackText).filter("tt");
				var
					i = 0,
					container = trackText.children("div").eq(0),
					lines = container.find("p"),
					styleNode = trackText.find("#" + container.attr("style")),
					styles,
					text,
					entries = {text:[], times:[]};


				if (styleNode.length) {
					var attributes = styleNode.removeAttr("id").get(0).attributes;
					if (attributes.length) {
						styles = {};
						for (i = 0; i < attributes.length; i++) {
							styles[attributes[i].name.split(":")[1]] = attributes[i].value;
						}
					}
				}

				for(i = 0; i<lines.length; i++) {
					var style;
					var _temp_times = {
						start: null,
						stop: null,
						style: null
					};
					if (lines.eq(i).attr("begin")) _temp_times.start = mejs.Utility.convertSMPTEtoSeconds(lines.eq(i).attr("begin"));
					if (!_temp_times.start && lines.eq(i-1).attr("end")) _temp_times.start = mejs.Utility.convertSMPTEtoSeconds(lines.eq(i-1).attr("end"));
					if (lines.eq(i).attr("end")) _temp_times.stop = mejs.Utility.convertSMPTEtoSeconds(lines.eq(i).attr("end"));
					if (!_temp_times.stop && lines.eq(i+1).attr("begin")) _temp_times.stop = mejs.Utility.convertSMPTEtoSeconds(lines.eq(i+1).attr("begin"));
					if (styles) {
						style = "";
						for (var _style in styles) {
							style += _style + ":" + styles[_style] + ";";
						}
					}
					if (style) _temp_times.style = style;
					if (_temp_times.start === 0) _temp_times.start = 0.200;
					entries.times.push(_temp_times);
					text = $.trim(lines.eq(i).html()).replace(/(\b(https?|ftp|file):\/\/[-A-Z0-9+&@#\/%?=~_|!:,.;]*[-A-Z0-9+&@#\/%=~_|])/ig, "<a href='$1' target='_blank'>$1</a>");
					entries.text.push(text);
					if (entries.times.start === 0) entries.times.start = 2;
				}
				return entries;
			}
		},
		split2: function (text, regex) {
			// normal version for compliant browsers
			// see below for IE fix
			return text.split(regex);
		}
	};

	// test for browsers with bad String.split method.
	if ('x\n\ny'.split(/\n/gi).length != 3) {
		// add super slow IE8 and below version
		mejs.TrackFormatParser.split2 = function(text, regex) {
			var
				parts = [],
				chunk = '',
				i;

			for (i=0; i<text.length; i++) {
				chunk += text.substring(i,i+1);
				if (regex.test(chunk)) {
					parts.push(chunk.replace(regex, ''));
					chunk = '';
				}
			}
			parts.push(chunk);
			return parts;
		};
	}

})(mejs.$);

/*
* ContextMenu Plugin
* 
*
*/

(function($) {

$.extend(mejs.MepDefaults,
	{ 'contextMenuItems': [
		// demo of a fullscreen option
		{ 
			render: function(player) {
				
				// check for fullscreen plugin
				if (typeof player.enterFullScreen == 'undefined')
					return null;
			
				if (player.isFullScreen) {
					return mejs.i18n.t('Turn off Fullscreen');
				} else {
					return mejs.i18n.t('Go Fullscreen');
				}
			},
			click: function(player) {
				if (player.isFullScreen) {
					player.exitFullScreen();
				} else {
					player.enterFullScreen();
				}
			}
		}
		,
		// demo of a mute/unmute button
		{ 
			render: function(player) {
				if (player.media.muted) {
					return mejs.i18n.t('Unmute');
				} else {
					return mejs.i18n.t('Mute');
				}
			},
			click: function(player) {
				if (player.media.muted) {
					player.setMuted(false);
				} else {
					player.setMuted(true);
				}
			}
		},
		// separator
		{
			isSeparator: true
		}
		,
		// demo of simple download video
		{ 
			render: function(player) {
				return mejs.i18n.t('Download Video');
			},
			click: function(player) {
				window.location.href = player.media.currentSrc;
			}
		}	
	]}
);


	$.extend(MediaElementPlayer.prototype, {
		buildcontextmenu: function(player, controls, layers, media) {
			
			// create context menu
			player.contextMenu = $('<div class="mejs-contextmenu"></div>')
								.appendTo($('body'))
								.hide();
			
			// create events for showing context menu
			player.container.bind('contextmenu', function(e) {
				if (player.isContextMenuEnabled) {
					e.preventDefault();
					player.renderContextMenu(e.clientX-1, e.clientY-1);
					return false;
				}
			});
			player.container.bind('click', function() {
				player.contextMenu.hide();
			});	
			player.contextMenu.bind('mouseleave', function() {

				//
				player.startContextMenuTimer();
				
			});		
		},

		cleancontextmenu: function(player) {
			player.contextMenu.remove();
		},
		
		isContextMenuEnabled: true,
		enableContextMenu: function() {
			this.isContextMenuEnabled = true;
		},
		disableContextMenu: function() {
			this.isContextMenuEnabled = false;
		},
		
		contextMenuTimeout: null,
		startContextMenuTimer: function() {
			//
			
			var t = this;
			
			t.killContextMenuTimer();
			
			t.contextMenuTimer = setTimeout(function() {
				t.hideContextMenu();
				t.killContextMenuTimer();
			}, 750);
		},
		killContextMenuTimer: function() {
			var timer = this.contextMenuTimer;
			
			//
			
			if (timer != null) {				
				clearTimeout(timer);
				delete timer;
				timer = null;
			}
		},		
		
		hideContextMenu: function() {
			this.contextMenu.hide();
		},
		
		renderContextMenu: function(x,y) {
			
			// alway re-render the items so that things like "turn fullscreen on" and "turn fullscreen off" are always written correctly
			var t = this,
				html = '',
				items = t.options.contextMenuItems;
			
			for (var i=0, il=items.length; i<il; i++) {
				
				if (items[i].isSeparator) {
					html += '<div class="mejs-contextmenu-separator"></div>';
				} else {
				
					var rendered = items[i].render(t);
				
					// render can return null if the item doesn't need to be used at the moment
					if (rendered != null) {
						html += '<div class="mejs-contextmenu-item" data-itemindex="' + i + '" id="element-' + (Math.random()*1000000) + '">' + rendered + '</div>';
					}
				}
			}
			
			// position and show the context menu
			t.contextMenu
				.empty()
				.append($(html))
				.css({top:y, left:x})
				.show();
				
			// bind events
			t.contextMenu.find('.mejs-contextmenu-item').each(function() {
							
				// which one is this?
				var $dom = $(this),
					itemIndex = parseInt( $dom.data('itemindex'), 10 ),
					item = t.options.contextMenuItems[itemIndex];
				
				// bind extra functionality?
				if (typeof item.show != 'undefined')
					item.show( $dom , t);
				
				// bind click action
				$dom.click(function() {			
					// perform click action
					if (typeof item.click != 'undefined')
						item.click(t);
					
					// close
					t.contextMenu.hide();				
				});				
			});	
			
			// stop the controls from hiding
			setTimeout(function() {
				t.killControlsTimer('rev3');	
			}, 100);
						
		}
	});
	
})(mejs.$);
(function($) {
	// skip back button

	$.extend(mejs.MepDefaults, {
		skipBackInterval: 30,
		// %1 will be replaced with skipBackInterval in this string
		skipBackText: mejs.i18n.t('Skip back %1 seconds')
	});

	$.extend(MediaElementPlayer.prototype, {
		buildskipback: function(player, controls, layers, media) {
			var
				t = this,
				// Replace %1 with skip back interval
				backText = t.options.skipBackText.replace('%1', t.options.skipBackInterval),
				// create the loop button
				loop =
				$('<div class="mejs-button mejs-skip-back-button">' +
					'<button type="button" aria-controls="' + t.id + '" title="' + backText + '" aria-label="' + backText + '">' + t.options.skipBackInterval + '</button>' +
				'</div>')
				// append it to the toolbar
				.appendTo(controls)
				// add a click toggle event
				.click(function() {
					media.setCurrentTime(Math.max(media.currentTime - t.options.skipBackInterval, 0));
					$(this).find('button').blur();
				});
		}
	});

})(mejs.$);

/**
 * Postroll plugin
 */
(function($) {

	$.extend(mejs.MepDefaults, {
		postrollCloseText: mejs.i18n.t('Close')
	});

	// Postroll
	$.extend(MediaElementPlayer.prototype, {
		buildpostroll: function(player, controls, layers, media) {
			var
				t = this,
				postrollLink = t.container.find('link[rel="postroll"]').attr('href');

			if (typeof postrollLink !== 'undefined') {
				player.postroll =
					$('<div class="mejs-postroll-layer mejs-layer"><a class="mejs-postroll-close" onclick="$(this).parent().hide();return false;">' + t.options.postrollCloseText + '</a><div class="mejs-postroll-layer-content"></div></div>').prependTo(layers).hide();

				t.media.addEventListener('ended', function (e) {
					$.ajax({
						dataType: 'html',
						url: postrollLink,
						success: function (data, textStatus) {
							layers.find('.mejs-postroll-layer-content').html(data);
						}
					});
					player.postroll.show();
				}, false);
			}
		}
	});

})(mejs.$);

$(document).ready(function(){
	$('.mediaelement_audio,.mediaelement_video').mediaelementplayer();
});

/****** end css file: mediaelement-and-player.js ******/

/****** js file: ai_editmode.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/core/js/ai_editmode.js ******/
/****** last modified: 1463068306 (2016-05-12 10:51:46) ******/
//Samuel Larkin 2016.5.111
//Js to toggle edit mode on an off
var current_edit_mode_state = false;

function toggle_edit_view(toState)
{
	if(toState != null && toState == current_edit_mode_state)return;

	if(!current_edit_mode_state)
	{
		$('.ai_edit_toggle').each(function(){$(this).removeClass('ai_edit_toggle').addClass('ai_edit_toggle_off');});
		$('.ai_edit_toggle_border').each(function(){$(this).removeClass('ai_edit_toggle_border').addClass('ai_edit_toggle_border_off');});
		$('.dynalist_edit_off').each(function(){$(this).removeClass('dynalist_edit_off').addClass('dynalist_edit')});
		$('#edit_toggle_button').css('background-color','red');
		current_edit_mode_state = true;
	}
	else
	{
		$('.ai_edit_toggle_off').each(function() {$(this).removeClass('ai_edit_toggle_off').addClass('ai_edit_toggle');	});
		$('.ai_edit_toggle_border_off').each(function () {$(this).removeClass('ai_edit_toggle_border_off').addClass('ai_edit_toggle_border'); });
		$('.dynalist_edit').each(function(){$(this).removeClass('dynalist_edit').addClass('dynalist_edit_off')});
		$('#edit_toggle_button').css('background-color','transparent');
		current_edit_mode_state = false;
	}
}



$(document).ready(function(){
	$('#edit_toggle_button').show(0);
});

/****** end css file: ai_editmode.js ******/

/****** js file: ai_tracking.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/plugins/ai_tracking/ai_tracking.js ******/
/****** last modified: 1360217446 (2013-02-07 00:10:46) ******/

var ai_track_response = 'unused';
var ai_track_asynchronous = true; //set to false when calling this just before a form post or other dom-destroying event
function ai_track(event_name,key_type,key,owner_id,subkey,lead_tag_list,lead_status,lead_note)
{
	if(typeof(key_type)=='undefined') key_type='';
	if(typeof(key)=='undefined') key_type=0;
	if(typeof(owner_id)=='undefined') owner_id=0;
	if(typeof(subkey)=='undefined') subkey=0;
	if(typeof(lead_tag_list)=='undefined') lead_tag_list='';
	if(typeof(lead_status)=='undefined') lead_status='';
	if(typeof(lead_note)=='undefined') lead_note='';
	
	//current_url: everything after the first slash. So, like: reports/event_tracking
	current_page_request = window.location.href.replace(/^(?:\/\/|[^\/]+)*\//, "");

	$.ajax({
		async: ai_track_asynchronous,
	  url:'ai_tracking_trigger?event_name='+encodeURIComponent(event_name)+'&key_type='+encodeURIComponent(key_type)+'&key='+encodeURIComponent(key)+'&owner_id='+encodeURIComponent(owner_id)+'&subkey='+encodeURIComponent(subkey)+'&lead_tag_list='+encodeURIComponent(lead_tag_list)+'&lead_status='+encodeURIComponent(lead_status)+'&lead_note='+encodeURIComponent(lead_note)+'&current_page_request='+encodeURIComponent(current_page_request),
	  success: function(data){
	  	ai_track_response = data;
	  },
	  fail: function() { alert("error"); }
	});
}
/****** end css file: ai_tracking.js ******/

/****** js file: ai_ajax.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/plugins/ai_ajax/ai_ajax.js ******/
/****** last modified: 1408031264 (2014-08-14 10:47:44) ******/
$(document).ready(function(){
	// This is for links
	$(document).on("click", ".ai_ajax_container INPUT.cancel_button, .ai_ajax_container INPUT[type='button'].te, .ai_ajax_container a.te_ajax_link, .ai_ajax_container a.te, .ai_ajax_container a.te_asearch_link, .ai_ajax_container a.te_button, .ai_ajax_container a.te_fieldname", function(event){
		
		// Stop the normal event from firing
		event.preventDefault();
		
		// Define parameters
		var href = this.href;
		var onclick = $(this).data("onclick");
		
		// Determine parent container's ID
		var container_id = $(this).closest(".ai_ajax_container").attr("id");
		
		if(href !== undefined) {
			// This is a link, we should use it	
			ai_ajax_goto_link(href,{},"get",container_id);
		}
		
		if(onclick !== undefined) {
			// This is an onclick event and needs to be intercepted
			ai_ajax_goto_link(onclick,{},"get",container_id);
		}

		return false;
	})

	// This is for form submissions
	$(document).on("submit", ".ai_ajax_container FORM", function(event){
		
		// Stop the normal event from firing
		event.preventDefault();
		
		// Define parameters
		var action = $(this).attr('action');
  	var method = $(this).attr('method');
		var string = $(this).serialize();

		// Determine parent container's ID
		var container_id = $(this).closest(".ai_ajax_container").attr("id");
		
		if(action !== undefined) {
			
			// For some reason jquery's serialize function doesn't like the confirm delete form post, so, let's build it manually
			if(string == "") {
				// Indicator to know it was manual, as well as easy hack to not have to worry about the &
				string += "m";

				// get all the inputs into an array.
				$($(this).find(":input")).each(function() {
					string += "&" + $(this).attr("name") + "=" + $(this).val();
				});
			}
	
			ai_ajax_goto_link(action,string,method,container_id);
		}

		return false;
	})
	
	// Function to add class to links that are just in the table edit
	$(".ai_ajax_container a").each(function() {
		$(this).addClass("te_ajax_link");
	})
	
	// Unbind onclick events
	translate_onclicks();
});

// This removes onclick events from all onclicks, so, that the browser doesn't process them
function translate_onclicks()
{
	$(".ai_ajax_container INPUT.te, .ai_ajax_container INPUT.cancel_button").each(function() {
		var onclick = $(this).attr("onclick");
		if(onclick !== undefined) {
			onclick = onclick.match(/(window|document)[.]location\s*=\s*'([^']+)'/i);
			if(onclick[2] !== undefined) {
				$(this).attr("data-onclick",onclick[2]).attr("onclick",null).unbind();
			}
		}
	})
}

// This is the actual ajax functionality
function ai_ajax_goto_link(href,data,method,container_id)
{
	// Set opacity of container to show action
	$("#" + container_id).css({"opacity":"0.5"});

	console.log("Calling ai_ajax to go to: " + href);

	if(method == "post") {
		$.post(href,data,function(response){
			$("#" + container_id).css({"opacity":"1"}).html(response)
			translate_onclicks();
		}) 
	} else {
		$.get(href,data,function(response){
			$("#" + container_id).css({"opacity":"1"}).html(response)
			translate_onclicks();
		}) 
	}
}
/****** end css file: ai_ajax.js ******/

/****** js file: ajax.parallel.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/plugins/ajax/ajax.parallel.js ******/
/****** last modified: 1411149480 (2014-09-19 12:58:00) ******/
//j0zf 2006.3.12
//ajax.parallel.js
//my normal ajax.js library barfed on parallel requests because there was only 1 request object
/**
 * METHOD I:   ajax_get_request( ajax_url, ajax_handler, set_loading_id, forget_previous_requests )
 *	-- this method uses XMLHttpRequest() and processes commands
 *
 * METHOD II:  ajax_post_request( ajax_url, ajax_data, ajax_handler, set_loading_id, forget_previous_requests )
 *	-- this method uses XMLHttpRequest() and processes commands
 *	-- this method is better than ajax_get_request() when submitting a large amount of data
 *	-- data should be in url encoded format with escape()'d values ( e.g. variable1=value1&another_var=someother+value )
 *
 * METHOD III: ajax_call_js( unique_element_id, src_url, allow_reload_flag )
 *	-- this method immediatly runs as javascript the returned data
 *
 * AJAX CGI RETURN COMMANDS:
 *	-- Format:  ajax command|cgi returned ajax data
 *	-- by default the "ajax command" is just the "element id" who's innerHTML will be replaced
 *	   by the "cgi returned ajax data" text or html.
 *
 * SPECIAL CGI RETURN COMMANDS:
 *	-- ajax_error : reports error string
 *		* if the "ajax_error" element id is available then it will replace it's innerHTML with
 *		  the error text "cgi returned ajax data".
 *		* if the "ajax_error" element id is not available then it will do an alert('cgi returned ajax data / error text');
 *	-- ajax_run_script : will eval('cgi returned ajax data / javascript');
 *
 */

//USED TO SYNCHRONIZE THE PARALLEL ARRAYS
var ajax_requests_count = 0;

//AN ARRAY THAT CONTAINS THE REQUESTED AJAX OBJECTS
var ajax_requests = new Array();

//KEEP TRACK OF HANDLERS SO WE DISPATCH THE CORRECT ONE
//parallel array to ajax_requests
var ajax_handlers = new Array();

function ajax_createRequestObject( ajax_handler )
{
	var i = ajax_requests_count++;
    var ajax_http;
    var browser = navigator.appName;

	//CREATE THE AJAX REQUEST OBJECT
	if( browser == "Microsoft Internet Explorer" && window.ActiveXObject )
	{
        ajax_http = new ActiveXObject("Microsoft.XMLHTTP");
    }
	else
	{
        ajax_http = new XMLHttpRequest();
    }

	//SETUP THE HANDLER DISPATCHER
	ajax_http.onreadystatechange = ajax_handler_dispatcher;

	//ADD THE HANDLER
	if( ajax_handler == null )
	{
		ajax_handlers[i] = ajax_handler_default;
	}
	else
	{
		ajax_handlers[i] = ajax_handler;
	}

	//ADD THE REQUEST OBJECT
	ajax_requests[i] = ajax_http;
    return ajax_http;
}

function ajax_handler_dispatcher()
{
	var i = 0;
	var ajax_http = null;
	var ajax_handler = null;

	if( ajax_requests_count < 1 ) return;

	for( i = (ajax_requests_count - 1); i >= 0; i-- )
	{
		if( ajax_requests[i] && ajax_handlers[i] && ajax_requests[i].readyState == 4 )
		{
			ajax_http = ajax_requests[i];
			ajax_requests[i] = null;
			ajax_handler = ajax_handlers[i];
			ajax_handlers[i] = null;

			if ( ajax_http.status == 200 )
			{
				//alert( 'RESPONSE TEXT:[' + ajax_http.responseText + ']' );
				ajax_handler( ajax_http );
			}
			else if ( ajax_http.status == 403 && ajax_http.statusText == "Logged Out" )
			{
				window.location = 'login.php';
			}
			else
			{
				ajax_report_error( 'Ajax Error - Status Code: "' + ajax_http.status + '" Status Text: "' + ajax_http.statusText + '".' );
			}
		}
	}
}

//FORGET ALL PREVIOUS AJAX REQUESTS
function ajax_forget_requests()
{
	ajax_requests_count = 0;
	ajax_requests = new Array();
	ajax_handlers = new Array();
}

//VERY SIMPLE TO USE DEFAULT HANDLER
//CUSTOM HANDLERS CAN BE SPECIFIED WHEN MAKING THE REQUESTS
//Make requests by:
//  ajax_get_request( ajax_url, ajax_handler, set_loading_id, forget_previous_requests )
//  or
//  ajax_post_request( ajax_url, ajax_data, ajax_handler, set_loading_id, forget_previous_requests )
function ajax_handler_default( ajax_http )
{
	var sep_loc = ajax_http.responseText.indexOf( '|' );
	var response_name = '';
	var response_value = '';

	if( sep_loc > 0 )
	{
		response_name = ajax_trim_str( ajax_http.responseText.substr( 0, sep_loc ) );
		response_value = ajax_http.responseText.substr( 1 + sep_loc );

		if( response_name == 'ajax_error' )
		{
			//REPORT THE ERROR
			ajax_report_error( response_value );
		}
		else if( response_name == 'ajax_run_script' )
		{
			ajax_run_script( response_value );
		}
		else
		{
			//WRITE THE RESPONSE TO THE SPECIFIED ELEMENT
			if( ajax_set_value( response_name, response_value ) )
			{
				ajax_clear_error();
			}
			else
			{
				ajax_report_error( 'Error: Ajax Element Not Found (' + response_name + ').' );
			}
		}
	}
	else
	{
		ajax_report_error( 'Error: Invalid Ajax Response.' );
	}
}

function ajax_report_error( str )
{
	var ajerr = document.getElementById('ajax_error');
	/*if ( ai.visor )
	{
		ai.visor.set(str);
		ai.visor.show();
	}
	else if ( ai.toaster )
	{
		ai.toaster.set(str);
		ai.toaster.show();
	}*/
	if ( ai.notification )
	{
		ai.notification.error("AJAX Error", str, true);
	}
	else if ( ajerr )
	{
		ajerr.innerHTML = str;
	}
	else
	{
		alert( str );
	}
}

function ajax_clear_error()
{
	var ajerr = document.getElementById('ajax_error');
	if( ajerr )
	{
		ajerr.innerHTML = "";
	}
}

function ajax_run_script( str )
{
	eval(str);
}

function ajax_trim_str( str )
{
   str = str.replace(/^\s+/, '');
   str = str.replace(/\s+$/, '');
   return str;
}

/**
 * SET LOADING IMAGE
 */
function ajax_set_loading( loading_id )
{
	loading_id = document.getElementById( loading_id );
	if(loading_id)
	{
		loading_id.innerHTML = '<div class="ajax_loading_icon"><span class="ajax_loading_icon">Loading...</span></div>';
	}
}

/**
 * GET AN ELEMENTS VALUE.... Never mind the element's type...
 * -- add types as needed..
 * -- Not currently supported:
 *		- radio buttons
 *		- select tags with "multselect" enabled
 *		- and more...
 */
function ajax_get_value( element_id )
{
	var e = document.getElementById( element_id );
	var v = '';
	if( !e ){ return null; }

	switch( e.tagName.toUpperCase() )
	{
		case 'INPUT':
			switch( e.type.toUpperCase() )
			{
				case 'TEXT':
					v = e.value;
					break;
				case 'HIDDEN':
					v = e.value;
					break;
				case 'CHECKBOX':
					v = ( e.checked ? e.value : '' );
					break;
				default:
					v = e.value;
					break;
			}
			break;
		case 'TEXTAREA':
			v = e.value;
			break;
		case 'SELECT':
			v = e.options[ e.selectedIndex ].value;
			break;
		default:
			v = e.innerHTML;
			break;
	}

	return v;
}

/**
 * SET AN ELEMENTS VALUE.... Never mind the element's type...
 * -- add types as needed..
 */
function ajax_set_value( element_id, v )
{
	var e = document.getElementById( element_id );
	if( !e ){ return null; }

	switch( e.tagName.toUpperCase() )
	{
		case 'INPUT':
			switch( e.type.toUpperCase() )
			{
				case 'TEXT':
					e.value = v;
					break;
				default:
					e.value = v;
					break;
			}
			break;
		default:
			e.innerHTML = v;
			break;
	}

	return v;
}

/**
 * CALL A JAVASCRIPT FILE
 *	-- yes this can have a PHP or other CGI extension ( .js not required )
 *	-- Output will be ran as Javascript
 *
 *	unique_element_id : mangle away.. make it origninal to the page
 *	allow_reload_flag : if true then unique_element_id may be replaced by a new script load
 *
 */
function ajax_call_js( unique_element_id, src_url, allow_reload_flag )
{
	if( !allow_reload_flag && document.getElementById( unique_element_id ) )return;

	var head = document.getElementsByTagName('head').item(0);
	var script = document.createElement('script');
	script.src = src_url;
	script.type = 'text/javascript';
	script.language = 'javascript';
	script.id = unique_element_id;
	head.appendChild(script);
}

/**
 * USE "GET" METHOD TO MAKE HTTP REQUEST
 * ajax_handler : This is the function which will handle the request when retured as success
 * set_loading_id : (optional) This is the element id who's innerHTML will be replaced by the loading icon
 * forget_previous_requests : Destroys the handler queue before making request
 *
 */
function ajax_get_request( ajax_url, ajax_handler, set_loading_id, forget_previous_requests )
{
	if( !ajax_handler ){ ajax_report_error( 'Error: Invalid Ajax Handler Javascript Function.' ); return; }
	if( forget_previous_requests == true ){ ajax_forget_requests(); }
	if( set_loading_id && set_loading_id != '' ){ ajax_set_loading( set_loading_id ); }

	var ajax_http = ajax_createRequestObject( ajax_handler );

    ajax_http.open( 'get', ajax_url );
	ajax_http.send( null );
}

/**
 * USE "POST" METHOD TO MAKE HTTP REQUEST
 * ajax_data : Contains the POST data.
 *	-- this method is better than ajax_get_request() when submitting a large amount of data
 *	-- data should be in url encoded format with escape()'d values ( e.g. variable1=value1&another_var=someother+value )
 * ajax_handler : This is the function which will handle the request when retured as success
 * set_loading_id : (optional) This is the element id who's innerHTML will be replaced by the loading icon
 * forget_previous_requests : Destroys the handler queue before making request
 *
 */
function ajax_post_request( ajax_url, ajax_data, ajax_handler, set_loading_id, forget_previous_requests )
{
	if( !ajax_handler ){ ajax_report_error( 'Error: Invalid Ajax Handler Javascript Function.' ); return; }
	if( forget_previous_requests == true ){ ajax_forget_requests(); }
	if( set_loading_id && set_loading_id != '' ){ ajax_set_loading( set_loading_id ); }

	var ajax_http = ajax_createRequestObject( ajax_handler );

    ajax_http.open( 'post', ajax_url );
    ajax_http.setRequestHeader( 'Content-Type', 'application/x-www-form-urlencoded' );
	ajax_http.send( ajax_data );
}

/**
 * Ajax Handler that expects a JSON string in the response representing a JavaScript object
 * This function is intended to be an alternative to ajax_handler_default()
 * and handles multiple script/error/DOM-inserts
 * Parsing is done using an external JSON parser library (included) and thus
 * should not encounter security issues presented when using the simple eval() approach
 *
 * Each object member is the ID of the HTML element in the DOM (no error is displayed if not found)
 * Each object member's values will be placed into their respective HTML elements
 * Because there are multiple instances, this will not throw errors if
 *
 * - JonJon <jon@apogeeinvent.com> 2009.05.10
 */
function ajax_handler_JSON(ajax_http)
{
	// Legacy error handling found: go backward to ajax_handler_default()
	if ( ajax_http.responseText.match(/^\s*ajax_error\|/) )
	{
		return ajax_handler_default(ajax_http);
	}
	try
	{
		var obj = JSON.parse(ajax_http.responseText); // throws errors
		for ( var key in obj )
		{
			// An error occured, stop everything now!
			if ( key == "ajax_error" )
			{
				ajax_report_error(obj[key]);
				return;
			}
			// Found a run command
			else if ( key == "ajax_run_script" )
			{
				ajax_run_script(obj[key]);
			}
			// Insert into the DOM
			else
			{
				ajax_set_value(key, obj[key])
			}
		}
		ajax_clear_error();
	}
	catch ( e )
	{
		ajax_report_error("Error: Could not parse JSON response");
	}
}

/**
 * Ajax Handler that expects to do nothing and will do nothing
 *
 * - JonJon <jon@apogeeinvent.com> 2009-09-04
 */
function ajax_handler_noop() { }

/****** end css file: ajax.parallel.js ******/

/****** js file: jquery.jonbox.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/plugins/jonbox/jquery.jonbox.js ******/
/****** last modified: 1445445038 (2015-10-21 11:30:38) ******/
/**
 * jquery.jonbox.js
 *  ~ Jon ????.??.??
 *  ~ JosephL 2008.10.24
 *
 * jQuery needs to be included on the page including this script... v 1.2.6 or higher
 *
 * 2008.10.24
 *  - Added jonbox alert
 *  - Added jonbox form
 *  - Uses ai javascript.parallel.js now
 *  - Tested working, IE6, IE7, FireFox(OS X), Safari(OS X), Opera(OS X)
 *
 * 2008.10.26
 *  - Added re-positioning support, now finds position bassed off of viewport
 *  - Added better resize/scroll support
 *  - Added jonbox_open_div
 *
 * 2008.10.27
 *  - Added jonbox_open_img
 *
 * 2008.11.05
 *  - Add feature to hide all elements with class="jonbox_hide" when jonbox is active
 *    and show when jonbox is closed
 **/
var jonbox_close_image = "includes/plugins/jonbox/images/jonbox_close.png";
var jonbox_close_hot_image = "includes/plugins/jonbox/images/jonbox_close_hot.png";
var jonbox_loading_image = "includes/plugins/jonbox/images/jonbox_loading.gif";

/** var bool Set to TRUE at anytime to make JonBox a non-closeable, persistent pop-up */
var jonbox_persistent = false;

if(typeof jQuery!='undefined') {
	$(document).ready(init_jonbox);
} else {
	// alert('Error: jonbox requires jQuery to be included.');
}

/**
 * Sets up the hidden div to display the jonbox
 * Also binds the click to all "a" objects withs rel="jonbox"
 **/
function init_jonbox(e)
{
	init_links();

	var img1 = new Image();
	img1.src = jonbox_close_image;

	var img2 = new Image();
	img2.src = jonbox_close_hot_image;

	var img_load = new Image();
	img_load = jonbox_loading_image;

	if($('#jonbox_jblock').length <= 0) {
		$("<div />").attr("id", "jonbox_jblock").appendTo("body").hide().css({
			backgroundColor: "#000",
			opacity: 0,
			width: "100%",
			position: "absolute",
			left: 0,
			top: 0,
			zIndex: 600
		}).click(close_jonbox);
	}
	// .click(close_jonbox) // append to above call to enable clicking outside the box to close.

	if($('#jonbox_loading').length <= 0) {
		$("<div />").attr("id", "jonbox_loading").appendTo("body").hide().css({
			backgroundColor:"#656565",
			color: "#f0f0f0",
			fontFamily: "'Lucida Grande', Arial, Helvetica, sans-serif",
			fontSize: "1.5em",
			fontWeight: 700,
			position: "absolute",
			left: "-9999px",
			top: "-9999px",
			zIndex: 700,
			border: "solid 2px #3F3F3F",
			padding: "5px 10px 5px 10px"
		}).html($("<img />").attr({
			src: jonbox_loading_image,
			alt: "Loading",
			title: "Loading"
		})).click(close_jonbox); // If error occurs, they can click loading to get out of jonbox
	}

	if($('#jonbox').length <= 0) {
		$("<div />").attr("id", "jonbox").appendTo("body").hide().css({
			backgroundColor: "#f0f0f0",
			opacity: 0,
			position: "absolute",
			left: 0,
			top: 0,
			zIndex: 1000,
			"border-radius": "10px",
			"border": "2px solid #ccc",
			"box-shadow": "2px 2px 10px #000"
		});
	}

	if($('#jonbox_titlebar').length <= 0) {
		$("<div />").attr("id", "jonbox_titlebar").appendTo("#jonbox").css({
			//background: "transparent url(includes/plugins/jonbox/images/title_bar_bg.png) repeat-x -15px bottom",
			textAlign: "right",
			padding: "3px",
			"border-radius": "10px 10px 0 0"
		});
	}

	if($('#jonbox_content').length <= 0) {
		$("<div />").attr("id", "jonbox_content").appendTo("#jonbox").css({
			background: "#ffffff",
			padding: "15px",
			"border-radius": "0 0 10px 10px"
		});
	}

	// only append if it does not exist already
	if($('#jonbox_close_x').length <= 0) {
		$("<img />").attr({
			src: jonbox_close_image,
			alt: "x",
			title: "Close"
		}).attr('id', 'jonbox_close_x').css({
			cursor: "pointer"
		}).hover(function () {
			this.src = jonbox_close_hot_image;
		}, function () {
			this.src = jonbox_close_image;
		}).appendTo("#jonbox_titlebar").click(close_jonbox);
	}

	if ( $("#jonbox_quick_content").length <= 0 ) {
		$("<div />").attr("id", "jonbox_quick_content").appendTo("body").hide();
	}
}

function init_links()
{
	/*$("a").each(function(i) {
		if ( $(this).attr("rel") == "jonbox" ) {
			$(this).bind("click", {aobj: this}, open_jonbox_from_object);
		}
	});*/

	// Traditional rel="jonbox" anchors
	$("body").on("click",'a[rel="jonbox"]',function(e) {
		e.data = {aobj:this};
		open_jonbox_from_object(e);
		return false;
	});

	// Delegated rel="jonbox_delegated" anchors
	// -----
	// The actual event is handled by the DOM element with rel="jonbox_delegator"
	// This will allow AJAX drawn anchors with rel="jonbox_delegated" to fire open_jonbox()
	// even after initial page load when contained inside the rel="jonbox_delegator" element
	$('[rel="jonbox_delegator"]').on("click", 'a[rel="jonbox_delegated"]', function( e ) {
		e.data = {aobj:this};
		open_jonbox_from_object(e);
		return false;
	});
}

/**
 * Opens a jonbox from a "a href=" object.
 *
 * @param: e : the object
 **/
function open_jonbox_from_object(e)
{
	e.preventDefault();
	var opts = {};
	if ( $(e.data.aobj).data("jonboxWidth") ) {
		opts.width = $(e.data.aobj).data("jonboxWidth");
	}
	if ( $(e.data.aobj).data("jonboxHeight") ) {
		opts.height = $(e.data.aobj).data("jonboxHeight");
	}
	return open_jonbox(e.data.aobj.href, "", opts);
}

/**
 * Opens a jonbox, retiving the content via. ajax.parallel and handling it properly for
 * the jonbox system
 *
 * @param: url : the url to retive & display
 * @param: post_str OPTIONAL: post string to submit with the http call using post
 **/
function open_jonbox(url, post_str, opts)
{
	$("#jonbox_jblock").css({
		height: $(document).height()
	}).show(1, function() {
		$(this).animate({
			opacity: 0.50
		}, 200, null, function() {
			show_loading();
			if ( $.isPlainObject(opts) ) {
				if ( typeof opts.width != "undefined" ) {
					$("#jonbox_content").css({"width":opts.width});
				} else {
					$("#jonbox_content").css({"width":"auto"});
				}
				if ( typeof opts.height != "undefined" ) {
					$("#jonbox_content").css({"height":opts.height});
				} else {
					$("#jonbox_content").css({"height":"auto"});
				}
			}
			// use AI ajax handler instead of jQuery handler
			if(typeof post_str == "undefined" || post_str == "") {
				ajax_get_request(url, jonbox_ajax_call_return);
			} else {
				ajax_post_request(url, post_str, jonbox_ajax_call_return);
			}
		});
	});
	return false;
}

/**
 * Handles AI standard ajax returns better
 * Displays results nicely in the jonbox
 **/
function jonbox_ajax_call_return( ajax_http )
{
	var sep_loc = ajax_http.responseText.indexOf( '|' );
	var response_name = '';
	var response_value = '';

	if( sep_loc > 0 && sep_loc < 256 )
	{
		response_name = ajax_trim_str( ajax_http.responseText.substr( 0, sep_loc ) );
		response_value = ajax_http.responseText.substr( 1 + sep_loc );

		if( response_name == 'ajax_error' )
		{
			//REPORT THE ERROR
			var err_msg = '<table><tr><td valign="top" style="padding-right:20px;"><img src="includes/plugins/jonbox/images/alert_red_48.png" style="align:left;margin-left:20x;" align="left" /></td>';
			err_msg +='<td style="width:400px;color:#FF0000;">';
			err_msg += response_value + '<br><div style="text-align:right;padding-left:10px;height:20px;"><input type="button" onclick="close_jonbox()" value="OK"></div></td>';
			$("#jonbox_content").html(err_msg);
		}
		else if( response_name == 'ajax_run_script' )
		{
			close_jonbox();
			ajax_run_script( response_value );
		}
		else
		{
			// Ingore the set location and set the response as the content.
			$("#jonbox_content").html(response_value);
		}
	}
	else
	{
		// jonbox support full page fetches, no error in this case
		$("#jonbox_content").html(ajax_http.responseText);
	}

	$.event.trigger({
		type: "jonbox-ajaxStop",
		message: "JonBox has finished AJAX",
		time: new Date()
	});

	// Everything is ready, show the jonbox!
	show_jonbox();
}

/**
 * Hides the loading icon then animates in the the jonbox
 **/
function show_jonbox(hide_frame_and_maximize)
{
	// Set any special items with class jonbox_hide to be hidden
	// These items may interfear with the jonbox
	$('.jonbox_hide').css('visibility','hidden');

	$.event.trigger({
		type: "jonbox-showStart",
		message: "JonBox is beginning to show",
		time: new Date()
	});

	// Show the jobbox with full content
	$("#jonbox_loading").fadeOut("fast", function() {
		$("#jonbox").show(1, function() {
			position("jonbox");
			var top = $(this).css('top');
			top = parseInt(top);
			$(this).css({
				top: (top - 20) + "px"
			}).animate({
				top: (top + 20) + "px",
				opacity: 1
			}, 300);

			if(hide_frame_and_maximize == true) {
				// Special logic to hide frame
				if($('#jonbox').length > 0) {
					$("#jonbox").css({
						background: "none",
						width: "90%",
						height: "90%",
						"border-radius": "0px",
						"border": "none",
						"box-shadow": "none"
					});
				}
				if($('#jonbox_content').length > 0) {
					$("#jonbox_content").css({
						padding: 0
					});
				}
			} 
			else {
				// Reset jonbox next time, this is the same as init, so, if init changes, this needs to change as well
				// This was removed because it was causing nondesired behavior, where the jonbox would move from the left side of the screen instead of the top
			/*	if($('#jonbox').length > 0) {
					$("#jonbox").css({
						backgroundColor: "#f0f0f0",
						opacity: 0,
						position: "absolute",
						left: 0,
						top: 0,
						width: "auto",
						height: "auto",
						zIndex: 1000,
						"border-radius": "10px",
						"border": "2px solid #ccc",
						"box-shadow": "2px 2px 10px #000"
					});
				}*/

				if($('#jonbox_content').length > 0) {
					$("#jonbox_content").css({
						background: "#ffffff",
						padding: "15px",
						"border-radius": "0 0 10px 10px"
					});
				}
			}

			// Go Ahead and reposition
			jonbox_reposition_resize();

			$(window).resize(jonbox_reposition_resize).scroll(jonbox_reposition_scroll);

			$.event.trigger({
				type: "jonbox-showComplete",
				message: "JonBox is finished showing",
				time: new Date()
			});

			// Logic to make dynamic areas work as expected
			if ( typeof disable_all_dynamic_areas_not_part_of_jonbox != "undefined" ) {
				disable_all_dynamic_areas_not_part_of_jonbox();
			}
			timeout = setTimeout('build_dyna_area_elements(); update_dynamic_areas_NOW()', 500);
		});
	});
}

function show_loading()
{
	position("jonbox_loading");
	$("#jonbox_loading").fadeIn("fast");
}

function position(div_id)
{
	set_position(div_id, false);
}

/**
 * bounded to window resize event, move the jonbox
 **/
var reposition_active = false;
var scroll_x = 0;
var scroll_y = 0;
var vp_x = 0;
var vp_y = 0;
function jonbox_reposition_resize(e)
{
	// Get active window
	var win = get_window_sizes();
	scroll_offset_x = win.scroll_offset_x;
	scroll_offset_y = win.scroll_offset_y;
	vp_width = win.vp_width;
	vp_height = win.vp_height;

	// If it does not match, then the effect is still in play
	// IE only, if other browser run the event because scroll
	// and resize trigger once rather than over and over
	if(navigator.userAgent.indexOf("MSIE") == -1 || (
		win.scroll_offset_x == scroll_x
		&& win.scroll_offset_y == scroll_y
		&& win.vp_width == vp_x
		&& win.vp_height == vp_y)) {
			// Matched, so re-position the window
			$("#jonbox_jblock").css({
				height: $(document).height()
			});
			set_position('jonbox', true);
		}
		else {
			reposition_active = true;
			scroll_x = win.scroll_offset_x;
			scroll_y = win.scroll_offset_y;
			vp_x = win.vp_width;
			vp_y = win.vp_height;
		}
}

var timer = false;
function jonbox_reposition_scroll(e)
{
	// Get active window
	var win = get_window_sizes();
	scroll_offset_x = win.scroll_offset_x;
	scroll_offset_y = win.scroll_offset_y;
	vp_width = win.vp_width;
	vp_height = win.vp_height;

	// If it does not match, then the effect is still in play
	if(win.scroll_offset_x == scroll_x
		&& win.scroll_offset_y == scroll_y
		&& win.vp_width == vp_x
		&& win.vp_height == vp_y) {
			// Matched, so re-position the window
			$("#jonbox_jblock").css({
				height: $(document).height(),
				width: $(document).width()
			});
			set_position('jonbox', true);
			timer = false;
		}
		else {
			reposition_active = true;
			scroll_x = win.scroll_offset_x;
			scroll_y = win.scroll_offset_y;
			vp_x = win.vp_width;
			vp_y = win.vp_height;
			// timeout and try again (only once)
			// some browswer act like they are trying over and over but never
			// successed in running the effect
			if(!timer) {
				setTimeout(jonbox_reposition_scroll, 400);
				timer = true;
			}
		}
}

/**
 * Positions the jonbox (1/3 centering vertically, absolute centering horizontally)
 * param string div_id  the id of the jonblock
 * 2008.01.08 - If box height is greater than 1/3 center viewing space, simplay display 25 pixles down ~JosephL
 * 2008.10.26 - Taken from jonbox 1.0, added animation effects ~ JosephL
 * returns void
 */
function set_position(div_id, animate)
{
	var jonbox = document.getElementById(div_id);
	
	var scroll_offset_x, scroll_offset_y, vp_width, vp_height, jonbox_height, jonbox_width;

	var win = get_window_sizes();
	scroll_offset_x = win.scroll_offset_x;
	scroll_offset_y = win.scroll_offset_y;
	vp_width = win.vp_width;
	vp_height = win.vp_height;

	// Computer jonbox dimensions
	jonbox_height = jonbox.offsetHeight;
	jonbox_width = jonbox.offsetWidth;

	// Set the CSS to position the jonbox - x axis
	var jonbox_x = parseInt((vp_width - jonbox.offsetWidth) / 2 + scroll_offset_x);
	
	// Set the CSS to position the jonbox - y axis
	var jonbox_y = 0;
	var static_pos = false;

	if(jonbox_height+25 > vp_height)
	{
		// display 25 from top of viewport
		if(jonbox.style.top == "0pt" || jonbox.style.top == "0" ||jonbox.style.top == "0px")
		{
			jonbox_y = parseInt(25 + scroll_offset_y);
		}
		else
		{
			static_pos = true;
		}
	}
	else if(jonbox_height > (vp_height - ( vp_height * (1/3) )))
	{
		// this box is bigger than 1/3 the viewport!  Simply 25 pixles down from screen
		jonbox_y = parseInt(25 + scroll_offset_y);
	}
	else
	{
		// display 1/3 centering vertically
		jonbox_y = parseInt((2 * vp_height - 3 * jonbox_height) / 6 + scroll_offset_y);
	}

	if (jonbox_y < 25) { jonbox_y = 25; }
	
	if(!static_pos)
	{
		// both X and Y
		if(animate) {
			$("#" + div_id).animate({
				top: jonbox_y + "px",
				left: jonbox_x + "px"
			}, 200, "swing");
		} else {
			jonbox.style.top = jonbox_y + "px";
			jonbox.style.left = jonbox_x + "px";
		}
	}
	else {
		// only X
		if(animate) {
			$("#" + div_id).animate({
				left: jonbox_x + "px"
			}, 200, "swing");
		}
		else {
			jonbox.style.left = jonbox_x + "px";
		}
	}
};

/**
 * return JSON literal contating scroll offsets & viewport information
 * multi-browser support
 **/
function get_window_sizes()
{
	// Compute scroll offsets for different browsers
	if (self.pageYOffset)
	{
		scroll_offset_x = self.pageXOffset;
		scroll_offset_y = self.pageYOffset;
	}
	else if (document.documentElement && document.documentElement.scrollTop)
	{
		scroll_offset_x = document.documentElement.scrollLeft;
		scroll_offset_y = document.documentElement.scrollTop;
	}
	else if (document.body)
	{
		scroll_offset_x = document.body.scrollLeft;
		scroll_offset_y = document.body.scrollTop;
	}

	// Computer viewport dimensions of different browsers
	if (self.innerHeight)
	{
		vp_width = self.innerWidth;
		vp_height = self.innerHeight;
	}
	else if (document.documentElement && document.documentElement.clientHeight)
	{
		vp_width = document.documentElement.clientWidth;
		vp_height = document.documentElement.clientHeight;
	}
	else if (document.body)
	{
		vp_width = document.body.clientWidth;
		vp_height = document.body.clientHeight;
	}


	return {'scroll_offset_y':scroll_offset_y, 'scroll_offset_x':scroll_offset_x, 'vp_width':vp_width, 'vp_height':vp_height};
}
/**
 * Helper function to display jonbox_display_message, for compatibility
 * @param: msg : html or plain txt message to display
 **/
function jonbox_alert(msg)
{
	jonbox_display_message(msg,"alert");
}

/**
 * Helper function to display jonbox_display_message, for compatibility
 * @param: msg : html or plain txt message to display
 **/
function jonbox_info(msg)
{
	jonbox_display_message(msg,"information");
}

/**
 * Helper function to display jonbox_display_message, for compatibility
 * @param: msg : html or plain txt message to display
 **/
function jonbox_checkmark(msg)
{
	jonbox_display_message(msg,"check");
}

/**
 * Prompts the user with a message in a pretty fashion.
 * @param: msg : html or plain txt message to display
 **/
function jonbox_display_message(msg,type)
{
	var full_msg = '<table><tr><td valign="top" style="padding-right:20px;">';

	// Switch to determine what icon to display

	switch(type) {
		case "check":
			full_msg += '<img src="includes/plugins/jonbox/images/check_mark_48.png" style="align:left;margin-left:20px;width:48px;height:48px;border:0;" align="left" />';
			break;
		case "danger":
			full_msg += '<img src="includes/plugins/jonbox/images/alert_red_48.png" style="align:left;margin-left:20px;width:48px;height:48px;border:0;" align="left" />';
			break;
		case "information":
			full_msg += '<img src="includes/plugins/jonbox/images/information.svg" style="align:left;margin-left:20px;width:48px;height:48px;border:0;" align="left" />';
			break;
		default:
			full_msg += '<img src="includes/plugins/jonbox/images/alert_yellow.svg" style="align:left;margin-left:20px;width:48px;height:48px;border:0;" align="left" />';
			break;
	}

	full_msg += '</td>';
	full_msg +='<td style="width:400px">';
	full_msg += msg + '<br><div style="text-align:right;padding-left:10px;height:20px;"><input type="button" onclick="close_jonbox()" value="OK"></div></td>';
	$("#jonbox_jblock").css({
		height: $(document).height()
	}).show(1, function() {
		$(this).animate({
			opacity: 0.60
		}, 100, null, function() {
			$("#jonbox_content").html(full_msg);
			show_jonbox();
		});
	});
	return false;
}


/**
 * Given form elements, and a callback funtions.  Create a pop-up that wants users input
 *
 * @param: form_id : string, the id of an element where the inner contents are the form elements to display
 * @param: passed_callback : function, the function to call once the user submits the form, returns true/false
 *          if return is true, closes the jonbox, if false, keep it open
 * @example:
 *  <div id="test_form_contents"><input type="text" name="test_input"/></div>
 *  <script> function callback_test(frm){...} </script>
 *  TO CALL: jonbox_form('test_corm_contents', callback_test);
 **/
var callback = '';
function jonbox_form(form_id, passed_callback)
{
	show_loading();

	tagtype = $('#'+form_id).prop("tagName");
	var form = (tagtype.toLowerCase()=='textarea')? $('#'+form_id).val():$('#'+form_id).html();
	callback = passed_callback;

	var full_form = '';
	full_form += '<form name="jonbox_form" action="#" method="GET" onSubmit="if(callback(this)){close_jonbox();}return false;">';
	full_form += '<p id="jonbox_form_error" style="color:#FF0000;font-weight:bold;"></p>';
	full_form += form;
	full_form += '<br><div style="text-align:right;padding-top:10px;"><input type="button" onclick="close_jonbox()" value="Cancel">';
	full_form += '&nbsp;<input type="submit" value="Submit"></div></td>';
	full_form += '</form>';
	$("#jonbox_jblock").css({
		height: $(document).height()
	}).show(1, function() {
		$(this).animate({
			opacity: 0.60
		}, 100, null, function() {
			$("#jonbox_content").html(full_form);
			show_jonbox();
		});
	});

	return false;
}

/**
 * Given form elements, and a callback funtions.  Create a pop-up that wants users input
 *
 * @param: form_id : string, the id of an element where the inner contents are the form elements to display
 * @param: passed_callback : function, the function to call once the user submits the form, returns true/false
 *          if return is true, closes the jonbox, if false, keep it open
 * @example:
 *  <div id="test_form_contents"><input type="text" name="test_input"/></div>
 *  <script> function callback_test(frm){...} </script>
 *  TO CALL: jonbox_form('test_corm_contents', callback_test);
 **/
var callback = '';
function jonbox_full_form(form_id, passed_callback)
{
	var full_form = $('#'+form_id).html();
	callback = passed_callback;

	$("#jonbox_jblock").css({
		height: $(document).height()
	}).show(1, function() {
		$(this).animate({
			opacity: 0.60
		}, 100, null, function() {
			$("#jonbox_content").html(full_form);
			show_jonbox();
		});
	});
	return false;
}

/**
 * Display the contents of a div in a jonbox (more jonbox 1.0 style)
 *
 * @param: div_id : the id of the div whos content will be displayed
 **/
function jonbox_open_div(div_id,hide_frame_and_maximize)
{
	var div_contents = $("#"+div_id).html();
	// Convert the original divs html to be text
	$("#"+div_id).addClass("jonbox_converted_to_text").text(div_contents).html();

	$("#jonbox_jblock").css({
		height: $(document).height()
	}).show(1, function() {
		$(this).animate({
			opacity: 0.60
		}, 100, null, function() {
			$("#jonbox_content").data("jonbox_original_div",div_id).html(div_contents);
			show_jonbox(hide_frame_and_maximize);
		});
	});
}

/**
 * Starts loading an image, once loaded displays the jonbox
 *
 * @param: img_src : the source of the image
 **/
var image = null;
function jonbox_open_img(img_src)
{
	$("#jonbox_jblock").css({
		height: $(document).height()
	}).show(1, function() {
		$(this).animate({
			opacity: 0.50
		}, 200, null, function() {
			show_loading();
			image = new Image();
			image.src = img_src;

			// Show the loading until pre-loading is complete
			setTimeout(jonbox_img_delay, '300');
		});
	});
	return false;
}
/**
 * Checks to see if the image is done loading, if it is then
 *  create the jonbox and display, otherwise timeout and check again
 *
 * uses global image object
 **/
function jonbox_img_delay()
{
	if(!image.complete) {
		setTimeout(jonbox_img_delay, '300');
	} else {
		// Have the image only show as the source
		$("#jonbox_content").html("");
		$("<img />").attr({
			src: image.src
		}).appendTo("#jonbox_content");

		show_jonbox();
	}
}
/**
 * Display an error in the active form (assumes the submit callback return false, avoiding the jonbox being closed)
 * @param: msg : error message to display
 **/
function jonbox_form_error(msg)
{
	$('#jonbox_form_error').html(msg);
}

/**
 * Animate out the visiable jonbox and background.
 **/
function close_jonbox(e)
{
	if ( jonbox_persistent ) { return false; }
	// ~dustinh @ 8/24/2012
	// This removes ALL events bound to the window. need to be less...nuclear. unbind ONLY jonbox events
	//$(window).unbind("resize").unbind("scroll");
	$(window).unbind("resize", jonbox_reposition_resize).unbind("scroll", jonbox_reposition_scroll);

	$.event.trigger({
		type: "jonbox-hideStart",
		message: "JonBox is beginning to hide",
		time: new Date()
	});

	$("#jonbox_loading").fadeOut("Fast", function() {
		var top = $("#jonbox").css('top');
		top = parseInt(top);

		$("#jonbox").animate({
			top: (top + 20) + "px",
			opacity: 0
		}, 200, null, function() {
			$(this).hide();
			$("#jonbox_jblock").animate({
				opacity: 0
			}, 200, null, function() {

				// Let's determine the original div and reset it back to the original html
				var original_div = $("#jonbox_content").data("jonbox_original_div");
				if(typeof original_div != "undefined") {
					$("#" + original_div).html($("#" + original_div).text()).removeClass("jonbox_converted_to_text");
				}

				$(this).hide();
				//$("#jonbox_content").html(''); // Removed to allow jonbox.close_div to work in IE

				// Show any of those hidden items
				$('.jonbox_hide').css('visibility','visible');
				if ( typeof jonbox != "undefined" && jonbox.current_open_div !== null ) {
					jonbox.close_div();
				}

				// Destroy jonbox_content
				$("#jonbox_content").empty();

				$.event.trigger({
					type: "jonbox-hideComplete",
					message: "JonBox is finished hiding",
					time: new Date()
				});
			})
		});
	});

	enable_all_dynamic_areas();

	return false;
}

////////////////////////////////////////////////////////////////
// 2012.07.13 -JonJon
// The beginnings of a move to a JonBox object
// It's purpose of above date is to help in bugs with duplicate DOM IDs being created on jonbox_open_div()

jonbox = {
	noop : function() {}

	, current_open_div : null

	, set_and_show : function( quick_html ) {
		$("#jonbox_quick_content").html(quick_html);
		this.open_div("jonbox_quick_content");
	}

	, open_div : function( div_id ) {
		var $div = $("#" + div_id);
		$("#jonbox_jblock").css({
			height: $(document).height()
		}).show(1, function() {
			$(this).animate({
				opacity: 0.60
			}, 100, null, function() {
				$("#jonbox_content").html("");
				$("#jonbox_content").append($div);
				$div.show();
				show_jonbox();
				jonbox.current_open_div = $div;
			})
		});
		return false;
	}

	, close_div : function() {
		if ( jonbox_persistent ) { return false; }
		if ( this.current_open_div != null ) {
			this.current_open_div.hide();
			$("body").append(this.current_open_div);
			this.current_open_div = null;
		}
	}
};

////////////////////////////////////////////////////////////////
// JonBox as a jQuery plugin
// Selected elements become a trigger that opens a jonbox
// For more information please see README.txt under the section "USING THE JQUERY PLUGIN"
//--------------------------------------------------------------
(function( $ ) {
	$.fn.jonbox = function( options ) {
		var defaults = {
			"alert"   : "",
			"content" : "",
			"href"    : "",
			"info"    : "",
			"selector": null,
			"target"  : ""
		};
		var globalOpts = $.extend(defaults, options);

		return this.each(function() {
			var $$ = globalOpts.selector === null ? $(this) : $(globalOpts.selector, this);

			var attrs = {};
			if ( $$.is("a") && $.type($$.attr("href")) != "undefined" ) {
				attrs.href = $$.attr("href");
			}
			var datum = {
				"alert"   : $$.data("alert"),
				"content" : $$.data("content"),
				"href"    : $$.data("href"),
				"info"    : $$.data("info"),
				"target"  : $$.data("target")
			};
			var opts = $.extend(globalOpts, datum, attrs);

			if ( opts.href != "" && opts.href != "#" ) {
				$(this).on("click", opts.selector, function( e ) {
					e.preventDefault();
					open_jonbox(opts.href);
				});
			} else if ( opts.target != "" ) {
				$(this).on("click", opts.selector, function( e ) {
					e.preventDefault();
					jonbox.open_div(opts.target);
				});
			} else if ( opts.content != "" ) {
				var rand = Math.round(Math.random() * 8999) + 1000;
				var id   = 'jonbox_cached_content_' + rand;
				$("body").append('<div id="' + id + '" style="display:none;">' + opts.content + '</div>');
				$(this).on("click", opts.selector, function( e ) {
					e.preventDefault();
					jonbox.open_div(id);
				});
			} else if ( opts.alert != "" ) {
				$(this).on("click", opts.selector, function( e ) {
					e.preventDefault();
					jonbox_alert(opts.alert);
				});
			} else if ( opts.info != "" ) {
				$(this).on("click", opts.selector, function( e ) {
					e.preventDefault();
					jonbox_info(opts.info);
				});
			}
		});
	};
}( jQuery ));

/****** end css file: jquery.jonbox.js ******/

/****** js file: json2.min.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/plugins/ajax/json2.min.js ******/
/****** last modified: 1360217448 (2013-02-07 00:10:48) ******/
if(!this.JSON){JSON={}}(function(){function f(n){return n<10?"0"+n:n}if(typeof Date.prototype.toJSON!=="function"){Date.prototype.toJSON=function(key){return this.getUTCFullYear()+"-"+f(this.getUTCMonth()+1)+"-"+f(this.getUTCDate())+"T"+f(this.getUTCHours())+":"+f(this.getUTCMinutes())+":"+f(this.getUTCSeconds())+"Z"};String.prototype.toJSON=Number.prototype.toJSON=Boolean.prototype.toJSON=function(key){return this.valueOf()}}var cx=/[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,escapable=/[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,gap,indent,meta={"\b":"\\b","\t":"\\t","\n":"\\n","\f":"\\f","\r":"\\r",'"':'\\"',"\\":"\\\\"},rep;function quote(string){escapable.lastIndex=0;return escapable.test(string)?'"'+string.replace(escapable,function(a){var c=meta[a];return typeof c==="string"?c:"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)})+'"':'"'+string+'"'}function str(key,holder){var i,k,v,length,mind=gap,partial,value=holder[key];if(value&&typeof value==="object"&&typeof value.toJSON==="function"){value=value.toJSON(key)}if(typeof rep==="function"){value=rep.call(holder,key,value)}switch(typeof value){case"string":return quote(value);case"number":return isFinite(value)?String(value):"null";case"boolean":case"null":return String(value);case"object":if(!value){return"null"}gap+=indent;partial=[];if(Object.prototype.toString.apply(value)==="[object Array]"){length=value.length;for(i=0;i<length;i+=1){partial[i]=str(i,value)||"null"}v=partial.length===0?"[]":gap?"[\n"+gap+partial.join(",\n"+gap)+"\n"+mind+"]":"["+partial.join(",")+"]";gap=mind;return v}if(rep&&typeof rep==="object"){length=rep.length;for(i=0;i<length;i+=1){k=rep[i];if(typeof k==="string"){v=str(k,value);if(v){partial.push(quote(k)+(gap?": ":":")+v)}}}}else{for(k in value){if(Object.hasOwnProperty.call(value,k)){v=str(k,value);if(v){partial.push(quote(k)+(gap?": ":":")+v)}}}}v=partial.length===0?"{}":gap?"{\n"+gap+partial.join(",\n"+gap)+"\n"+mind+"}":"{"+partial.join(",")+"}";gap=mind;return v}}if(typeof JSON.stringify!=="function"){JSON.stringify=function(value,replacer,space){var i;gap="";indent="";if(typeof space==="number"){for(i=0;i<space;i+=1){indent+=" "}}else{if(typeof space==="string"){indent=space}}rep=replacer;if(replacer&&typeof replacer!=="function"&&(typeof replacer!=="object"||typeof replacer.length!=="number")){throw new Error("JSON.stringify")}return str("",{"":value})}}if(typeof JSON.parse!=="function"){JSON.parse=function(text,reviver){var j;function walk(holder,key){var k,v,value=holder[key];if(value&&typeof value==="object"){for(k in value){if(Object.hasOwnProperty.call(value,k)){v=walk(value,k);if(v!==undefined){value[k]=v}else{delete value[k]}}}}return reviver.call(holder,key,value)}cx.lastIndex=0;if(cx.test(text)){text=text.replace(cx,function(a){return"\\u"+("0000"+a.charCodeAt(0).toString(16)).slice(-4)})}if(/^[\],:{}\s]*$/.test(text.replace(/\\(?:["\\\/bfnrt]|u[0-9a-fA-F]{4})/g,"@").replace(/"[^"\\\n\r]*"|true|false|null|-?\d+(?:\.\d*)?(?:[eE][+\-]?\d+)?/g,"]").replace(/(?:^|:|,)(?:\s*\[)+/g,""))){j=eval("("+text+")");return typeof reviver==="function"?walk({"":j},""):j}throw new SyntaxError("JSON.parse")}}}());
/****** end css file: json2.min.js ******/

/****** js file: draw.lead_management.table.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/plugins/lead_management/includes/views/default/draw.lead_management.table.js ******/
/****** last modified: 1473361857 (2016-09-08 14:10:57) ******/
var lead_management_table = {
	url : te_url
	, tags_exclude : te_tags_exclude
	, sspy : null
	, current_ajax : null
	, uiStates: {
		  'menus': { 'search': true, 'settings': false }
		, 'display': { 'expand': false }
	}

	, init : function() {

		ai.te.quantifier_offset = 3;
		/*
		var html  = '<div id="select_all_sub_options">';
		    html += '<div><button id="select_all_sub_options_current_page">Select current page</button></div>';
		    html += '<div><button id="select_all_sub_options_all">Select all in results</button></div>';
		    html += '</div>';
		$(html).css({
			display: "none"
			, background: "#f8f8f8"
			, border: "1px solid #aaa"
			, borderRadius: "5px"
			, padding: "10px"
		}).appendTo("body");

		$("#lead_management_main_table .te_selectall_checkbox").click(function( e ) {
			if ( $(this).is(":checked") ) {
				var pos = $(this).position();
				var w = $(this).outerWidth();
				var h = $(this).outerHeight();

				var x = pos.left;
				var y = Math.round(pos.top + h);

				$("#select_all_sub_options").css({
					  position: "absolute"
					, left: x + "px"
					, top: y + "px"
				}).show();
			} else {
				lead_management_table.set_select_all_results(false);
			}

		}).after('<input type="hidden" id="select_all_results" name="select_all_results" value="0" /><img src="images/help.png" alt="" title="All results have been selected" style="display:none; vertical-align:middle;" id="select_all_info" />');

		$("#select_all_sub_options_current_page").click(function( e ) {
			lead_management_table.set_select_all_results(false);
		});

		$("#select_all_sub_options_all").click(function( e ) {
			lead_management_table.set_select_all_results(true);
		});

		$(".te_multiselect_checkbox").click(function( e ) {
			if ( $(this).not(":checked") ) {
				if ( $("#select_all_results").val() == "1" ) {
					ai.notification.info("Select All", "\"Select all results\" has been changed to \"current page only\".", true);
				}
				lead_management_table.set_select_all_results(false);
			}
		});
		*/


		// Right Action Buttons
		$("#table_container_loader_cancel").click(function( e ) {
			e.preventDefault();
			$("#table_container_loader").hide();
			$("#table_container").show();
			try {
				lead_management_table.current_ajax.abort();
			}
			catch ( err ) { }
		});
		$("#broadcast_email_button").click(function( e ) {
			e.preventDefault();
			multi_action('email');
		});
        $("#give_gifts").click(function( e ) {
            e.preventDefault();
            multi_action('give_gifts');
        });

        // Delegated Events (Objects that are only dynamically loaded will have their events delegated to [ancestor] objects ready on initial page load)
		$("#ajax_div").on("focus", "#csv_upload_ownerID", function( e ) {
			if ( !$(this).hasClass("autocomplete_loaded") ) {
				$(this).autocomplete({
					source: "lead_management?ai_skin=full_page&te_mode=ajax&ajax_cmd=autocomplete_receiving_user&return_userID=1&format=json",
					autoFocus:true,
					select: function(e, u) {
						$(this).val(u.item.value);
					}
				}); //.result(function( e, d, f ) { if ( d ) { $(this).val(d[1]); } });

				$(this).addClass("autocomplete_loaded");
			}
		});

		$("#ajax_div").on("focus", "#receiving_user", function( e ) {
			if ( !$(this).hasClass("autocomplete_loaded") ) {
				$(this).autocomplete({
					source: "lead_management?ai_skin=full_page&te_mode=ajax&ajax_cmd=autocomplete_receiving_user&format=json",
					autoFocus:true,
					select: function(e, u) {
						$(this).val(u.item.value);
					}
				});  //.result(function( e, d, f ) { if ( d ) { $(this).val(d[1]); } });
				$(this).addClass("autocomplete_loaded");
			}
		});

		$("#email_missing_search_field").click(function( e ) {
			if ( $(this).is(":checked") ) {
				$("#email_search_field").attr("disabled", "disabled");
			} else {
				$("#email_search_field").removeAttr("disabled");
			}
		});
		$("#email_status").on("change", function( e ) {
			$$ = $(this);
			console.log($$.val());
			if ( $$.val() == "" ) {
				$("#email_search_field").prop("disabled", false).show();
			} else {
				$("#email_search_field").prop("disabled", true).hide();
			}
		}).change();

		$("#search_toggle_button").click(function( e ) {
			e.preventDefault();
			search_toggle();
		});

		$("#search_recycle_button").click(function( e ) {
			e.preventDefault();
			search_toggle_recycle();
		});

		// Turn off anchors (TE rows have the click action)
		// If JS is disabled, the anchor still exists as a fallback
		$("#lead_management_main_table").on("click", "a.view_lead", function( e ) {
			e.preventDefault();
		});

		$("#lead_management_main_table").on("click", "a.view_lead_email", function( e ) {
			var $tr_parent = $(this).parents("tr");
			var row_i = $tr_parent.attr("data-row-i");
			this.href += "&te_row=" + encodeURIComponent(row_i);
			console.log(this.href);
		});

		// Enable Marketing Manager
		$("#marketing_manager_button").on("click", function( e ) {
			e.preventDefault();
			$("#table_container").fadeOut(200, function() {
				$("#ajax_div").html('<img src="images/loading.large.gif" alt="Loading...">').show();
				$.get(lead_management_table.url + "&ai_skin=full_page&te_mode=ajax&ajax_cmd=load_marketing_manager", function( data, success, xhr ) {
					$("#ajax_div").hide().html(data).fadeIn(200);
				});
			});
		});
		$("#ajax_div").on("click", "#marketing_manager_closer", function( e ) {
			e.preventDefault();
			$("#ajax_div").fadeOut(200, function() {
				$("#table_container").fadeIn(200);
			});
		});

		this.init_ownerID_asearch();
		this.init_qsearch_reset();

		if ( window.localStorage.getItem('crmUI') == 'undefined' || window.localStorage.getItem('crmUI') == null ) {
			window.localStorage.setItem('crmUI', JSON.stringify(this.uiStates));
		} else {
			this.uiStates = JSON.parse(window.localStorage.getItem('crmUI'));
		}

		$('#switch_view_opt').click(function(e) {
			lead_management_table.crmExpandView(-1);
		});

		$('#compress_view_opt').click(function(e) {
			lead_management_table.crmExpandView(e, false);
		});
		$('#expand_view_opt').click(function(e) {
			lead_management_table.crmExpandView(e, true);
		});

		return this;
	}
	, init_email_selected : function() {
		var cloud_height = $("#email_selected_tag_cloud").height();
		var wrapper_height = $("#email_selected_tag_cloud_wrapper").height();
		if ( cloud_height <= wrapper_height ) {
			$("#email_selected_tag_cloud_more").hide();
		} else {
			$("#email_selected_tag_cloud_more").click(function( e ) {
				e.preventDefault();
				$("#email_selected_tag_cloud_wrapper").css({height: "auto"});
				$(this).hide();
			});
		}

		$("#email_selected_form").submit(function( e ) {
			var url = $(this).attr("action");
			var data = $("#email_selected_form").serialize();
			var mode = $(this).attr('mode');
			$('#email_selected').hide();
			$('#email_selected_processing').show();

			$.post(url, data, function( data, status, xhr ) {
				$('#email_selected_processing').hide();
				$('#email_selected').show();

				if ( data.error ) {
					jonbox_alert(data.error);
				} else if ( data.success == "1") {
					var ai_token_rate = $("#ai_token_rate").val(); // 1 digit decimal
					var ai_token_have_count = $("#ai_token_have_count").val(); // 1 digit decimal
					var ai_token_need_count = $("#ai_token_need_count").val(); // Whole Number

					ai_token_amount = ai_token_have_count - (ai_token_rate * ai_token_need_count);

					$("#token_badge_id").html(ai_token_amount.toFixed(1));

					if (typeof jonbox_checkmark == 'function') {
						jonbox_checkmark('Your message has been successfully sent.<br><br>To see your updated Contact Manager, <a href="lead_management?te_class=lead_management&amp;te_mode=table">Refresh This Page</a>.<br><br>Otherwise click "OK" or close this box to continue.');
					} else {
						jonbox_alert('Your message has been successfully sent.<br><br>To see your updated Contact Manager, <a href="lead_management?te_class=lead_management&amp;te_mode=table">Refresh This Page</a>.<br><br>Otherwise click "OK" or close this box to continue.');
					}
					multi_action("email_cancel", mode);
				} else if ( data.success == "2") {
					if (typeof jonbox_checkmark == 'function') {
						jonbox_checkmark('Your message has been successfully saved.<br><br>Click "OK" or close this box to continue.');
					} else {
						jonbox_alert('Your message has been successfully saved.<br><br>Click "OK" or close this box to continue.');
					}
					multi_action("email_cancel");
				} else {
					jonbox_alert("Unknown error");
				}
			}, 'json');
			return false;
		});
		return this;
	}
	, init_qsearch_reset : function() {
		// Initiate the qsearch remove/reset "x" button
		$(".te_qsearch_keywords").after('<a id="qkeywords_clear_x" href="#"><span>&times;</span></a>');
		$("#qkeywords_clear_x").click(function( e ) {
			e.preventDefault();
			document.location = lead_management_table.url + "&te_mode=table&te_qsearch=true&te_qkeywords=";
		});
		// Add events to the qsearch remove/reset "x" button
		$("#te_qkeywords").focus(function( e ) {
			$("#qkeywords_clear_x").show();
		}).blur(function( e ) {
			if ( $.trim($(this).val()) == "" ) {
				$("#qkeywords_clear_x").hide();
			}
		});
		// Fine tune the positioning of the button
		// (it's not enough to just generalize the CSS since certain
		// dimensions render differently in different browsers)
		var $search_button = $(".te_qsearch_keywords .search_button");
		var x = $search_button.outerWidth() + 5;
		var y = $search_button.outerHeight();
		$("#qkeywords_clear_x").css({
			  top  : ("-" + y + "px")
			, right: (      x + "px")
		});
	}
	, preview_content : function( select_obj ) {

		$("#email_selected_creative_preview").html('<img src="images/loading.large.gif" alt="Loading..." />');

		var url = $(select_obj.form).attr("action").replace("email_step=process_form", "email_step=preview_content");
		var data = {creative: $(select_obj).val()};

		$("#email_selected_creative_preview").load(url, data, function() {
			if($(select_obj).val() == "-1") {
				$(".broadcast_save_only").removeClass("disabled_bttn");
			}

			if (typeof update_token_displays == 'function') {
				update_token_displays();
			}
		});

		return this;
	}
	, edit_content : function( creative_id ) {
		$("#email_selected_creative_preview").html('<img src="images/loading.large.gif" alt="Loading..." />');
		$(".broadcast_save_only").removeClass("disabled_bttn");

		var url = $("#email_selected_form").attr("action").replace("email_step=process_form", "email_step=preview_content&edit=true");
		var data = {creative: creative_id};

		$("#email_selected_creative_preview").load(url, data);

		return this;
	}
	, remove_content : function( creative_id ) {
		var url = $("#email_selected_form").attr("action").replace("email_step=process_form", "email_step=remove_content");
		var data = {creative: creative_id};

		$.post(url, data, function( data, status, xhr ) {
			if ( data.error ) {
				jonbox_alert(data.error);
			} else if ( data.success ) {
				if (typeof jonbox_checkmark == 'function') {
					jonbox_checkmark('Your creative has been successfully removed.<br><br>To see your updated Contact Manager, <a href="lead_management?te_class=lead_management&amp;te_mode=table">Refresh This Page</a>.<br><br>Otherwise click "OK" or close this box to continue.');
				} else {
					jonbox_alert('Your creative has been successfully removed.<br><br>To see your updated Contact Manager, <a href="lead_management?te_class=lead_management&amp;te_mode=table">Refresh This Page</a>.<br><br>Otherwise click "OK" or close this box to continue.');
				}
				multi_action("email_cancel");
			} else {
				jonbox_alert("Unknown error");
			}
		}, 'json');
		return false;
	}
	, set_select_all_results : function( is_all ) {
		if ( is_all ) {
			$("#select_all_results").val("1");
			$("#select_all_info").show();
			$("#select_all_sub_options").hide();
		} else {
			$("#select_all_results").val("0");
			$("#select_all_info").hide();
			$("#select_all_sub_options").hide();
		}
	}
	, scrollTo : function( te_key ) {
		/*var target_row = $("tr#contact_" + te_key);
		var destination = $(target_row).offset().top;
		$("html:not(:animated),body:not(:animated)").animate({ scrollTop: destination}, 1100);*/
		// ^This is now handled as a standard in the base Table Edit
	}
	, remove_tag_exclude : function( tag_id ) {
		var tag_vars = this.tags_exclude;
		remove_tag = tag_id;
		regex = new RegExp("(^| )" + remove_tag + "( |$)");
		tag_vars = tag_vars.replace(regex, " ");
		var url = this.url;
		var qkeywords = $.trim($("#te_qkeywords").val())
		if ( qkeywords != "" ) {
			url += "&te_qsearch=true&te_qkeywords=" + encodeURIComponent(qkeywords);
		}
		document.location = url + "&te_asearch=true&tags_exclude=" + encodeURIComponent($.trim(tag_vars));
		return false;
	}
	////////////////////////////////////////////////////////////////
	// OWNER SEARCH
	, init_ownerID_asearch : function() {
		if ( $('#ownerID_autocomplete').length > 0 ) {
			var ac = $("#ownerID_autocomplete").autocomplete({
				source: "lead_management?ai_skin=full_page&te_mode=ajax&ajax_cmd=autocomplete_receiving_user&return_userID=1&format=json",
				autoFocus: true,
				select: function(e, u) {
					lead_management_table.add_ownerID_asearch(u.item.value, u.item.label);

					window.setTimeout(function() {
						$('#ownerID_autocomplete').val("");
					}, 200);
				}
			});

			$("#ownerID_tag_list").on("click", "a.ownerID_remove_tag", lead_management_table.remove_ownerID_asearch);
			$("#ownerID_exclude_checkbox").click(function( e ) {
				if ( $(this).is(":checked") ) {
					$("#ownerID_exclude").val("1");
				} else {
					$("#ownerID_exclude").val("0");
				}
			});
		}
	}
	, add_ownerID_asearch : function( owner_id, owner_name ) {
		// Grab current value
		var term = $("#ownerID").val();
		// If owner_id is not in the value, add it
		var regex = new RegExp("(^|,)" + owner_id + "(,|$)");
		if ( !term.match(regex) ) {
			if ( term != "" ) {
				term += ",";
			}
			term += owner_id;
			$("#ownerID").val(term);
			var new_tag_html  = '<li id="ownerID_tag_' + owner_id + '" class="tag">';
			    new_tag_html += '<span>' + owner_name + '</span>';
				new_tag_html += '<a href="#" class="remove_tag ownerID_remove_tag" data-ownerID="' + owner_id + '"><span>&times;</span></a>';
				new_tag_html += '</li>';
			$("#ownerID_tag_list").append(new_tag_html);
		}
	}
	, remove_ownerID_asearch : function( e ) {
		// This is an anchor, do not honor the link
		e.preventDefault();
		// Parse the owner_id
		var owner_id = $(this).attr("data-ownerID");
		// Grab current value
		var term = $("#ownerID").val();
		// Remove any instance from the term
		term_rebuild = "";
		a_terms = term.split(",");
		$.each(a_terms, function(n, v) {
			if ( v == owner_id ) {
				return true;
			}
			term_rebuild += "," + v;
		});
		term = term_rebuild.substr(1);
		$("#ownerID").val(term);
		// Remove any tags in the list
		$("#ownerID_tag_" + owner_id).remove();
	}

	, crmExpandView : function(e, show) {
		if ( e == null && $('#crm_expand_menu').hasClass('none') ) {
			$('.tb-button-menu').addClass('none');
			$('#crm_expand_menu').removeClass('none');
		}
		else if ( e == null && show == null) {
			$('#crm_expand_menu').addClass('none');
		}
		else if ( e == -1 ) {
			$('#crm_expand_menu').addClass('none');
			switchCrmView('default');
		} else {
			if ( e !== false ) {
				e.stopPropagation();
			}

			if ( show === true ) {
				$('#crm_expand_menu').addClass('none');
				this.setUI('display', 'expand', true);
				switchCrmView('compact');
			} else if ( show === false ) {
				$('#crm_expand_menu').addClass('none');
				this.setUI('display', 'expand', false);
				switchCrmView('compact');
			}
		}
	}

	, crmToggleContactMenu : function() {
		var isHidden = $('#crm_contact_menu').hasClass('none');
		$('.tb-button-menu').addClass('none');

		if ( isHidden ) {
			$('#crm_contact_menu').removeClass('none');
			// $('#crm_contact_menu').css('height', $('#crm_contact_menu ul').height());
			$('#crm_contact_menu').css('height', 'auto');
		}
	}

	, setUI : function(which, id, value) {
		if ( which in this.uiStates && id in this.uiStates[which] ) {
			this.uiStates[which][id] = value;
			window.localStorage.setItem('crmUI', JSON.stringify(this.uiStates));

			return true;
		}

		return false;
	}
};

////////////////////////////////////////////////////////////////

$(document).ready(function() {
	lead_management_table.init();
});

function switchCrmView(view) {
	$.ajax('lead_management?ai_skin=full_page&te_class=lead_management&te_mode=ajax&ajax_cmd=switch_view&view=' + view)
	.done(function(data) {
		if ( data.match(/ajax_success/) ) {
			document.location.reload();
		}
	});
}

(function( $ ) {
	$.widget( "custom.combobox", {
		_create: function() {
			this.wrapper = $( "<span>" )
				.addClass( "custom-combobox" )
				.insertAfter( this.element );

			this.element.hide();
			this._createAutocomplete();
			this._createShowAllButton();
		},

		_createAutocomplete: function() {
			var selected = this.element.children( ":selected" ),
				value = selected.val() ? selected.text() : "";

			this.input = $( "<input>" )
				.appendTo( this.wrapper )
				.val( value )
				.attr( "title", "" )
				.addClass( "custom-combobox-input ui-widget ui-widget-content ui-state-default ui-corner-left" )
				.autocomplete({
					delay: 0,
					minLength: 0,
					source: $.proxy( this, "_source" )
				})
				.tooltip({
					tooltipClass: "ui-state-highlight"
				});

			if ( 'placeholder' in this.options ) {
				this.input.attr('placeholder', this.options.placeholder);
			}

			this._on( this.input, {
				autocompleteselect: function( event, ui ) {
					ui.item.option.selected = true;
					this._trigger( "select", event, {
						item: ui.item.option
					});
				},

				autocompletechange: "_removeIfInvalid"
			});
		},

		_createShowAllButton: function() {
			var input = this.input,
				wasOpen = false;

			$( "<a>" )
				.attr( "tabIndex", -1 )
				.attr("title", "Show All Tags")
				.tooltip()
				.appendTo( this.wrapper )
				.button({
					icons: {
						primary: "ui-icon-triangle-1-s"
					},
					text: false
				})
				.removeClass( "ui-corner-all" )
				.addClass( "custom-combobox-toggle ui-corner-right" )
				.mousedown(function() {
					wasOpen = input.autocomplete( "widget" ).is( ":visible" );
				})
				.click(function() {
					input.focus();

					// Close if already visible
					if ( wasOpen ) {
						return;
					}

					// Pass empty string as value to search for, displaying all results
					input.autocomplete( "search", "" );
				});
		},

		_source: function( request, response ) {
			var matcher = new RegExp( $.ui.autocomplete.escapeRegex(request.term), "i" );
			response( this.element.children( "option" ).map(function() {
				var text = $( this ).text();
				if ( this.value && ( !request.term || matcher.test(text) ) )
					return {
						label: text,
						value: text,
						option: this
					};
			}) );
		},

		_removeIfInvalid: function( event, ui ) {

			// Selected an item, nothing to do
			if ( ui.item ) {
				return;
			}

			// Search for a match (case-insensitive)
			var value = this.input.val(),
				valueLowerCase = value.toLowerCase(),
				valid = false;
			this.element.children( "option" ).each(function() {
				if ( $( this ).text().toLowerCase() === valueLowerCase ) {
					this.selected = valid = true;
					return false;
				}
			});

			// Found a match, nothing to do
			if ( valid ) {
				return;
			}

			// Remove invalid value
			this.input
				.val( "" )
				.attr( "title", value + " didn't match any item" )
				.tooltip( "open" );
			this.element.val( "" );
			this._delay(function() {
				this.input.tooltip( "close" ).attr( "title", "" );
			}, 2500 );
			this.input.data( "ui-autocomplete" ).term = "";
		},

		_destroy: function() {
			this.wrapper.remove();
			this.element.show();
		},


	});

		$.ui.autocomplete.prototype._renderMenu = function( ul, items ) {
   var self = this;
   $.each( items, function( index, item ) {
      if (index < 500) // here we define how many results to show
         {self._renderItem( ul, item );}
      });
      }

	$.ui.autocomplete.prototype._renderItem = function(ul, item) {
    return $("<li></li>").data("ui-autocomplete-item", item).append("<a>" + item.label + "</a>").appendTo(ul);
		};

})( jQuery );


/****** end css file: draw.lead_management.table.js ******/

/****** js file: default.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/plugins/lead_management/includes/views/default/default.js ******/
/****** last modified: 1465833519 (2016-06-13 10:58:39) ******/
//This file is for js that need to be included for all lead_management default views

$(document).ready(function(){
	// verify scrollspy library has been loaded
	if ($.fn.scrollspy != null) {
		// this is a horrible way to accomplish this, but it will have to do for now
		var lc_buttons = $('#lead_control_buttons_wrap');

		if ( lc_buttons ) {
			var $docH = $(document.body).height();	 // get the height of the document
			lcOff = lc_buttons.offset();		 // get the top of the sidebar menu
			lcbH  = (lc_buttons.height() + 60); // +100 to account for various margins/paddings and the bottom control panel

			lc_buttons.scrollspy({
				'min': lcOff.top-41,		// onEnter begins at top of top bar
				'max': 1000000,			// it ends at bottom of page
				'onEnter': function() {
					// set the stationary class to make this fixed position
					lc_buttons.addClass('stationary');

					// the height of the menu shouldn't change, but the height of the window just might
					// therefore we will not cache it
					if ( lcbH >= $(window).height() ) {
						// only if it is possible that the menu may extend past the viewport do we shrink
						// the buttons and add an overflow to the element so as not to prevent access to buttons
						lc_buttons.addClass('make-fit');
					}
				},
				'onLeave': function() {
					// reset everything
					lc_buttons.removeClass('stationary');
					lc_buttons.removeClass('make-fit');
					//lc_buttons.attr('style', '');
				}
			});
		}
	} // end scrolling sidebar menu

});

/****** end css file: default.js ******/

/****** js file: lead_management.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/plugins/lead_management/lead_management.js ******/
/****** last modified: 1428089242 (2015-04-03 14:27:22) ******/

var last_num_selected=-1;
function check_for_selected_boxes(){
	var num_selected = $("input[name='te_multiselect[]']:checked").size();	
	if(num_selected==last_num_selected) return;
	last_num_selected=num_selected;
	if(num_selected>0) { $('.multioptionoff').addClass('multioptionon'); $('.multioptionoff').removeClass('multioptionoff'); }
	else { $('.multioptionon').addClass('multioptionoff'); $('.multioptionon').removeClass('multioptionon'); }
}
$(document).ready(function() {
	$(".te_data_row .te_data_cell").click(function(e) {
		var $table_parent = $(this).parents("table");
		var $tr_parent = $(this).parents("tr");
		if ( e.ctrlKey ) {
			check_for_selected_boxes();
		}
	});
	$("input[name='te_multiselect[]']").change(check_for_selected_boxes);
	$("input[name='te_selectall']").change(check_for_selected_boxes);
	check_for_selected_boxes();


$('.twilio_lead_options').on('click', function(e){
	e.preventDefault();
	jonbox.open_div('twilio_options');
});



	

$('#jonbox_content').on('click','.twilio_lead_action', function(e){
		e.preventDefault();
		var url = $(this).data('url');
		note_url = $(this).data('noteUrl');
		lead_id = $(this).data('leadId');
			if($(this).data('pin_submit') == "true")
			{
				var pdata =
				{ 
					phone_number: $('#twilio_pin').val()
				};
				
			}
			else
			{
				var pdata ={ };
			}
			$.post(url, pdata, function( data, success, xhr )
			{
				if ( typeof data.status == "undefined" )
				{
					jonbox_alert(data);
				}
				else if ( data.status == "0" )
				{
					jonbox_alert(data.message);
				}
				else if ( data.status == "1")
				{
					var params = $.parseJSON( data.js );
					$('body').append('body', data.html);
					Twilio.Device.connect(params);
					var nvp = {
						lead_id: lead_id,
						status: data.status_id,
						notes: data.note_message
					};
					$.post(note_url, nvp, function( data_notes, status, xhr ) {
						if ( data_notes.substr(0, 6) == "error|" ) {
							$("#lead_notes_ajax_error").html(data_notes.substr(6));
						} else {
							$("#lead_notes_maindiv").html(data_notes);
							$('#lead_notes_submit_button button').removeClass('disabled').removeAttr('disabled');
							ai.helptext.init();
							
							if ( $("#etag_field_add_tag").length && add_etag ) {
								var new_tag = $("#etag_field_add_tag").val();
								add_etag(new_tag);
							}
						}
						$('#lead_notes_submit_button button').show();
						$('.loading_span').remove();
					});
					close_jonbox();
				}
				else if (data.status == "2")
				{
					$('#jonbox_content').html(data.html);
				}
				else if ( data.status == "3")
				{
					console.log(data.html);
					$('body').append('body', data.html);
					close_jonbox();
				}
			}, "json");
	})

});
/****** end css file: lead_management.js ******/

/****** js file: te_lead_management.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/plugins/lead_management/includes/te_lead_management.js ******/
/****** last modified: 1454958724 (2016-02-08 13:12:04) ******/
$(document).ready(function(){
	$('#tag_select + span.custom-combobox .custom-combobox-input').attr("readonly", "readonly");
	$('#tag_select_exclude + span.custom-combobox .custom-combobox-input').attr("readonly", "readonly");
	$.post("lead_management?te_class=lead_management&te_mode=ajax&ajax_cmd=tag_search&ai_skin=full_page", function(data){
		
		$('.loading-select-list').hide();

		// make first option on data an empty option so the placeholder is kept
		$('#tag_select').html('<option value=""></option>'+data.tag_options);
		$('#tag_select + span.custom-combobox .custom-combobox-input').attr('placeholder', 'Search by Tag');
		$('#tag_select + span.custom-combobox .custom-combobox-input').prop("readonly", false)
		
		$('#tag_select_exclude').html('<option value=""></option>'+data.tag_options);
		$('#tag_select_exclude + span.custom-combobox .custom-combobox-input').attr('placeholder', 'Exclude by Tag');
		$('#tag_select_exclude + span.custom-combobox .custom-combobox-input').prop("readonly", false);

		$('.tag').each(function(){
			if (typeof $(this).attr('id') != 'undefined')
			{
				tag_id = $(this).attr('id').replace(/^tag_/, '');
				exclude_id = $(this).attr('id').replace(/^tag_exclude_/, '');
				tag_list = $.makeArray( data.tag_list );
				
				type_id = $("#tag_select #" + tag_id).data('type');
				type_id_exclude = $("#tag_select_exclude #" + tag_id).data('type');
				
				found = false;
				$.each( data.tag_list, function( key, value ) {
					if(value == tag_id  || value == exclude_id )
					{
						found = true;
					}
				});

				if(found == false)
				{
					// task 26107, do not mess with tags in asearch view, http://x-v.it/3vh4s9/1
					if( $(this).parent().attr('id') == 'ownerID_tag_list' )	{ return; /*continue*/ }
					
					// Don't hide system tags
					if(type_id == "" && type_id_exclude == "") {
						$(this).remove();
					}
				}
			}
		});

		// Now that the list has been loaded we can initiate the UI elemnts for fancy autocompelte
		$("#tag_select").combobox({
			placeholder: 'Search By Tag',
		    select: function (event, ui) {
				if($('#tag_select').val()!='') {
					if($('#tag_'+$('#tag_select').val()).length == 0) {
						//save for an ajax solution if we decide to go that way
						//$(".tag_cloud").prepend('<li class="tag" id="tag_'+$('#tag_select').val()+'"> '+$('#tag_select').val()+' <a class="remove_tag" href="javascript:void(0)" onclick="return remove_tag(\'tag_'+$('#tag_select').val()+'\')">&times;</a></li>');
						var url = "lead_management?te_class=lead_management";
						var qkeywords = $.trim($("#te_qkeywords").val());

						if ( qkeywords != "" ) {
							url += "&te_qsearch=true&te_qkeywords=" + encodeURIComponent(qkeywords);
						}

						var tag_list = (search_var_tags ? search_var_tags + " " : "") + $('#tag_select').val();

						document.location = url + "&te_asearch=true&tags=" + encodeURIComponent(tag_list);
					}
					$('#tag_select').val('');
				}
		    }
		});

		$("#tag_select_exclude").combobox({
			placeholder: 'Exclude By Tag',
		    select: function (event, ui) {
				if ( $(this).val() != "" ) {
					if ( $("#tag_exclude_" + $(this).val()).length < 1 ) {
						var url = lead_management_table.url;
						var qkeywords = $.trim($("#te_qkeywords").val())
						if ( qkeywords != "" ) {
							url += "&te_qsearch=true&te_qkeywords=" + encodeURIComponent(qkeywords);
						}
						document.location = url + "&te_asearch=true&tags_exclude=" + encodeURIComponent(lead_management_table.tags_exclude) + "+" + $(this).val();
					}
					$('#tag_select').val("");
				}
		    }
		});

	}, 'json');

	// for standard, pass te_row key in post, task 25226
	$(document.body).on('change', '.te_multiselect_checkbox', function( e ) {
		var row = $(this).closest('tr').attr('data-row-i');
		if ( $(this).is(":checked") ) {
			$('<input>').attr( {"type": "checkbox"
								,"checked": "checked"
								,"name": "te_row[]"
								,"id": "te_row_"+row
								,"value": row
								})
						.css('display','none')
						.appendTo($(this).parent());
		}
		else{
			$("#te_row_"+row).remove();
		}
	});

});
/****** end css file: te_lead_management.js ******/

/****** js file: timepicker.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/plugins/jQuery_datepicker/timepicker.js ******/
/****** last modified: 1382398107 (2013-10-21 18:28:27) ******/
/*! jQuery Timepicker Addon - v1.4 - 2013-08-11
* http://trentrichardson.com/examples/timepicker
* Copyright (c) 2013 Trent Richardson; Licensed MIT */
(function ($) {

	/*
	* Lets not redefine timepicker, Prevent "Uncaught RangeError: Maximum call stack size exceeded"
	*/
	$.ui.timepicker = $.ui.timepicker || {};
	if ($.ui.timepicker.version) {
		return;
	}

	/*
	* Extend jQueryUI, get it started with our version number
	*/
	$.extend($.ui, {
		timepicker: {
			version: "1.4"
		}
	});

	/* 
	* Timepicker manager.
	* Use the singleton instance of this class, $.timepicker, to interact with the time picker.
	* Settings for (groups of) time pickers are maintained in an instance object,
	* allowing multiple different settings on the same page.
	*/
	var Timepicker = function () {
		this.regional = []; // Available regional settings, indexed by language code
		this.regional[''] = { // Default regional settings
			currentText: 'Now',
			closeText: 'Done',
			amNames: ['AM', 'A'],
			pmNames: ['PM', 'P'],
			timeFormat: 'HH:mm',
			timeSuffix: '',
			timeOnlyTitle: 'Choose Time',
			timeText: 'Time',
			hourText: 'Hour',
			minuteText: 'Minute',
			secondText: 'Second',
			millisecText: 'Millisecond',
			microsecText: 'Microsecond',
			timezoneText: 'Time Zone',
			isRTL: false
		};
		this._defaults = { // Global defaults for all the datetime picker instances
			showButtonPanel: true,
			timeOnly: false,
			showHour: null,
			showMinute: null,
			showSecond: null,
			showMillisec: null,
			showMicrosec: null,
			showTimezone: null,
			showTime: true,
			stepHour: 1,
			stepMinute: 1,
			stepSecond: 1,
			stepMillisec: 1,
			stepMicrosec: 1,
			hour: 0,
			minute: 0,
			second: 0,
			millisec: 0,
			microsec: 0,
			timezone: null,
			hourMin: 0,
			minuteMin: 0,
			secondMin: 0,
			millisecMin: 0,
			microsecMin: 0,
			hourMax: 23,
			minuteMax: 59,
			secondMax: 59,
			millisecMax: 999,
			microsecMax: 999,
			minDateTime: null,
			maxDateTime: null,
			onSelect: null,
			hourGrid: 0,
			minuteGrid: 0,
			secondGrid: 0,
			millisecGrid: 0,
			microsecGrid: 0,
			alwaysSetTime: true,
			separator: ' ',
			altFieldTimeOnly: true,
			altTimeFormat: null,
			altSeparator: null,
			altTimeSuffix: null,
			pickerTimeFormat: null,
			pickerTimeSuffix: null,
			showTimepicker: true,
			timezoneList: null,
			addSliderAccess: false,
			sliderAccessArgs: null,
			controlType: 'slider',
			defaultValue: null,
			parse: 'strict'
		};
		$.extend(this._defaults, this.regional['']);
	};

	$.extend(Timepicker.prototype, {
		$input: null,
		$altInput: null,
		$timeObj: null,
		inst: null,
		hour_slider: null,
		minute_slider: null,
		second_slider: null,
		millisec_slider: null,
		microsec_slider: null,
		timezone_select: null,
		hour: 0,
		minute: 0,
		second: 0,
		millisec: 0,
		microsec: 0,
		timezone: null,
		hourMinOriginal: null,
		minuteMinOriginal: null,
		secondMinOriginal: null,
		millisecMinOriginal: null,
		microsecMinOriginal: null,
		hourMaxOriginal: null,
		minuteMaxOriginal: null,
		secondMaxOriginal: null,
		millisecMaxOriginal: null,
		microsecMaxOriginal: null,
		ampm: '',
		formattedDate: '',
		formattedTime: '',
		formattedDateTime: '',
		timezoneList: null,
		units: ['hour', 'minute', 'second', 'millisec', 'microsec'],
		support: {},
		control: null,

		/* 
		* Override the default settings for all instances of the time picker.
		* @param  {Object} settings  object - the new settings to use as defaults (anonymous object)
		* @return {Object} the manager object
		*/
		setDefaults: function (settings) {
			extendRemove(this._defaults, settings || {});
			return this;
		},

		/*
		* Create a new Timepicker instance
		*/
		_newInst: function ($input, opts) {
			var tp_inst = new Timepicker(),
				inlineSettings = {},
				fns = {},
				overrides, i;

			for (var attrName in this._defaults) {
				if (this._defaults.hasOwnProperty(attrName)) {
					var attrValue = $input.attr('time:' + attrName);
					if (attrValue) {
						try {
							inlineSettings[attrName] = eval(attrValue);
						} catch (err) {
							inlineSettings[attrName] = attrValue;
						}
					}
				}
			}

			overrides = {
				beforeShow: function (input, dp_inst) {
					if ($.isFunction(tp_inst._defaults.evnts.beforeShow)) {
						return tp_inst._defaults.evnts.beforeShow.call($input[0], input, dp_inst, tp_inst);
					}
				},
				onChangeMonthYear: function (year, month, dp_inst) {
					// Update the time as well : this prevents the time from disappearing from the $input field.
					tp_inst._updateDateTime(dp_inst);
					if ($.isFunction(tp_inst._defaults.evnts.onChangeMonthYear)) {
						tp_inst._defaults.evnts.onChangeMonthYear.call($input[0], year, month, dp_inst, tp_inst);
					}
				},
				onClose: function (dateText, dp_inst) {
					if (tp_inst.timeDefined === true && $input.val() !== '') {
						tp_inst._updateDateTime(dp_inst);
					}
					if ($.isFunction(tp_inst._defaults.evnts.onClose)) {
						tp_inst._defaults.evnts.onClose.call($input[0], dateText, dp_inst, tp_inst);
					}
				}
			};
			for (i in overrides) {
				if (overrides.hasOwnProperty(i)) {
					fns[i] = opts[i] || null;
				}
			}

			tp_inst._defaults = $.extend({}, this._defaults, inlineSettings, opts, overrides, {
				evnts: fns,
				timepicker: tp_inst // add timepicker as a property of datepicker: $.datepicker._get(dp_inst, 'timepicker');
			});
			tp_inst.amNames = $.map(tp_inst._defaults.amNames, function (val) {
				return val.toUpperCase();
			});
			tp_inst.pmNames = $.map(tp_inst._defaults.pmNames, function (val) {
				return val.toUpperCase();
			});

			// detect which units are supported
			tp_inst.support = detectSupport(
					tp_inst._defaults.timeFormat + 
					(tp_inst._defaults.pickerTimeFormat ? tp_inst._defaults.pickerTimeFormat : '') +
					(tp_inst._defaults.altTimeFormat ? tp_inst._defaults.altTimeFormat : ''));

			// controlType is string - key to our this._controls
			if (typeof(tp_inst._defaults.controlType) === 'string') {
				if (tp_inst._defaults.controlType === 'slider' && typeof($.ui.slider) === 'undefined') {
					tp_inst._defaults.controlType = 'select';
				}
				tp_inst.control = tp_inst._controls[tp_inst._defaults.controlType];
			}
			// controlType is an object and must implement create, options, value methods
			else {
				tp_inst.control = tp_inst._defaults.controlType;
			}

			// prep the timezone options
			var timezoneList = [-720, -660, -600, -570, -540, -480, -420, -360, -300, -270, -240, -210, -180, -120, -60,
					0, 60, 120, 180, 210, 240, 270, 300, 330, 345, 360, 390, 420, 480, 525, 540, 570, 600, 630, 660, 690, 720, 765, 780, 840];
			if (tp_inst._defaults.timezoneList !== null) {
				timezoneList = tp_inst._defaults.timezoneList;
			}
			var tzl = timezoneList.length, tzi = 0, tzv = null;
			if (tzl > 0 && typeof timezoneList[0] !== 'object') {
				for (; tzi < tzl; tzi++) {
					tzv = timezoneList[tzi];
					timezoneList[tzi] = { value: tzv, label: $.timepicker.timezoneOffsetString(tzv, tp_inst.support.iso8601) };
				}
			}
			tp_inst._defaults.timezoneList = timezoneList;

			// set the default units
			tp_inst.timezone = tp_inst._defaults.timezone !== null ? $.timepicker.timezoneOffsetNumber(tp_inst._defaults.timezone) :
							((new Date()).getTimezoneOffset() * -1);
			tp_inst.hour = tp_inst._defaults.hour < tp_inst._defaults.hourMin ? tp_inst._defaults.hourMin :
							tp_inst._defaults.hour > tp_inst._defaults.hourMax ? tp_inst._defaults.hourMax : tp_inst._defaults.hour;
			tp_inst.minute = tp_inst._defaults.minute < tp_inst._defaults.minuteMin ? tp_inst._defaults.minuteMin :
							tp_inst._defaults.minute > tp_inst._defaults.minuteMax ? tp_inst._defaults.minuteMax : tp_inst._defaults.minute;
			tp_inst.second = tp_inst._defaults.second < tp_inst._defaults.secondMin ? tp_inst._defaults.secondMin :
							tp_inst._defaults.second > tp_inst._defaults.secondMax ? tp_inst._defaults.secondMax : tp_inst._defaults.second;
			tp_inst.millisec = tp_inst._defaults.millisec < tp_inst._defaults.millisecMin ? tp_inst._defaults.millisecMin :
							tp_inst._defaults.millisec > tp_inst._defaults.millisecMax ? tp_inst._defaults.millisecMax : tp_inst._defaults.millisec;
			tp_inst.microsec = tp_inst._defaults.microsec < tp_inst._defaults.microsecMin ? tp_inst._defaults.microsecMin :
							tp_inst._defaults.microsec > tp_inst._defaults.microsecMax ? tp_inst._defaults.microsecMax : tp_inst._defaults.microsec;
			tp_inst.ampm = '';
			tp_inst.$input = $input;

			if (tp_inst._defaults.altField) {
				tp_inst.$altInput = $(tp_inst._defaults.altField).css({
					cursor: 'pointer'
				}).focus(function () {
					$input.trigger("focus");
				});
			}

			if (tp_inst._defaults.minDate === 0 || tp_inst._defaults.minDateTime === 0) {
				tp_inst._defaults.minDate = new Date();
			}
			if (tp_inst._defaults.maxDate === 0 || tp_inst._defaults.maxDateTime === 0) {
				tp_inst._defaults.maxDate = new Date();
			}

			// datepicker needs minDate/maxDate, timepicker needs minDateTime/maxDateTime..
			if (tp_inst._defaults.minDate !== undefined && tp_inst._defaults.minDate instanceof Date) {
				tp_inst._defaults.minDateTime = new Date(tp_inst._defaults.minDate.getTime());
			}
			if (tp_inst._defaults.minDateTime !== undefined && tp_inst._defaults.minDateTime instanceof Date) {
				tp_inst._defaults.minDate = new Date(tp_inst._defaults.minDateTime.getTime());
			}
			if (tp_inst._defaults.maxDate !== undefined && tp_inst._defaults.maxDate instanceof Date) {
				tp_inst._defaults.maxDateTime = new Date(tp_inst._defaults.maxDate.getTime());
			}
			if (tp_inst._defaults.maxDateTime !== undefined && tp_inst._defaults.maxDateTime instanceof Date) {
				tp_inst._defaults.maxDate = new Date(tp_inst._defaults.maxDateTime.getTime());
			}
			tp_inst.$input.bind('focus', function () {
				tp_inst._onFocus();
			});

			return tp_inst;
		},

		/*
		* add our sliders to the calendar
		*/
		_addTimePicker: function (dp_inst) {
			var currDT = (this.$altInput && this._defaults.altFieldTimeOnly) ? this.$input.val() + ' ' + this.$altInput.val() : this.$input.val();

			this.timeDefined = this._parseTime(currDT);
			this._limitMinMaxDateTime(dp_inst, false);
			this._injectTimePicker();
		},

		/*
		* parse the time string from input value or _setTime
		*/
		_parseTime: function (timeString, withDate) {
			if (!this.inst) {
				this.inst = $.datepicker._getInst(this.$input[0]);
			}

			if (withDate || !this._defaults.timeOnly) {
				var dp_dateFormat = $.datepicker._get(this.inst, 'dateFormat');
				try {
					var parseRes = parseDateTimeInternal(dp_dateFormat, this._defaults.timeFormat, timeString, $.datepicker._getFormatConfig(this.inst), this._defaults);
					if (!parseRes.timeObj) {
						return false;
					}
					$.extend(this, parseRes.timeObj);
				} catch (err) {
					$.timepicker.log("Error parsing the date/time string: " + err +
									"\ndate/time string = " + timeString +
									"\ntimeFormat = " + this._defaults.timeFormat +
									"\ndateFormat = " + dp_dateFormat);
					return false;
				}
				return true;
			} else {
				var timeObj = $.datepicker.parseTime(this._defaults.timeFormat, timeString, this._defaults);
				if (!timeObj) {
					return false;
				}
				$.extend(this, timeObj);
				return true;
			}
		},

		/*
		* generate and inject html for timepicker into ui datepicker
		*/
		_injectTimePicker: function () {
			var $dp = this.inst.dpDiv,
				o = this.inst.settings,
				tp_inst = this,
				litem = '',
				uitem = '',
				show = null,
				max = {},
				gridSize = {},
				size = null,
				i = 0,
				l = 0;

			// Prevent displaying twice
			if ($dp.find("div.ui-timepicker-div").length === 0 && o.showTimepicker) {
				var noDisplay = ' style="display:none;"',
					html = '<div class="ui-timepicker-div' + (o.isRTL ? ' ui-timepicker-rtl' : '') + '"><dl>' + '<dt class="ui_tpicker_time_label"' + ((o.showTime) ? '' : noDisplay) + '>' + o.timeText + '</dt>' +
								'<dd class="ui_tpicker_time"' + ((o.showTime) ? '' : noDisplay) + '></dd>';

				// Create the markup
				for (i = 0, l = this.units.length; i < l; i++) {
					litem = this.units[i];
					uitem = litem.substr(0, 1).toUpperCase() + litem.substr(1);
					show = o['show' + uitem] !== null ? o['show' + uitem] : this.support[litem];

					// Added by Peter Medeiros:
					// - Figure out what the hour/minute/second max should be based on the step values.
					// - Example: if stepMinute is 15, then minMax is 45.
					max[litem] = parseInt((o[litem + 'Max'] - ((o[litem + 'Max'] - o[litem + 'Min']) % o['step' + uitem])), 10);
					gridSize[litem] = 0;

					html += '<dt class="ui_tpicker_' + litem + '_label"' + (show ? '' : noDisplay) + '>' + o[litem + 'Text'] + '</dt>' +
								'<dd class="ui_tpicker_' + litem + '"><div class="ui_tpicker_' + litem + '_slider"' + (show ? '' : noDisplay) + '></div>';

					if (show && o[litem + 'Grid'] > 0) {
						html += '<div style="padding-left: 1px"><table class="ui-tpicker-grid-label"><tr>';

						if (litem === 'hour') {
							for (var h = o[litem + 'Min']; h <= max[litem]; h += parseInt(o[litem + 'Grid'], 10)) {
								gridSize[litem]++;
								var tmph = $.datepicker.formatTime(this.support.ampm ? 'hht' : 'HH', {hour: h}, o);
								html += '<td data-for="' + litem + '">' + tmph + '</td>';
							}
						}
						else {
							for (var m = o[litem + 'Min']; m <= max[litem]; m += parseInt(o[litem + 'Grid'], 10)) {
								gridSize[litem]++;
								html += '<td data-for="' + litem + '">' + ((m < 10) ? '0' : '') + m + '</td>';
							}
						}

						html += '</tr></table></div>';
					}
					html += '</dd>';
				}
				
				// Timezone
				var showTz = o.showTimezone !== null ? o.showTimezone : this.support.timezone;
				html += '<dt class="ui_tpicker_timezone_label"' + (showTz ? '' : noDisplay) + '>' + o.timezoneText + '</dt>';
				html += '<dd class="ui_tpicker_timezone" ' + (showTz ? '' : noDisplay) + '></dd>';

				// Create the elements from string
				html += '</dl></div>';
				var $tp = $(html);

				// if we only want time picker...
				if (o.timeOnly === true) {
					$tp.prepend('<div class="ui-widget-header ui-helper-clearfix ui-corner-all">' + '<div class="ui-datepicker-title">' + o.timeOnlyTitle + '</div>' + '</div>');
					$dp.find('.ui-datepicker-header, .ui-datepicker-calendar').hide();
				}
				
				// add sliders, adjust grids, add events
				for (i = 0, l = tp_inst.units.length; i < l; i++) {
					litem = tp_inst.units[i];
					uitem = litem.substr(0, 1).toUpperCase() + litem.substr(1);
					show = o['show' + uitem] !== null ? o['show' + uitem] : this.support[litem];

					// add the slider
					tp_inst[litem + '_slider'] = tp_inst.control.create(tp_inst, $tp.find('.ui_tpicker_' + litem + '_slider'), litem, tp_inst[litem], o[litem + 'Min'], max[litem], o['step' + uitem]);

					// adjust the grid and add click event
					if (show && o[litem + 'Grid'] > 0) {
						size = 100 * gridSize[litem] * o[litem + 'Grid'] / (max[litem] - o[litem + 'Min']);
						$tp.find('.ui_tpicker_' + litem + ' table').css({
							width: size + "%",
							marginLeft: o.isRTL ? '0' : ((size / (-2 * gridSize[litem])) + "%"),
							marginRight: o.isRTL ? ((size / (-2 * gridSize[litem])) + "%") : '0',
							borderCollapse: 'collapse'
						}).find("td").click(function (e) {
								var $t = $(this),
									h = $t.html(),
									n = parseInt(h.replace(/[^0-9]/g), 10),
									ap = h.replace(/[^apm]/ig),
									f = $t.data('for'); // loses scope, so we use data-for

								if (f === 'hour') {
									if (ap.indexOf('p') !== -1 && n < 12) {
										n += 12;
									}
									else {
										if (ap.indexOf('a') !== -1 && n === 12) {
											n = 0;
										}
									}
								}
								
								tp_inst.control.value(tp_inst, tp_inst[f + '_slider'], litem, n);

								tp_inst._onTimeChange();
								tp_inst._onSelectHandler();
							}).css({
								cursor: 'pointer',
								width: (100 / gridSize[litem]) + '%',
								textAlign: 'center',
								overflow: 'hidden'
							});
					} // end if grid > 0
				} // end for loop

				// Add timezone options
				this.timezone_select = $tp.find('.ui_tpicker_timezone').append('<select></select>').find("select");
				$.fn.append.apply(this.timezone_select,
				$.map(o.timezoneList, function (val, idx) {
					return $("<option />").val(typeof val === "object" ? val.value : val).text(typeof val === "object" ? val.label : val);
				}));
				if (typeof(this.timezone) !== "undefined" && this.timezone !== null && this.timezone !== "") {
					var local_timezone = (new Date(this.inst.selectedYear, this.inst.selectedMonth, this.inst.selectedDay, 12)).getTimezoneOffset() * -1;
					if (local_timezone === this.timezone) {
						selectLocalTimezone(tp_inst);
					} else {
						this.timezone_select.val(this.timezone);
					}
				} else {
					if (typeof(this.hour) !== "undefined" && this.hour !== null && this.hour !== "") {
						this.timezone_select.val(o.timezone);
					} else {
						selectLocalTimezone(tp_inst);
					}
				}
				this.timezone_select.change(function () {
					tp_inst._onTimeChange();
					tp_inst._onSelectHandler();
				});
				// End timezone options
				
				// inject timepicker into datepicker
				var $buttonPanel = $dp.find('.ui-datepicker-buttonpane');
				if ($buttonPanel.length) {
					$buttonPanel.before($tp);
				} else {
					$dp.append($tp);
				}

				this.$timeObj = $tp.find('.ui_tpicker_time');

				if (this.inst !== null) {
					var timeDefined = this.timeDefined;
					this._onTimeChange();
					this.timeDefined = timeDefined;
				}

				// slideAccess integration: http://trentrichardson.com/2011/11/11/jquery-ui-sliders-and-touch-accessibility/
				if (this._defaults.addSliderAccess) {
					var sliderAccessArgs = this._defaults.sliderAccessArgs,
						rtl = this._defaults.isRTL;
					sliderAccessArgs.isRTL = rtl;
						
					setTimeout(function () { // fix for inline mode
						if ($tp.find('.ui-slider-access').length === 0) {
							$tp.find('.ui-slider:visible').sliderAccess(sliderAccessArgs);

							// fix any grids since sliders are shorter
							var sliderAccessWidth = $tp.find('.ui-slider-access:eq(0)').outerWidth(true);
							if (sliderAccessWidth) {
								$tp.find('table:visible').each(function () {
									var $g = $(this),
										oldWidth = $g.outerWidth(),
										oldMarginLeft = $g.css(rtl ? 'marginRight' : 'marginLeft').toString().replace('%', ''),
										newWidth = oldWidth - sliderAccessWidth,
										newMarginLeft = ((oldMarginLeft * newWidth) / oldWidth) + '%',
										css = { width: newWidth, marginRight: 0, marginLeft: 0 };
									css[rtl ? 'marginRight' : 'marginLeft'] = newMarginLeft;
									$g.css(css);
								});
							}
						}
					}, 10);
				}
				// end slideAccess integration

				tp_inst._limitMinMaxDateTime(this.inst, true);
			}
		},

		/*
		* This function tries to limit the ability to go outside the
		* min/max date range
		*/
		_limitMinMaxDateTime: function (dp_inst, adjustSliders) {
			var o = this._defaults,
				dp_date = new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay);

			if (!this._defaults.showTimepicker) {
				return;
			} // No time so nothing to check here

			if ($.datepicker._get(dp_inst, 'minDateTime') !== null && $.datepicker._get(dp_inst, 'minDateTime') !== undefined && dp_date) {
				var minDateTime = $.datepicker._get(dp_inst, 'minDateTime'),
					minDateTimeDate = new Date(minDateTime.getFullYear(), minDateTime.getMonth(), minDateTime.getDate(), 0, 0, 0, 0);

				if (this.hourMinOriginal === null || this.minuteMinOriginal === null || this.secondMinOriginal === null || this.millisecMinOriginal === null || this.microsecMinOriginal === null) {
					this.hourMinOriginal = o.hourMin;
					this.minuteMinOriginal = o.minuteMin;
					this.secondMinOriginal = o.secondMin;
					this.millisecMinOriginal = o.millisecMin;
					this.microsecMinOriginal = o.microsecMin;
				}

				if (dp_inst.settings.timeOnly || minDateTimeDate.getTime() === dp_date.getTime()) {
					this._defaults.hourMin = minDateTime.getHours();
					if (this.hour <= this._defaults.hourMin) {
						this.hour = this._defaults.hourMin;
						this._defaults.minuteMin = minDateTime.getMinutes();
						if (this.minute <= this._defaults.minuteMin) {
							this.minute = this._defaults.minuteMin;
							this._defaults.secondMin = minDateTime.getSeconds();
							if (this.second <= this._defaults.secondMin) {
								this.second = this._defaults.secondMin;
								this._defaults.millisecMin = minDateTime.getMilliseconds();
								if (this.millisec <= this._defaults.millisecMin) {
									this.millisec = this._defaults.millisecMin;
									this._defaults.microsecMin = minDateTime.getMicroseconds();
								} else {
									if (this.microsec < this._defaults.microsecMin) {
										this.microsec = this._defaults.microsecMin;
									}
									this._defaults.microsecMin = this.microsecMinOriginal;
								}
							} else {
								this._defaults.millisecMin = this.millisecMinOriginal;
								this._defaults.microsecMin = this.microsecMinOriginal;
							}
						} else {
							this._defaults.secondMin = this.secondMinOriginal;
							this._defaults.millisecMin = this.millisecMinOriginal;
							this._defaults.microsecMin = this.microsecMinOriginal;
						}
					} else {
						this._defaults.minuteMin = this.minuteMinOriginal;
						this._defaults.secondMin = this.secondMinOriginal;
						this._defaults.millisecMin = this.millisecMinOriginal;
						this._defaults.microsecMin = this.microsecMinOriginal;
					}
				} else {
					this._defaults.hourMin = this.hourMinOriginal;
					this._defaults.minuteMin = this.minuteMinOriginal;
					this._defaults.secondMin = this.secondMinOriginal;
					this._defaults.millisecMin = this.millisecMinOriginal;
					this._defaults.microsecMin = this.microsecMinOriginal;
				}
			}

			if ($.datepicker._get(dp_inst, 'maxDateTime') !== null && $.datepicker._get(dp_inst, 'maxDateTime') !== undefined && dp_date) {
				var maxDateTime = $.datepicker._get(dp_inst, 'maxDateTime'),
					maxDateTimeDate = new Date(maxDateTime.getFullYear(), maxDateTime.getMonth(), maxDateTime.getDate(), 0, 0, 0, 0);

				if (this.hourMaxOriginal === null || this.minuteMaxOriginal === null || this.secondMaxOriginal === null || this.millisecMaxOriginal === null) {
					this.hourMaxOriginal = o.hourMax;
					this.minuteMaxOriginal = o.minuteMax;
					this.secondMaxOriginal = o.secondMax;
					this.millisecMaxOriginal = o.millisecMax;
					this.microsecMaxOriginal = o.microsecMax;
				}

				if (dp_inst.settings.timeOnly || maxDateTimeDate.getTime() === dp_date.getTime()) {
					this._defaults.hourMax = maxDateTime.getHours();
					if (this.hour >= this._defaults.hourMax) {
						this.hour = this._defaults.hourMax;
						this._defaults.minuteMax = maxDateTime.getMinutes();
						if (this.minute >= this._defaults.minuteMax) {
							this.minute = this._defaults.minuteMax;
							this._defaults.secondMax = maxDateTime.getSeconds();
							if (this.second >= this._defaults.secondMax) {
								this.second = this._defaults.secondMax;
								this._defaults.millisecMax = maxDateTime.getMilliseconds();
								if (this.millisec >= this._defaults.millisecMax) {
									this.millisec = this._defaults.millisecMax;
									this._defaults.microsecMax = maxDateTime.getMicroseconds();
								} else {
									if (this.microsec > this._defaults.microsecMax) {
										this.microsec = this._defaults.microsecMax;
									}
									this._defaults.microsecMax = this.microsecMaxOriginal;
								}
							} else {
								this._defaults.millisecMax = this.millisecMaxOriginal;
								this._defaults.microsecMax = this.microsecMaxOriginal;
							}
						} else {
							this._defaults.secondMax = this.secondMaxOriginal;
							this._defaults.millisecMax = this.millisecMaxOriginal;
							this._defaults.microsecMax = this.microsecMaxOriginal;
						}
					} else {
						this._defaults.minuteMax = this.minuteMaxOriginal;
						this._defaults.secondMax = this.secondMaxOriginal;
						this._defaults.millisecMax = this.millisecMaxOriginal;
						this._defaults.microsecMax = this.microsecMaxOriginal;
					}
				} else {
					this._defaults.hourMax = this.hourMaxOriginal;
					this._defaults.minuteMax = this.minuteMaxOriginal;
					this._defaults.secondMax = this.secondMaxOriginal;
					this._defaults.millisecMax = this.millisecMaxOriginal;
					this._defaults.microsecMax = this.microsecMaxOriginal;
				}
			}

			if (adjustSliders !== undefined && adjustSliders === true) {
				var hourMax = parseInt((this._defaults.hourMax - ((this._defaults.hourMax - this._defaults.hourMin) % this._defaults.stepHour)), 10),
					minMax = parseInt((this._defaults.minuteMax - ((this._defaults.minuteMax - this._defaults.minuteMin) % this._defaults.stepMinute)), 10),
					secMax = parseInt((this._defaults.secondMax - ((this._defaults.secondMax - this._defaults.secondMin) % this._defaults.stepSecond)), 10),
					millisecMax = parseInt((this._defaults.millisecMax - ((this._defaults.millisecMax - this._defaults.millisecMin) % this._defaults.stepMillisec)), 10),
					microsecMax = parseInt((this._defaults.microsecMax - ((this._defaults.microsecMax - this._defaults.microsecMin) % this._defaults.stepMicrosec)), 10);

				if (this.hour_slider) {
					this.control.options(this, this.hour_slider, 'hour', { min: this._defaults.hourMin, max: hourMax });
					this.control.value(this, this.hour_slider, 'hour', this.hour - (this.hour % this._defaults.stepHour));
				}
				if (this.minute_slider) {
					this.control.options(this, this.minute_slider, 'minute', { min: this._defaults.minuteMin, max: minMax });
					this.control.value(this, this.minute_slider, 'minute', this.minute - (this.minute % this._defaults.stepMinute));
				}
				if (this.second_slider) {
					this.control.options(this, this.second_slider, 'second', { min: this._defaults.secondMin, max: secMax });
					this.control.value(this, this.second_slider, 'second', this.second - (this.second % this._defaults.stepSecond));
				}
				if (this.millisec_slider) {
					this.control.options(this, this.millisec_slider, 'millisec', { min: this._defaults.millisecMin, max: millisecMax });
					this.control.value(this, this.millisec_slider, 'millisec', this.millisec - (this.millisec % this._defaults.stepMillisec));
				}
				if (this.microsec_slider) {
					this.control.options(this, this.microsec_slider, 'microsec', { min: this._defaults.microsecMin, max: microsecMax });
					this.control.value(this, this.microsec_slider, 'microsec', this.microsec - (this.microsec % this._defaults.stepMicrosec));
				}
			}

		},

		/*
		* when a slider moves, set the internal time...
		* on time change is also called when the time is updated in the text field
		*/
		_onTimeChange: function () {
			if (!this._defaults.showTimepicker) {
                                return;
			}
			var hour = (this.hour_slider) ? this.control.value(this, this.hour_slider, 'hour') : false,
				minute = (this.minute_slider) ? this.control.value(this, this.minute_slider, 'minute') : false,
				second = (this.second_slider) ? this.control.value(this, this.second_slider, 'second') : false,
				millisec = (this.millisec_slider) ? this.control.value(this, this.millisec_slider, 'millisec') : false,
				microsec = (this.microsec_slider) ? this.control.value(this, this.microsec_slider, 'microsec') : false,
				timezone = (this.timezone_select) ? this.timezone_select.val() : false,
				o = this._defaults,
				pickerTimeFormat = o.pickerTimeFormat || o.timeFormat,
				pickerTimeSuffix = o.pickerTimeSuffix || o.timeSuffix;

			if (typeof(hour) === 'object') {
				hour = false;
			}
			if (typeof(minute) === 'object') {
				minute = false;
			}
			if (typeof(second) === 'object') {
				second = false;
			}
			if (typeof(millisec) === 'object') {
				millisec = false;
			}
			if (typeof(microsec) === 'object') {
				microsec = false;
			}
			if (typeof(timezone) === 'object') {
				timezone = false;
			}

			if (hour !== false) {
				hour = parseInt(hour, 10);
			}
			if (minute !== false) {
				minute = parseInt(minute, 10);
			}
			if (second !== false) {
				second = parseInt(second, 10);
			}
			if (millisec !== false) {
				millisec = parseInt(millisec, 10);
			}
			if (microsec !== false) {
				microsec = parseInt(microsec, 10);
			}

			var ampm = o[hour < 12 ? 'amNames' : 'pmNames'][0];

			// If the update was done in the input field, the input field should not be updated.
			// If the update was done using the sliders, update the input field.
			var hasChanged = (hour !== this.hour || minute !== this.minute || second !== this.second || millisec !== this.millisec || microsec !== this.microsec || 
					(this.ampm.length > 0 && (hour < 12) !== ($.inArray(this.ampm.toUpperCase(), this.amNames) !== -1)) || (this.timezone !== null && timezone !== this.timezone));

			if (hasChanged) {

				if (hour !== false) {
					this.hour = hour;
				}
				if (minute !== false) {
					this.minute = minute;
				}
				if (second !== false) {
					this.second = second;
				}
				if (millisec !== false) {
					this.millisec = millisec;
				}
				if (microsec !== false) {
					this.microsec = microsec;
				}
				if (timezone !== false) {
					this.timezone = timezone;
				}

				if (!this.inst) {
					this.inst = $.datepicker._getInst(this.$input[0]);
				}

				this._limitMinMaxDateTime(this.inst, true);
			}
			if (this.support.ampm) {
				this.ampm = ampm;
			}

			// Updates the time within the timepicker
			this.formattedTime = $.datepicker.formatTime(o.timeFormat, this, o);
			if (this.$timeObj) {
				if (pickerTimeFormat === o.timeFormat) {
					this.$timeObj.text(this.formattedTime + pickerTimeSuffix);
				}
				else {
					this.$timeObj.text($.datepicker.formatTime(pickerTimeFormat, this, o) + pickerTimeSuffix);
				}
			}

			this.timeDefined = true;
			if (hasChanged) {
				this._updateDateTime();
			}
		},

		/*
		* call custom onSelect.
		* bind to sliders slidestop, and grid click.
		*/
		_onSelectHandler: function () {
			var onSelect = this._defaults.onSelect || this.inst.settings.onSelect;
			var inputEl = this.$input ? this.$input[0] : null;
			if (onSelect && inputEl) {
				onSelect.apply(inputEl, [this.formattedDateTime, this]);
			}
		},

		/*
		* update our input with the new date time..
		*/
		_updateDateTime: function (dp_inst) {
			dp_inst = this.inst || dp_inst;
			var dtTmp = (dp_inst.currentYear > 0? 
							new Date(dp_inst.currentYear, dp_inst.currentMonth, dp_inst.currentDay) : 
							new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay)),
				dt = $.datepicker._daylightSavingAdjust(dtTmp),
				//dt = $.datepicker._daylightSavingAdjust(new Date(dp_inst.selectedYear, dp_inst.selectedMonth, dp_inst.selectedDay)),
				//dt = $.datepicker._daylightSavingAdjust(new Date(dp_inst.currentYear, dp_inst.currentMonth, dp_inst.currentDay)),
				dateFmt = $.datepicker._get(dp_inst, 'dateFormat'),
				formatCfg = $.datepicker._getFormatConfig(dp_inst),
				timeAvailable = dt !== null && this.timeDefined;
			this.formattedDate = $.datepicker.formatDate(dateFmt, (dt === null ? new Date() : dt), formatCfg);
			var formattedDateTime = this.formattedDate;
			
			// if a slider was changed but datepicker doesn't have a value yet, set it
			if (dp_inst.lastVa === "") {
                dp_inst.currentYear = dp_inst.selectedYear;
                dp_inst.currentMonth = dp_inst.selectedMonth;
                dp_inst.currentDay = dp_inst.selectedDay;
            }

			/*
			* remove following lines to force every changes in date picker to change the input value
			* Bug descriptions: when an input field has a default value, and click on the field to pop up the date picker. 
			* If the user manually empty the value in the input field, the date picker will never change selected value.
			*/
			//if (dp_inst.lastVal !== undefined && (dp_inst.lastVal.length > 0 && this.$input.val().length === 0)) {
			//	return;
			//}

			if (this._defaults.timeOnly === true) {
				formattedDateTime = this.formattedTime;
			} else if (this._defaults.timeOnly !== true && (this._defaults.alwaysSetTime || timeAvailable)) {
				formattedDateTime += this._defaults.separator + this.formattedTime + this._defaults.timeSuffix;
			}

			this.formattedDateTime = formattedDateTime;

			if (!this._defaults.showTimepicker) {
				this.$input.val(this.formattedDate);
			} else if (this.$altInput && this._defaults.timeOnly === false && this._defaults.altFieldTimeOnly === true) {
				this.$altInput.val(this.formattedTime);
				this.$input.val(this.formattedDate);
			} else if (this.$altInput) {
				this.$input.val(formattedDateTime);
				var altFormattedDateTime = '',
					altSeparator = this._defaults.altSeparator ? this._defaults.altSeparator : this._defaults.separator,
					altTimeSuffix = this._defaults.altTimeSuffix ? this._defaults.altTimeSuffix : this._defaults.timeSuffix;
				
				if (!this._defaults.timeOnly) {
					if (this._defaults.altFormat) {
						altFormattedDateTime = $.datepicker.formatDate(this._defaults.altFormat, (dt === null ? new Date() : dt), formatCfg);
					}
					else {
						altFormattedDateTime = this.formattedDate;
					}

					if (altFormattedDateTime) {
						altFormattedDateTime += altSeparator;
					}
				}

				if (this._defaults.altTimeFormat) {
					altFormattedDateTime += $.datepicker.formatTime(this._defaults.altTimeFormat, this, this._defaults) + altTimeSuffix;
				}
				else {
					altFormattedDateTime += this.formattedTime + altTimeSuffix;
				}
				this.$altInput.val(altFormattedDateTime);
			} else {
				this.$input.val(formattedDateTime);
			}

			this.$input.trigger("change");
		},

		_onFocus: function () {
			if (!this.$input.val() && this._defaults.defaultValue) {
				this.$input.val(this._defaults.defaultValue);
				var inst = $.datepicker._getInst(this.$input.get(0)),
					tp_inst = $.datepicker._get(inst, 'timepicker');
				if (tp_inst) {
					if (tp_inst._defaults.timeOnly && (inst.input.val() !== inst.lastVal)) {
						try {
							$.datepicker._updateDatepicker(inst);
						} catch (err) {
							$.timepicker.log(err);
						}
					}
				}
			}
		},

		/*
		* Small abstraction to control types
		* We can add more, just be sure to follow the pattern: create, options, value
		*/
		_controls: {
			// slider methods
			slider: {
				create: function (tp_inst, obj, unit, val, min, max, step) {
					var rtl = tp_inst._defaults.isRTL; // if rtl go -60->0 instead of 0->60
					return obj.prop('slide', null).slider({
						orientation: "horizontal",
						value: rtl ? val * -1 : val,
						min: rtl ? max * -1 : min,
						max: rtl ? min * -1 : max,
						step: step,
						slide: function (event, ui) {
							tp_inst.control.value(tp_inst, $(this), unit, rtl ? ui.value * -1 : ui.value);
							tp_inst._onTimeChange();
						},
						stop: function (event, ui) {
							tp_inst._onSelectHandler();
						}
					});	
				},
				options: function (tp_inst, obj, unit, opts, val) {
					if (tp_inst._defaults.isRTL) {
						if (typeof(opts) === 'string') {
							if (opts === 'min' || opts === 'max') {
								if (val !== undefined) {
									return obj.slider(opts, val * -1);
								}
								return Math.abs(obj.slider(opts));
							}
							return obj.slider(opts);
						}
						var min = opts.min, 
							max = opts.max;
						opts.min = opts.max = null;
						if (min !== undefined) {
							opts.max = min * -1;
						}
						if (max !== undefined) {
							opts.min = max * -1;
						}
						return obj.slider(opts);
					}
					if (typeof(opts) === 'string' && val !== undefined) {
						return obj.slider(opts, val);
					}
					return obj.slider(opts);
				},
				value: function (tp_inst, obj, unit, val) {
					if (tp_inst._defaults.isRTL) {
						if (val !== undefined) {
							return obj.slider('value', val * -1);
						}
						return Math.abs(obj.slider('value'));
					}
					if (val !== undefined) {
						return obj.slider('value', val);
					}
					return obj.slider('value');
				}
			},
			// select methods
			select: {
				create: function (tp_inst, obj, unit, val, min, max, step) {
					var sel = '<select class="ui-timepicker-select" data-unit="' + unit + '" data-min="' + min + '" data-max="' + max + '" data-step="' + step + '">',
						format = tp_inst._defaults.pickerTimeFormat || tp_inst._defaults.timeFormat;

					for (var i = min; i <= max; i += step) {
						sel += '<option value="' + i + '"' + (i === val ? ' selected' : '') + '>';
						if (unit === 'hour') {
							sel += $.datepicker.formatTime($.trim(format.replace(/[^ht ]/ig, '')), {hour: i}, tp_inst._defaults);
						}
						else if (unit === 'millisec' || unit === 'microsec' || i >= 10) { sel += i; }
						else {sel += '0' + i.toString(); }
						sel += '</option>';
					}
					sel += '</select>';

					obj.children('select').remove();

					$(sel).appendTo(obj).change(function (e) {
						tp_inst._onTimeChange();
						tp_inst._onSelectHandler();
					});

					return obj;
				},
				options: function (tp_inst, obj, unit, opts, val) {
					var o = {},
						$t = obj.children('select');
					if (typeof(opts) === 'string') {
						if (val === undefined) {
							return $t.data(opts);
						}
						o[opts] = val;	
					}
					else { o = opts; }
					return tp_inst.control.create(tp_inst, obj, $t.data('unit'), $t.val(), o.min || $t.data('min'), o.max || $t.data('max'), o.step || $t.data('step'));
				},
				value: function (tp_inst, obj, unit, val) {
					var $t = obj.children('select');
					if (val !== undefined) {
						return $t.val(val);
					}
					return $t.val();
				}
			}
		} // end _controls

	});

	$.fn.extend({
		/*
		* shorthand just to use timepicker.
		*/
		timepicker: function (o) {
			o = o || {};
			var tmp_args = Array.prototype.slice.call(arguments);

			if (typeof o === 'object') {
				tmp_args[0] = $.extend(o, {
					timeOnly: true
				});
			}

			return $(this).each(function () {
				$.fn.datetimepicker.apply($(this), tmp_args);
			});
		},

		/*
		* extend timepicker to datepicker
		*/
		datetimepicker: function (o) {
			o = o || {};
			var tmp_args = arguments;

			if (typeof(o) === 'string') {
				if (o === 'getDate') {
					return $.fn.datepicker.apply($(this[0]), tmp_args);
				} else {
					return this.each(function () {
						var $t = $(this);
						$t.datepicker.apply($t, tmp_args);
					});
				}
			} else {
				return this.each(function () {
					var $t = $(this);
					$t.datepicker($.timepicker._newInst($t, o)._defaults);
				});
			}
		}
	});

	/*
	* Public Utility to parse date and time
	*/
	$.datepicker.parseDateTime = function (dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) {
		var parseRes = parseDateTimeInternal(dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings);
		if (parseRes.timeObj) {
			var t = parseRes.timeObj;
			parseRes.date.setHours(t.hour, t.minute, t.second, t.millisec);
			parseRes.date.setMicroseconds(t.microsec);
		}

		return parseRes.date;
	};

	/*
	* Public utility to parse time
	*/
	$.datepicker.parseTime = function (timeFormat, timeString, options) {
		var o = extendRemove(extendRemove({}, $.timepicker._defaults), options || {}),
			iso8601 = (timeFormat.replace(/\'.*?\'/g, '').indexOf('Z') !== -1);

		// Strict parse requires the timeString to match the timeFormat exactly
		var strictParse = function (f, s, o) {

			// pattern for standard and localized AM/PM markers
			var getPatternAmpm = function (amNames, pmNames) {
				var markers = [];
				if (amNames) {
					$.merge(markers, amNames);
				}
				if (pmNames) {
					$.merge(markers, pmNames);
				}
				markers = $.map(markers, function (val) {
					return val.replace(/[.*+?|()\[\]{}\\]/g, '\\$&');
				});
				return '(' + markers.join('|') + ')?';
			};

			// figure out position of time elements.. cause js cant do named captures
			var getFormatPositions = function (timeFormat) {
				var finds = timeFormat.toLowerCase().match(/(h{1,2}|m{1,2}|s{1,2}|l{1}|c{1}|t{1,2}|z|'.*?')/g),
					orders = {
						h: -1,
						m: -1,
						s: -1,
						l: -1,
						c: -1,
						t: -1,
						z: -1
					};

				if (finds) {
					for (var i = 0; i < finds.length; i++) {
						if (orders[finds[i].toString().charAt(0)] === -1) {
							orders[finds[i].toString().charAt(0)] = i + 1;
						}
					}
				}
				return orders;
			};

			var regstr = '^' + f.toString()
					.replace(/([hH]{1,2}|mm?|ss?|[tT]{1,2}|[zZ]|[lc]|'.*?')/g, function (match) {
							var ml = match.length;
							switch (match.charAt(0).toLowerCase()) {
							case 'h':
								return ml === 1 ? '(\\d?\\d)' : '(\\d{' + ml + '})';
							case 'm':
								return ml === 1 ? '(\\d?\\d)' : '(\\d{' + ml + '})';
							case 's':
								return ml === 1 ? '(\\d?\\d)' : '(\\d{' + ml + '})';
							case 'l':
								return '(\\d?\\d?\\d)';
							case 'c':
								return '(\\d?\\d?\\d)';
							case 'z':
								return '(z|[-+]\\d\\d:?\\d\\d|\\S+)?';
							case 't':
								return getPatternAmpm(o.amNames, o.pmNames);
							default:    // literal escaped in quotes
								return '(' + match.replace(/\'/g, "").replace(/(\.|\$|\^|\\|\/|\(|\)|\[|\]|\?|\+|\*)/g, function (m) { return "\\" + m; }) + ')?';
							}
						})
					.replace(/\s/g, '\\s?') +
					o.timeSuffix + '$',
				order = getFormatPositions(f),
				ampm = '',
				treg;

			treg = s.match(new RegExp(regstr, 'i'));

			var resTime = {
				hour: 0,
				minute: 0,
				second: 0,
				millisec: 0,
				microsec: 0
			};

			if (treg) {
				if (order.t !== -1) {
					if (treg[order.t] === undefined || treg[order.t].length === 0) {
						ampm = '';
						resTime.ampm = '';
					} else {
						ampm = $.inArray(treg[order.t].toUpperCase(), o.amNames) !== -1 ? 'AM' : 'PM';
						resTime.ampm = o[ampm === 'AM' ? 'amNames' : 'pmNames'][0];
					}
				}

				if (order.h !== -1) {
					if (ampm === 'AM' && treg[order.h] === '12') {
						resTime.hour = 0; // 12am = 0 hour
					} else {
						if (ampm === 'PM' && treg[order.h] !== '12') {
							resTime.hour = parseInt(treg[order.h], 10) + 12; // 12pm = 12 hour, any other pm = hour + 12
						} else {
							resTime.hour = Number(treg[order.h]);
						}
					}
				}

				if (order.m !== -1) {
					resTime.minute = Number(treg[order.m]);
				}
				if (order.s !== -1) {
					resTime.second = Number(treg[order.s]);
				}
				if (order.l !== -1) {
					resTime.millisec = Number(treg[order.l]);
				}
				if (order.c !== -1) {
					resTime.microsec = Number(treg[order.c]);
				}
				if (order.z !== -1 && treg[order.z] !== undefined) {
					resTime.timezone = $.timepicker.timezoneOffsetNumber(treg[order.z]);
				}


				return resTime;
			}
			return false;
		};// end strictParse

		// First try JS Date, if that fails, use strictParse
		var looseParse = function (f, s, o) {
			try {
				var d = new Date('2012-01-01 ' + s);
				if (isNaN(d.getTime())) {
					d = new Date('2012-01-01T' + s);
					if (isNaN(d.getTime())) {
						d = new Date('01/01/2012 ' + s);
						if (isNaN(d.getTime())) {
							throw "Unable to parse time with native Date: " + s;
						}
					}
				}

				return {
					hour: d.getHours(),
					minute: d.getMinutes(),
					second: d.getSeconds(),
					millisec: d.getMilliseconds(),
					microsec: d.getMicroseconds(),
					timezone: d.getTimezoneOffset() * -1
				};
			}
			catch (err) {
				try {
					return strictParse(f, s, o);
				}
				catch (err2) {
					$.timepicker.log("Unable to parse \ntimeString: " + s + "\ntimeFormat: " + f);
				}				
			}
			return false;
		}; // end looseParse
		
		if (typeof o.parse === "function") {
			return o.parse(timeFormat, timeString, o);
		}
		if (o.parse === 'loose') {
			return looseParse(timeFormat, timeString, o);
		}
		return strictParse(timeFormat, timeString, o);
	};

	/**
	 * Public utility to format the time
	 * @param {string} format format of the time
	 * @param {Object} time Object not a Date for timezones
	 * @param {Object} [options] essentially the regional[].. amNames, pmNames, ampm
	 * @returns {string} the formatted time
	 */
	$.datepicker.formatTime = function (format, time, options) {
		options = options || {};
		options = $.extend({}, $.timepicker._defaults, options);
		time = $.extend({
			hour: 0,
			minute: 0,
			second: 0,
			millisec: 0,
			microsec: 0,
			timezone: null
		}, time);

		var tmptime = format,
			ampmName = options.amNames[0],
			hour = parseInt(time.hour, 10);

		if (hour > 11) {
			ampmName = options.pmNames[0];
		}

		tmptime = tmptime.replace(/(?:HH?|hh?|mm?|ss?|[tT]{1,2}|[zZ]|[lc]|'.*?')/g, function (match) {
			switch (match) {
			case 'HH':
				return ('0' + hour).slice(-2);
			case 'H':
				return hour;
			case 'hh':
				return ('0' + convert24to12(hour)).slice(-2);
			case 'h':
				return convert24to12(hour);
			case 'mm':
				return ('0' + time.minute).slice(-2);
			case 'm':
				return time.minute;
			case 'ss':
				return ('0' + time.second).slice(-2);
			case 's':
				return time.second;
			case 'l':
				return ('00' + time.millisec).slice(-3);
			case 'c':
				return ('00' + time.microsec).slice(-3);
			case 'z':
				return $.timepicker.timezoneOffsetString(time.timezone === null ? options.timezone : time.timezone, false);
			case 'Z':
				return $.timepicker.timezoneOffsetString(time.timezone === null ? options.timezone : time.timezone, true);
			case 'T':
				return ampmName.charAt(0).toUpperCase();
			case 'TT':
				return ampmName.toUpperCase();
			case 't':
				return ampmName.charAt(0).toLowerCase();
			case 'tt':
				return ampmName.toLowerCase();
			default:
				return match.replace(/'/g, "");
			}
		});

		return tmptime;
	};

	/*
	* the bad hack :/ override datepicker so it doesn't close on select
	// inspired: http://stackoverflow.com/questions/1252512/jquery-datepicker-prevent-closing-picker-when-clicking-a-date/1762378#1762378
	*/
	$.datepicker._base_selectDate = $.datepicker._selectDate;
	$.datepicker._selectDate = function (id, dateStr) {
		var inst = this._getInst($(id)[0]),
			tp_inst = this._get(inst, 'timepicker');

		if (tp_inst) {
			tp_inst._limitMinMaxDateTime(inst, true);
			inst.inline = inst.stay_open = true;
			//This way the onSelect handler called from calendarpicker get the full dateTime
			this._base_selectDate(id, dateStr);
			inst.inline = inst.stay_open = false;
			this._notifyChange(inst);
			this._updateDatepicker(inst);
		} else {
			this._base_selectDate(id, dateStr);
		}
	};

	/*
	* second bad hack :/ override datepicker so it triggers an event when changing the input field
	* and does not redraw the datepicker on every selectDate event
	*/
	$.datepicker._base_updateDatepicker = $.datepicker._updateDatepicker;
	$.datepicker._updateDatepicker = function (inst) {

		// don't popup the datepicker if there is another instance already opened
		var input = inst.input[0];
		if ($.datepicker._curInst && $.datepicker._curInst !== inst && $.datepicker._datepickerShowing && $.datepicker._lastInput !== input) {
			return;
		}

		if (typeof(inst.stay_open) !== 'boolean' || inst.stay_open === false) {

			this._base_updateDatepicker(inst);

			// Reload the time control when changing something in the input text field.
			var tp_inst = this._get(inst, 'timepicker');
			if (tp_inst) {
				tp_inst._addTimePicker(inst);
			}
		}
	};

	/*
	* third bad hack :/ override datepicker so it allows spaces and colon in the input field
	*/
	$.datepicker._base_doKeyPress = $.datepicker._doKeyPress;
	$.datepicker._doKeyPress = function (event) {
		var inst = $.datepicker._getInst(event.target),
			tp_inst = $.datepicker._get(inst, 'timepicker');

		if (tp_inst) {
			if ($.datepicker._get(inst, 'constrainInput')) {
				var ampm = tp_inst.support.ampm,
					tz = tp_inst._defaults.showTimezone !== null ? tp_inst._defaults.showTimezone : tp_inst.support.timezone,
					dateChars = $.datepicker._possibleChars($.datepicker._get(inst, 'dateFormat')),
					datetimeChars = tp_inst._defaults.timeFormat.toString()
											.replace(/[hms]/g, '')
											.replace(/TT/g, ampm ? 'APM' : '')
											.replace(/Tt/g, ampm ? 'AaPpMm' : '')
											.replace(/tT/g, ampm ? 'AaPpMm' : '')
											.replace(/T/g, ampm ? 'AP' : '')
											.replace(/tt/g, ampm ? 'apm' : '')
											.replace(/t/g, ampm ? 'ap' : '') + 
											" " + tp_inst._defaults.separator + 
											tp_inst._defaults.timeSuffix + 
											(tz ? tp_inst._defaults.timezoneList.join('') : '') + 
											(tp_inst._defaults.amNames.join('')) + (tp_inst._defaults.pmNames.join('')) + 
											dateChars,
					chr = String.fromCharCode(event.charCode === undefined ? event.keyCode : event.charCode);
				return event.ctrlKey || (chr < ' ' || !dateChars || datetimeChars.indexOf(chr) > -1);
			}
		}

		return $.datepicker._base_doKeyPress(event);
	};

	/*
	* Fourth bad hack :/ override _updateAlternate function used in inline mode to init altField
	* Update any alternate field to synchronise with the main field.
	*/
	$.datepicker._base_updateAlternate = $.datepicker._updateAlternate;
	$.datepicker._updateAlternate = function (inst) {
		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			var altField = tp_inst._defaults.altField;
			if (altField) { // update alternate field too
				var altFormat = tp_inst._defaults.altFormat || tp_inst._defaults.dateFormat,
					date = this._getDate(inst),
					formatCfg = $.datepicker._getFormatConfig(inst),
					altFormattedDateTime = '', 
					altSeparator = tp_inst._defaults.altSeparator ? tp_inst._defaults.altSeparator : tp_inst._defaults.separator, 
					altTimeSuffix = tp_inst._defaults.altTimeSuffix ? tp_inst._defaults.altTimeSuffix : tp_inst._defaults.timeSuffix,
					altTimeFormat = tp_inst._defaults.altTimeFormat !== null ? tp_inst._defaults.altTimeFormat : tp_inst._defaults.timeFormat;
				
				altFormattedDateTime += $.datepicker.formatTime(altTimeFormat, tp_inst, tp_inst._defaults) + altTimeSuffix;
				if (!tp_inst._defaults.timeOnly && !tp_inst._defaults.altFieldTimeOnly && date !== null) {
					if (tp_inst._defaults.altFormat) {
						altFormattedDateTime = $.datepicker.formatDate(tp_inst._defaults.altFormat, date, formatCfg) + altSeparator + altFormattedDateTime;
					}
					else {
						altFormattedDateTime = tp_inst.formattedDate + altSeparator + altFormattedDateTime;
					}
				}
				$(altField).val(altFormattedDateTime);
			}
		}
		else {
			$.datepicker._base_updateAlternate(inst);
		}
	};

	/*
	* Override key up event to sync manual input changes.
	*/
	$.datepicker._base_doKeyUp = $.datepicker._doKeyUp;
	$.datepicker._doKeyUp = function (event) {
		var inst = $.datepicker._getInst(event.target),
			tp_inst = $.datepicker._get(inst, 'timepicker');

		if (tp_inst) {
			if (tp_inst._defaults.timeOnly && (inst.input.val() !== inst.lastVal)) {
				try {
					$.datepicker._updateDatepicker(inst);
				} catch (err) {
					$.timepicker.log(err);
				}
			}
		}

		return $.datepicker._base_doKeyUp(event);
	};

	/*
	* override "Today" button to also grab the time.
	*/
	$.datepicker._base_gotoToday = $.datepicker._gotoToday;
	$.datepicker._gotoToday = function (id) {
		var inst = this._getInst($(id)[0]),
			$dp = inst.dpDiv;
		this._base_gotoToday(id);
		var tp_inst = this._get(inst, 'timepicker');
		selectLocalTimezone(tp_inst);
		var now = new Date();
		this._setTime(inst, now);
		$('.ui-datepicker-today', $dp).click();
	};

	/*
	* Disable & enable the Time in the datetimepicker
	*/
	$.datepicker._disableTimepickerDatepicker = function (target) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');
		$(target).datepicker('getDate'); // Init selected[Year|Month|Day]
		if (tp_inst) {
			inst.settings.showTimepicker = false;
			tp_inst._defaults.showTimepicker = false;
			tp_inst._updateDateTime(inst);
		}
	};

	$.datepicker._enableTimepickerDatepicker = function (target) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');
		$(target).datepicker('getDate'); // Init selected[Year|Month|Day]
		if (tp_inst) {
			inst.settings.showTimepicker = true;
			tp_inst._defaults.showTimepicker = true;
			tp_inst._addTimePicker(inst); // Could be disabled on page load
			tp_inst._updateDateTime(inst);
		}
	};

	/*
	* Create our own set time function
	*/
	$.datepicker._setTime = function (inst, date) {
		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			var defaults = tp_inst._defaults;

			// calling _setTime with no date sets time to defaults
			tp_inst.hour = date ? date.getHours() : defaults.hour;
			tp_inst.minute = date ? date.getMinutes() : defaults.minute;
			tp_inst.second = date ? date.getSeconds() : defaults.second;
			tp_inst.millisec = date ? date.getMilliseconds() : defaults.millisec;
			tp_inst.microsec = date ? date.getMicroseconds() : defaults.microsec;

			//check if within min/max times.. 
			tp_inst._limitMinMaxDateTime(inst, true);

			tp_inst._onTimeChange();
			tp_inst._updateDateTime(inst);
		}
	};

	/*
	* Create new public method to set only time, callable as $().datepicker('setTime', date)
	*/
	$.datepicker._setTimeDatepicker = function (target, date, withDate) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');

		if (tp_inst) {
			this._setDateFromField(inst);
			var tp_date;
			if (date) {
				if (typeof date === "string") {
					tp_inst._parseTime(date, withDate);
					tp_date = new Date();
					tp_date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec);
					tp_date.setMicroseconds(tp_inst.microsec);
				} else {
					tp_date = new Date(date.getTime());
					tp_date.setMicroseconds(date.getMicroseconds());
				}
				if (tp_date.toString() === 'Invalid Date') {
					tp_date = undefined;
				}
				this._setTime(inst, tp_date);
			}
		}

	};

	/*
	* override setDate() to allow setting time too within Date object
	*/
	$.datepicker._base_setDateDatepicker = $.datepicker._setDateDatepicker;
	$.datepicker._setDateDatepicker = function (target, date) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		if (typeof(date) === 'string') {
			date = new Date(date);
			if (!date.getTime()) {
				$.timepicker.log("Error creating Date object from string.");
			}
		}

		var tp_inst = this._get(inst, 'timepicker');
		var tp_date;
		if (date instanceof Date) {
			tp_date = new Date(date.getTime());
			tp_date.setMicroseconds(date.getMicroseconds());
		} else {
			tp_date = date;
		}
		
		// This is important if you are using the timezone option, javascript's Date 
		// object will only return the timezone offset for the current locale, so we 
		// adjust it accordingly.  If not using timezone option this won't matter..
		// If a timezone is different in tp, keep the timezone as is
		if (tp_inst) {
			// look out for DST if tz wasn't specified
			if (!tp_inst.support.timezone && tp_inst._defaults.timezone === null) {
				tp_inst.timezone = tp_date.getTimezoneOffset() * -1;
			}
			date = $.timepicker.timezoneAdjust(date, tp_inst.timezone);
			tp_date = $.timepicker.timezoneAdjust(tp_date, tp_inst.timezone);
		}

		this._updateDatepicker(inst);
		this._base_setDateDatepicker.apply(this, arguments);
		this._setTimeDatepicker(target, tp_date, true);
	};

	/*
	* override getDate() to allow getting time too within Date object
	*/
	$.datepicker._base_getDateDatepicker = $.datepicker._getDateDatepicker;
	$.datepicker._getDateDatepicker = function (target, noDefault) {
		var inst = this._getInst(target);
		if (!inst) {
			return;
		}

		var tp_inst = this._get(inst, 'timepicker');

		if (tp_inst) {
			// if it hasn't yet been defined, grab from field
			if (inst.lastVal === undefined) {
				this._setDateFromField(inst, noDefault);
			}

			var date = this._getDate(inst);
			if (date && tp_inst._parseTime($(target).val(), tp_inst.timeOnly)) {
				date.setHours(tp_inst.hour, tp_inst.minute, tp_inst.second, tp_inst.millisec);
				date.setMicroseconds(tp_inst.microsec);

				// This is important if you are using the timezone option, javascript's Date 
				// object will only return the timezone offset for the current locale, so we 
				// adjust it accordingly.  If not using timezone option this won't matter..
				if (tp_inst.timezone != null) {
					// look out for DST if tz wasn't specified
					if (!tp_inst.support.timezone && tp_inst._defaults.timezone === null) {
						tp_inst.timezone = date.getTimezoneOffset() * -1;
					}
					date = $.timepicker.timezoneAdjust(date, tp_inst.timezone);
				}
			}
			return date;
		}
		return this._base_getDateDatepicker(target, noDefault);
	};

	/*
	* override parseDate() because UI 1.8.14 throws an error about "Extra characters"
	* An option in datapicker to ignore extra format characters would be nicer.
	*/
	$.datepicker._base_parseDate = $.datepicker.parseDate;
	$.datepicker.parseDate = function (format, value, settings) {
		var date;
		try {
			date = this._base_parseDate(format, value, settings);
		} catch (err) {
			// Hack!  The error message ends with a colon, a space, and
			// the "extra" characters.  We rely on that instead of
			// attempting to perfectly reproduce the parsing algorithm.
			if (err.indexOf(":") >= 0) {
				date = this._base_parseDate(format, value.substring(0, value.length - (err.length - err.indexOf(':') - 2)), settings);
				$.timepicker.log("Error parsing the date string: " + err + "\ndate string = " + value + "\ndate format = " + format);
			} else {
				throw err;
			}
		}
		return date;
	};

	/*
	* override formatDate to set date with time to the input
	*/
	$.datepicker._base_formatDate = $.datepicker._formatDate;
	$.datepicker._formatDate = function (inst, day, month, year) {
		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			tp_inst._updateDateTime(inst);
			return tp_inst.$input.val();
		}
		return this._base_formatDate(inst);
	};

	/*
	* override options setter to add time to maxDate(Time) and minDate(Time). MaxDate
	*/
	$.datepicker._base_optionDatepicker = $.datepicker._optionDatepicker;
	$.datepicker._optionDatepicker = function (target, name, value) {
		var inst = this._getInst(target),
			name_clone;
		if (!inst) {
			return null;
		}

		var tp_inst = this._get(inst, 'timepicker');
		if (tp_inst) {
			var min = null,
				max = null,
				onselect = null,
				overrides = tp_inst._defaults.evnts,
				fns = {},
				prop;
			if (typeof name === 'string') { // if min/max was set with the string
				if (name === 'minDate' || name === 'minDateTime') {
					min = value;
				} else if (name === 'maxDate' || name === 'maxDateTime') {
					max = value;
				} else if (name === 'onSelect') {
					onselect = value;
				} else if (overrides.hasOwnProperty(name)) {
					if (typeof (value) === 'undefined') {
						return overrides[name];
					}
					fns[name] = value;
					name_clone = {}; //empty results in exiting function after overrides updated
				}
			} else if (typeof name === 'object') { //if min/max was set with the JSON
				if (name.minDate) {
					min = name.minDate;
				} else if (name.minDateTime) {
					min = name.minDateTime;
				} else if (name.maxDate) {
					max = name.maxDate;
				} else if (name.maxDateTime) {
					max = name.maxDateTime;
				}
				for (prop in overrides) {
					if (overrides.hasOwnProperty(prop) && name[prop]) {
						fns[prop] = name[prop];
					}
				}
			}
			for (prop in fns) {
				if (fns.hasOwnProperty(prop)) {
					overrides[prop] = fns[prop];
					if (!name_clone) { name_clone = $.extend({}, name); }
					delete name_clone[prop];
				}
			}
			if (name_clone && isEmptyObject(name_clone)) { return; }
			if (min) { //if min was set
				if (min === 0) {
					min = new Date();
				} else {
					min = new Date(min);
				}
				tp_inst._defaults.minDate = min;
				tp_inst._defaults.minDateTime = min;
			} else if (max) { //if max was set
				if (max === 0) {
					max = new Date();
				} else {
					max = new Date(max);
				}
				tp_inst._defaults.maxDate = max;
				tp_inst._defaults.maxDateTime = max;
			} else if (onselect) {
				tp_inst._defaults.onSelect = onselect;
			}
		}
		if (value === undefined) {
			return this._base_optionDatepicker.call($.datepicker, target, name);
		}
		return this._base_optionDatepicker.call($.datepicker, target, name_clone || name, value);
	};
	
	/*
	* jQuery isEmptyObject does not check hasOwnProperty - if someone has added to the object prototype,
	* it will return false for all objects
	*/
	var isEmptyObject = function (obj) {
		var prop;
		for (prop in obj) {
			if (obj.hasOwnProperty(prop)) {
				return false;
			}
		}
		return true;
	};

	/*
	* jQuery extend now ignores nulls!
	*/
	var extendRemove = function (target, props) {
		$.extend(target, props);
		for (var name in props) {
			if (props[name] === null || props[name] === undefined) {
				target[name] = props[name];
			}
		}
		return target;
	};

	/*
	* Determine by the time format which units are supported
	* Returns an object of booleans for each unit
	*/
	var detectSupport = function (timeFormat) {
		var tf = timeFormat.replace(/'.*?'/g, '').toLowerCase(), // removes literals
			isIn = function (f, t) { // does the format contain the token?
					return f.indexOf(t) !== -1 ? true : false;
				};
		return {
				hour: isIn(tf, 'h'),
				minute: isIn(tf, 'm'),
				second: isIn(tf, 's'),
				millisec: isIn(tf, 'l'),
				microsec: isIn(tf, 'c'),
				timezone: isIn(tf, 'z'),
				ampm: isIn(tf, 't') && isIn(timeFormat, 'h'),
				iso8601: isIn(timeFormat, 'Z')
			};
	};

	/*
	* Converts 24 hour format into 12 hour
	* Returns 12 hour without leading 0
	*/
	var convert24to12 = function (hour) {
		hour %= 12;

		if (hour === 0) {
			hour = 12;
		}

		return String(hour);
	};

	var computeEffectiveSetting = function (settings, property) {
		return settings && settings[property] ? settings[property] : $.timepicker._defaults[property];
	};

	/*
	* Splits datetime string into date and time substrings.
	* Throws exception when date can't be parsed
	* Returns {dateString: dateString, timeString: timeString}
	*/
	var splitDateTime = function (dateTimeString, timeSettings) {
		// The idea is to get the number separator occurrences in datetime and the time format requested (since time has
		// fewer unknowns, mostly numbers and am/pm). We will use the time pattern to split.
		var separator = computeEffectiveSetting(timeSettings, 'separator'),
			format = computeEffectiveSetting(timeSettings, 'timeFormat'),
			timeParts = format.split(separator), // how many occurrences of separator may be in our format?
			timePartsLen = timeParts.length,
			allParts = dateTimeString.split(separator),
			allPartsLen = allParts.length;

		if (allPartsLen > 1) {
			return {
				dateString: allParts.splice(0, allPartsLen - timePartsLen).join(separator),
				timeString: allParts.splice(0, timePartsLen).join(separator)
			};
		}

		return {
			dateString: dateTimeString,
			timeString: ''
		};
	};

	/*
	* Internal function to parse datetime interval
	* Returns: {date: Date, timeObj: Object}, where
	*   date - parsed date without time (type Date)
	*   timeObj = {hour: , minute: , second: , millisec: , microsec: } - parsed time. Optional
	*/
	var parseDateTimeInternal = function (dateFormat, timeFormat, dateTimeString, dateSettings, timeSettings) {
		var date,
			parts,
			parsedTime;

		parts = splitDateTime(dateTimeString, timeSettings);
		date = $.datepicker._base_parseDate(dateFormat, parts.dateString, dateSettings);

		if (parts.timeString === '') {
			return {
				date: date
			};
		}

		parsedTime = $.datepicker.parseTime(timeFormat, parts.timeString, timeSettings);

		if (!parsedTime) {
			throw 'Wrong time format';
		}

		return {
			date: date,
			timeObj: parsedTime
		};
	};

	/*
	* Internal function to set timezone_select to the local timezone
	*/
	var selectLocalTimezone = function (tp_inst, date) {
		if (tp_inst && tp_inst.timezone_select) {
			var now = date || new Date();
			tp_inst.timezone_select.val(-now.getTimezoneOffset());
		}
	};

	/*
	* Create a Singleton Instance
	*/
	$.timepicker = new Timepicker();

	/**
	 * Get the timezone offset as string from a date object (eg '+0530' for UTC+5.5)
	 * @param {number} tzMinutes if not a number, less than -720 (-1200), or greater than 840 (+1400) this value is returned
	 * @param {boolean} iso8601 if true formats in accordance to iso8601 "+12:45"
	 * @return {string}
	 */
	$.timepicker.timezoneOffsetString = function (tzMinutes, iso8601) {
		if (isNaN(tzMinutes) || tzMinutes > 840 || tzMinutes < -720) {
			return tzMinutes;
		}

		var off = tzMinutes,
			minutes = off % 60,
			hours = (off - minutes) / 60,
			iso = iso8601 ? ':' : '',
			tz = (off >= 0 ? '+' : '-') + ('0' + Math.abs(hours)).slice(-2) + iso + ('0' + Math.abs(minutes)).slice(-2);
		
		if (tz === '+00:00') {
			return 'Z';
		}
		return tz;
	};

	/**
	 * Get the number in minutes that represents a timezone string
	 * @param  {string} tzString formatted like "+0500", "-1245", "Z"
	 * @return {number} the offset minutes or the original string if it doesn't match expectations
	 */
	$.timepicker.timezoneOffsetNumber = function (tzString) {
		var normalized = tzString.toString().replace(':', ''); // excuse any iso8601, end up with "+1245"

		if (normalized.toUpperCase() === 'Z') { // if iso8601 with Z, its 0 minute offset
			return 0;
		}

		if (!/^(\-|\+)\d{4}$/.test(normalized)) { // possibly a user defined tz, so just give it back
			return tzString;
		}

		return ((normalized.substr(0, 1) === '-' ? -1 : 1) * // plus or minus
					((parseInt(normalized.substr(1, 2), 10) * 60) + // hours (converted to minutes)
					parseInt(normalized.substr(3, 2), 10))); // minutes
	};

	/**
	 * No way to set timezone in js Date, so we must adjust the minutes to compensate. (think setDate, getDate)
	 * @param  {Date} date
	 * @param  {string} toTimezone formatted like "+0500", "-1245"
	 * @return {Date}
	 */
	$.timepicker.timezoneAdjust = function (date, toTimezone) {
		var toTz = $.timepicker.timezoneOffsetNumber(toTimezone);
		if (!isNaN(toTz)) {
			date.setMinutes(date.getMinutes() + -date.getTimezoneOffset() - toTz);
		}
		return date;
	};

	/**
	 * Calls `timepicker()` on the `startTime` and `endTime` elements, and configures them to
	 * enforce date range limits.
	 * n.b. The input value must be correctly formatted (reformatting is not supported)
	 * @param  {Element} startTime
	 * @param  {Element} endTime
	 * @param  {Object} options Options for the timepicker() call
	 * @return {jQuery}
	 */
	$.timepicker.timeRange = function (startTime, endTime, options) {
		return $.timepicker.handleRange('timepicker', startTime, endTime, options);
	};

	/**
	 * Calls `datetimepicker` on the `startTime` and `endTime` elements, and configures them to
	 * enforce date range limits.
	 * @param  {Element} startTime
	 * @param  {Element} endTime
	 * @param  {Object} options Options for the `timepicker()` call. Also supports `reformat`,
	 *   a boolean value that can be used to reformat the input values to the `dateFormat`.
	 * @param  {string} method Can be used to specify the type of picker to be added
	 * @return {jQuery}
	 */
	$.timepicker.datetimeRange = function (startTime, endTime, options) {
		$.timepicker.handleRange('datetimepicker', startTime, endTime, options);
	};

	/**
	 * Calls `datepicker` on the `startTime` and `endTime` elements, and configures them to
	 * enforce date range limits.
	 * @param  {Element} startTime
	 * @param  {Element} endTime
	 * @param  {Object} options Options for the `timepicker()` call. Also supports `reformat`,
	 *   a boolean value that can be used to reformat the input values to the `dateFormat`.
	 * @return {jQuery}
	 */
	$.timepicker.dateRange = function (startTime, endTime, options) {
		$.timepicker.handleRange('datepicker', startTime, endTime, options);
	};

	/**
	 * Calls `method` on the `startTime` and `endTime` elements, and configures them to
	 * enforce date range limits.
	 * @param  {string} method Can be used to specify the type of picker to be added
	 * @param  {Element} startTime
	 * @param  {Element} endTime
	 * @param  {Object} options Options for the `timepicker()` call. Also supports `reformat`,
	 *   a boolean value that can be used to reformat the input values to the `dateFormat`.
	 * @return {jQuery}
	 */
	$.timepicker.handleRange = function (method, startTime, endTime, options) {
		options = $.extend({}, {
			minInterval: 0, // min allowed interval in milliseconds
			maxInterval: 0, // max allowed interval in milliseconds
			start: {},      // options for start picker
			end: {}         // options for end picker
		}, options);

		function checkDates(changed, other) {
			var startdt = startTime[method]('getDate'),
				enddt = endTime[method]('getDate'),
				changeddt = changed[method]('getDate');

			if (startdt !== null) {
				var minDate = new Date(startdt.getTime()),
					maxDate = new Date(startdt.getTime());

				minDate.setMilliseconds(minDate.getMilliseconds() + options.minInterval);
				maxDate.setMilliseconds(maxDate.getMilliseconds() + options.maxInterval);

				if (options.minInterval > 0 && minDate > enddt) { // minInterval check
					endTime[method]('setDate', minDate);
				}
				else if (options.maxInterval > 0 && maxDate < enddt) { // max interval check
					endTime[method]('setDate', maxDate);
				}
				else if (startdt > enddt) {
					other[method]('setDate', changeddt);
				}
			}
		}

		function selected(changed, other, option) {
			if (!changed.val()) {
				return;
			}
			var date = changed[method].call(changed, 'getDate');
			if (date !== null && options.minInterval > 0) {
				if (option === 'minDate') {
					date.setMilliseconds(date.getMilliseconds() + options.minInterval);
				}
				if (option === 'maxDate') {
					date.setMilliseconds(date.getMilliseconds() - options.minInterval);
				}
			}
			if (date.getTime) {
				other[method].call(other, 'option', option, date);
			}
		}

		$.fn[method].call(startTime, $.extend({
			onClose: function (dateText, inst) {
				checkDates($(this), endTime);
			},
			onSelect: function (selectedDateTime) {
				selected($(this), endTime, 'minDate');
			}
		}, options, options.start));
		$.fn[method].call(endTime, $.extend({
			onClose: function (dateText, inst) {
				checkDates($(this), startTime);
			},
			onSelect: function (selectedDateTime) {
				selected($(this), startTime, 'maxDate');
			}
		}, options, options.end));

		checkDates(startTime, endTime);
		selected(startTime, endTime, 'minDate');
		selected(endTime, startTime, 'maxDate');
		return $([startTime.get(0), endTime.get(0)]);
	};

	/**
	 * Log error or data to the console during error or debugging
	 * @param  {Object} err pass any type object to log to the console during error or debugging
	 * @return {void}
	 */
	$.timepicker.log = function (err) {
		if (window.console) {
			window.console.log(err);
		}
	};

	/*
	 * Add util object to allow access to private methods for testability.
	 */
	$.timepicker._util = {
		_extendRemove: extendRemove,
		_isEmptyObject: isEmptyObject,
		_convert24to12: convert24to12,
		_detectSupport: detectSupport,
		_selectLocalTimezone: selectLocalTimezone,
		_computeEffectiveSetting: computeEffectiveSetting,
		_splitDateTime: splitDateTime,
		_parseDateTimeInternal: parseDateTimeInternal
	};

	/*
	* Microsecond support
	*/
	if (!Date.prototype.getMicroseconds) {
		Date.prototype.microseconds = 0;
		Date.prototype.getMicroseconds = function () { return this.microseconds; };
		Date.prototype.setMicroseconds = function (m) {
			this.setMilliseconds(this.getMilliseconds() + Math.floor(m / 1000));
			this.microseconds = m % 1000;
			return this;
		};
	}

	/*
	* Keep up with the version
	*/
	$.timepicker.version = "1.4";

})(jQuery);
/****** end css file: timepicker.js ******/

/****** js file: events.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/plugins/events/events.js ******/
/****** last modified: 1477335686 (2016-10-24 14:01:26) ******/
$(document).ready(function(){
	$qsearch = $( $(".te_qsearch").html() );
	$("#te_qkeywords", $qsearch).css({"width":"75px"});
	if ( $("#te_qkeywords", $qsearch).val() != "" ) {
		$("#te_qkeywords", $qsearch).removeClass("search_input");
	}
	$("#tag_select").before($qsearch);

	$('#events_qsearch_form').remove();
	// Moved to table_search_area.php

	if($("#thumbnail_calendar")) {
		$("#thumbnail_calendar").datepicker({
			showOtherMonths: true,
			selectOtherMonths: true
		});
	}
	$(".drop_arrow_indicator").css("cursor", "pointer").attr("title", "Click to View");
	$(document).on("click",".drop_arrow_indicator", function()
	{
		var event_id = $(this).attr("id");
		var event_html = $(this).html();
		if(event_html == "&#9658;" || event_html == "") {
			$(this).html('&#x25BC;');
			show_description(event_id);
		} else {
			$(this).html('&#9658;');
			hide_description(event_id);
		}
	});
	$(".drop_arrow_indicator_with_div").css("cursor", "pointer").attr("title", "Click to View");
	$(document).on("click",".drop_arrow_indicator_with_div DIV", function()
	{
		var event_id = $(this).attr("id");
		var event_html = $(this).html();
		if(event_html == "&#9658;" || event_html == "") {
			$(this).html('&#x25BC;');
			show_description(event_id);
		} else {
			$(this).html('&#9658;');
			hide_description(event_id);
		}
	});

	$(document).on("click",".read_more_link", function()
	{
		var event_id = $(this).attr("id");
		var event_html = $(".drop_arrow_indicator_with_div DIV#" + event_id).html();
		if(event_html == "&#9658;" || event_html == "") {
			$(".drop_arrow_indicator_with_div DIV#" + event_id).html('&#x25BC;');
			show_description(event_id);
		} else {
			$(".drop_arrow_indicator_with_div DIV#" + event_id).html('&#9658;');
			hide_description(event_id);
		}
	});

	$(".event_color_selector:first").css({"color":"#ff0000"});
	$(document).on("click",".event_color_selector", function() {
		$(".event_color_selector").html("");
		var color = $(this).attr("data-color");
		$(this).html("X");
		$("#event_color").val(color);
	});

	$(".hidden_hour").slideUp("fast");
	$(".hidden_event").css({"visibility":"hidden"});
	$(document).on("click",".show_more_events_btn",function() {
		var adjustment = $(this).data("adjustment");
    var hhours = $(this).data("hhours");

		// Event Hours
		$( ".event_day_draw_day_hour_event" ).each(function() {
			var p = $(this);

			var position = p.position();

      hhours = $(this).data("hhours");

      if (hhours>0){
        $(this).css("top",position.top+adjustment - (50 * hhours));
        var new_height = $(this).css("height");
        new_height = new_height.replace("px", "");
        new_height = parseInt(new_height)  + (50 * hhours);
        new_height = new_height  + "px";
        $(this).css("height",new_height);
        //$(this).css("height","400px");
      }else{
			   $(this).css("top",position.top+adjustment );
      }

		});

		// Event Popup Details
		$( ".event_popup_details, .event_add_details" ).each(function() {
			var position = $(this).css("top").replace(/[^-\d\.]/g, '');
			// Avoid all day events
			if(position > 30) {
				$(this).css("top",parseInt(position) + parseInt(adjustment));
			}
		});

		$(".hidden_hour").slideDown("fast");
		$(".hidden_event").css({"visibility":"visible"});
		$(".show_more_events_btn").slideUp("fast");
	});

	// Logic to handle client filtering
	$(document).on("click",".event_calendar_client", function() {
		$(this).toggleClass("event_calendar_client_active");

		var string = "0";
		$(".event_calendar_client").each(function() {
			if(!$(this).hasClass("event_calendar_client_active")) {
				string += "," + $(this).data("client");
			}
		});

		// Store the newly created client list in the events_users_settings table for users
		$.ajax({
			type: "POST",
			url: 'events_users_settings?ai_skin=full_page&te_mode=ajax&ajax_cmd=save_client_view',
			data: { clients: string }
		}).done(function(response) {

		});
	});
	$(document).on("click","#event_calendar_client_update", function() {
		// if there is a mini-calendar, do long differently
		if (typeof load_mini_calendar == 'function') {
			load_mini_calendar($("#day_offsets").val(),$("#viewing_calendar").val());
		} else {
			document.location = 'events?mode=' + $("#mode").val() + '&selected_date=' + $("#selected_date").val() + '&clients=' + $("#event_calendar_client_list").val();
		}
	});

	//when beg time changes, add 1 hour to the end time.
	$(document).on("change","#beg_time", function() {

		console.log("btime loaded");
		//if multi day is checked do nothing
		if(document.getElementById('multi_day_checkbox').checked) {
			console.log("btime multi-day checked");
		} else {

			console.log("btime multi-day not checked");

			//gets the beg date and beg time and passes it to strtotime js function
			//which then converts it to a unix timestamp
			var btime = php_strtotime($("#beg_date").val() +" "+ $("#beg_time").val());
			var new_time = php_strtotime('+1 hour',btime); //adds 1 hour to the time
			console.log("time= "+ new_time);

			//converts unix timestamp into formatted am/pm time
			var new_end_time = php_date('h:i a', new_time);
			var new_end_date = php_date('m/d/Y', new_time);
			console.log("end time= "+ new_end_time +" -- "+ new_end_date);

			$("#end_time").val(new_end_time);
			$("#end_date").val(new_end_date); //set end_date to new_time date

		}
	});
});

$(document).on("click", '#events_submit', function(){
	$('#events_form').submit();
});
$(document).on("click",'.event_popup_details A', function(){
	$(".event_popup_details").hide('fast');
});

function save_and_stay()
{
	$('#save_and_stay').val('save_and_stay');
}

// Event Add Popup Options - Start
$(document).on("click",'.event_add_details BUTTON', function(){
	var event_title = $(".event_add_details #event_title").val();
	var event_description = $(".event_add_details #event_description").val();
	var beg_date = $(".event_add_details #beg_date").val();
	var beg_time = $(".event_add_details #beg_time").val();
	var end_date = $(".event_add_details #end_date").val();
	var end_time = $(".event_add_details #end_time").val();
	var allday_Checked = $('.event_add_details #all_day_checkbox:checked').length;
	var multiday_Checked = $('.event_add_details #multi_day_checkbox:checked').length;
	var connected_contact = $('.event_add_details #add_details_connected_contact').val();
	var viewing_user = $('.event_add_details #viewing_user').val();
	var event_color = $('.event_add_details #event_color').val();
	var shared_event_string = $('.event_add_details #shared_event_string').val();
	var allow_shared_users_to_edit = $('.event_add_details #allow_shared_users_to_edit').val();
	var mode = $(".event_add_details #mode").val();

	if(event_title == "") {
		alert("You must add a title!");
		return false;
	}

	$(".event_add_details:visible DT").html('<br><div align="center"><img src="images/loading.gif"><br><br>');
	$(".event_add_details:visible BUTTON").hide(0);

	$.ajax({
		type: "POST",
		url: 'events?ai_skin=full_page&te_mode=ajax&ajax_cmd=save_add_details',
		data: { title: event_title, description: event_description, beg_date: beg_date, beg_time: beg_time, end_date: end_date, end_time: end_time, all_day: allday_Checked, multi_day: multiday_Checked, connected_contact: connected_contact, viewing_user: viewing_user, shared: shared_event_string, allow_shared: allow_shared_users_to_edit, color: event_color }
	}).done(function(response) {
		var response = $.parseJSON((response));
		$(".event_add_details:visible DT").html(response.responseText);

		// ERROR ALERT
		if(response.status == false) {
			alert( response.responseText.replace(/<\/?[^>]+(>|$)/g, ""));
			return false;
		}

		var date = new Date();
		var selected_date = new Date(beg_date);

		var day = selected_date.getDate();
		var month = selected_date.getMonth() + 1;
		var year = selected_date.getFullYear();
		if(day < 10) { day = "0" + day; }
		if(month < 10) { month = "0" + month; }

		setTimeout(reload_calendar(mode, year + "-" + month + "-" + day), 3000);
	});

});
$(document).on("click",'.event_add_details A.close_link', function(){
	if(confirm("Are you sure you wish to cancel?")) {
		if(typeof reset_event_add == 'function') {
			reset_event_add();
		} else {
			$(".event_add_details").hide('fast');
		}
	}
});

function reload_calendar(mode,selected_date)
{
	if(mode === undefined) { mode = "month"; }

	if($("#day_offsets").length > 0) {
		if($("#viewing_calendar").length > 0) {
			load_mini_calendar($("#day_offsets").val(),$("#viewing_calendar").val());
		} else {
			load_mini_calendar($("#day_offsets").val());
		}
	} else {
		if(selected_date === undefined) {
			var date = new Date();
			var selected_date = new Date(date.getFullYear(), date.getMonth(), date.getDate());

			var day = selected_date.getDate();
			var month = selected_date.getMonth() + 1;
			var year = selected_date.getFullYear();
			if(day < 10) { day = "0" + day; }
			if(month < 10) { month = "0" + month; }
			display_calendar(mode,year + "-" + month + "-" + day,false);
		} else {
			display_calendar(mode,selected_date,false);
		}
	}
}

function toggle_add_popup(date)
{
	$(".event_add_details").not($("#add_popup_" + date)).hide('fast');
	$("#add_popup_" + date).toggle('fast');

	var connected_contact = $("#add_popup_" + date + " #add_details_connected_contact").val();
	var viewing_calendar = $("#viewing_calendar").val();

	$("#add_popup_" + date + " DT").load('events?ai_skin=full_page&te_mode=ajax&ajax_cmd=display_add_details&date=' + encodeURIComponent(date) + '&viewing_calendar=' + encodeURIComponent(viewing_calendar) + '&connected_contact=' + encodeURIComponent(connected_contact), function() {
		$(".beg_date_" + date + ", .end_date_" + date).datepicker({
			yearRange: "-2:+0",
			showMonthAfterYear:true,
			hideIfNoPrevNext: false,
			showOn: "both",
			buttonImage: "images/calendar.gif",
			changeMonth: true,
			changeYear: true,
			yearRange: "-100:+100",
			constrainInput: false,
			buttonImageOnly: true
		});
		toggle_add_allday_toggle();
		toggle_add_multiday_toggle();
		run_helper_functions();

		// task 26406.  felipe 2015-05-25.  removed the if statement because code that runs for lead_management also work for events.  the code in the else was throwing errors
		// // This is the tag form which is only on lead_management table mode
		// if($("#lead_management_table_form").length == 0) {

		// This is the tag form which is only on lead_management edit mode.  For some reason the jQuery autocomplete that works in events and lead_management table does not work in lead_management edit mode
		if($("#lead_management_form").length != 0) {
			// $("#shared_event_lookup").autocomplete("events?ai_skin=full_page&te_class=events&te_mode=ajax&ajax_cmd=autocomplete_users", {minChars:3}).result(function(e, d, f) { if ( d ) {
			$("#shared_event_lookup").autocomplete("events?ai_skin=full_page&te_class=events&te_mode=ajax&ajax_cmd=autocomplete_users").result(function(e, d, f) { if ( d ) {
				add_shared_event(d);
			} });

		} else {
			// Trigger shared event lookup functionality
			$("#shared_event_lookup").autocomplete({
				source: "events?ai_skin=full_page&te_class=events&te_mode=ajax&ajax_cmd=autocomplete_users&format=json",
				minChars:3,
				select: function( event, ui ) {
					add_shared_event(ui.item.value + " " + ui.item.label);

					window.setTimeout(function() {
						$("#shared_event_lookup").val(ui.item.label);
					}, 500);
				}
			});
		}
	});
}

var allday2 = false;
function toggle_add_allday_toggle()
{
	allday2 = $('.event_add_details #all_day_checkbox:checked').length;
	if(allday2) $('.event_add_details #beg_time, .event_add_details #end_time').hide(100);
	else $('.event_add_details #beg_time, .event_add_details #end_time').show(100);
	if(allday2 && !multiday2) { $('.event_add_details #to_txt').hide(); } else { $('.event_add_details #to_txt').show(); }
}
$(document).on("click",'.event_add_details #all_day_checkbox', function(){
	toggle_add_allday_toggle();
});

var multiday2 = false;
function toggle_add_multiday_toggle(){
	multiday2 = $('.event_add_details #multi_day_checkbox:checked').length;
	if(multiday2) {
		$('.event_add_details #end_date').attr('type', 'text').datepicker("option", "disabled", false).datepicker("option", "showOn", "both").show(0);
	} else {
		$('.event_add_details #end_date').attr('type', 'hidden').datepicker("option", "disabled", true).datepicker("option", "showOn", "focus").hide(0);
	}
	if(allday2 && !multiday2) { $('.event_add_details #to_txt').hide(); } else { $('.event_add_details #to_txt').show(); }
}
$(document).on("click",'.event_add_details #multi_day_checkbox', function(){
	toggle_add_multiday_toggle();
});
// Event Add Popup Options - Finish

function toggle_popup_details(unique_id)
{
	$(".event_popup_details").not($("#" + unique_id)).hide('fast');
	$("#" + unique_id).toggle('fast');
}
function show_description(event_id)
{
	$("#description_" + event_id).slideDown('slow');
}
function hide_description(event_id)
{
	$("#description_" + event_id).slideUp('slow');
}
function display_calendar(mode,date,print_mode) {

	if(print_mode) {

		var already_in_print_mode = getParameterByName('print_mode');
		if(already_in_print_mode) {
			window.print();
		} else {
			document.location = "events?mode=" + mode + "&selected_date=" + date + "&print_mode=true";
		}

	} else {

		// Always Fade
		$(".left_column").fadeTo('fast',0.15);
		document.location = "events?mode=" + mode + "&selected_date=" + date;
	}
}
function getParameterByName(name, url) {
	if (!url) url = window.location.href;
	name = name.replace(/[\[\]]/g, "\\$&");
	var regex = new RegExp("[?&]" + name + "(=([^&#]*)|&|#|$)", "i"),
			results = regex.exec(url);
	if (!results) return null;
	if (!results[2]) return '';
	return decodeURIComponent(results[2].replace(/\+/g, " "));
}
function events_delete_selected()
{
	var frm = document.getElementById('events_table_form');

	if( confirm('Delete Selected Items?') )
	{
		frm.action = 'events?te_class=events&te_mode=multidelete';
		frm.submit();
	}
}
function events_process_multiselect_checkbox( selectall_checkbox )
{
	var frm = document.getElementById('events_table_form');

	for( var i=0; i < frm.elements.length; i++ )
	{
		if( frm.elements[i].type == 'checkbox' && frm.elements[i].name == 'te_multiselect[]' )
		{
			frm.elements[i].checked = selectall_checkbox.checked;
		}
	}
}

function run_helper_functions()
{
	$('#event_title').focus(function(){
		if($(this).val()=='Title') { $(this).val(''); $(this).css('color','#000'); }
	});
	$('#event_title').blur(function(){
		if($(this).val()=='') { $(this).val('Title'); $(this).css('color','#AAA'); }
	});
	if($('#event_title').val()=='') { $('#event_title').val('Title'); $('#event_title').css('color','#AAA'); }

	$('#event_description').focus(function(){
		if($(this).val()=='Description') { $(this).val(''); $(this).css('color','#000'); }
	});
	$('#event_description').blur(function(){
		if($(this).val()=='') { $(this).val('Description'); $(this).css('color','#AAA'); }
	});
	if($('#event_description').val()=='') { $('#event_description').val('Description'); $('#event_description').css('color','#AAA'); }

	$('#event_location').focus(function(){
		if($(this).val()=='Location') { $(this).val(''); $(this).css('color','#000'); }
	});
	$('#event_location').blur(function(){
		if($(this).val()=='') { $(this).val('Location'); $(this).css('color','#AAA'); }
	});
	if($('#event_location').val()=='') { $('#event_location').val('Location'); $('#event_location').css('color','#AAA'); }

	$('#connected_contacts_lookup').focus(function(){
		if($(this).val()=='Search for a Contact') { $(this).val(''); $(this).css('color','#000'); }
	});
	$('#connected_contacts_lookup').blur(function(){
		if($(this).val()=='') { $(this).val('Search for a Contact'); $(this).css('color','#AAA'); }
	});
	if($('#connected_contacts_lookup').val()=='') { $('#connected_contacts_lookup').val('Search for a Contact'); $('#connected_contacts_lookup').css('color','#AAA'); }

	$('#shared_event_lookup').focus(function(){
		if($(this).val()=='Search for a Member') { $(this).val(''); $(this).css('color','#000'); }
	});
	$('#shared_event_lookup').blur(function(){
		if($(this).val()=='') { $(this).val('Search for a Member'); $(this).css('color','#AAA'); }
	});
	if($('#shared_event_lookup').val()=='') { $('#shared_event_lookup').val('Search for a Member'); $('#shared_event_lookup').css('color','#AAA'); }
}

run_helper_functions();

function repeat_hideshow(){
	var on = $('#is_repeating_checkbox:checked').length;
	if(on) $('dd.repeat_info').show(100);
	else $('dd.repeat_info').hide(100);

	if(on && $('#repeat_units').val()=='weeks') $('.repeat_on_days').show(100);
	else $('.repeat_on_days').hide(100);
}
$('#is_repeating_checkbox').click(repeat_hideshow);
$('#repeat_units').click(repeat_hideshow);
repeat_hideshow();

var allday = false;
function allday_hideshow(){
	allday = $('#all_day_checkbox:checked').length;
	if(allday) $('#beg_time,#end_time').hide(100);
	else $('#beg_time,#end_time').show(100);
	if(allday && !multiday) { $('#to_txt').hide(); } else { $('#to_txt').show(); }
}
$('#all_day_checkbox').click(allday_hideshow);
allday_hideshow();

var multiday = false;
function multiday_hideshow(){
	multiday = $('#multi_day_checkbox:checked').length;
	if(multiday) {
		$('#end_date').attr('type', 'text').datepicker("option", "disabled", false).datepicker("option", "showOn", "both").show(0);
	} else {
		$('#end_date').attr('type', 'hidden').datepicker("option", "disabled", true).datepicker("option", "showOn", "focus").hide(0);
	}
	if(allday && !multiday) { $('#to_txt').hide(); } else { $('#to_txt').show(); }
}
$('#multi_day_checkbox').click(multiday_hideshow);
multiday_hideshow();

$('#series_end_date').focus(function(){
	if($(this).val()=='Never') { $(this).val(''); }
});
$('#series_end_date').blur(function(){
	if($(this).val()=='') { $(this).val('Never'); }
});
if($('#series_end_date').val()=='') { $('#series_end_date').val('Never'); }

var days = ['Sunday','Monday','Tuesday','Wednesday','Thursday','Friday','Saturday'];
var months = ['January','February','March','April','May','June','July','August','September','October','November','December'];
function getDateOrdinal(n) {
	var s=["th","st","nd","rd"],v=n%100;
	return n+(s[(v-20)%10]||s[v]||s[0]);
}
function recalc_rep_text() {
	beg = $('#beg_date').val().split('-');
	bdate = new Date(beg[0], beg[1], beg[2]);
	d = beg[2];
	dow = days[ bdate.getDay() ];
	month = months[ bdate.getMonth()-1 ];

	rep_i = $('#repeat_period').val();

	if (typeof rep_i == 'undefined') { return; }

	rep_u = $('#repeat_units').val();
	rep_u_single = (rep_u=='days'? 'Daily':(rep_u=='weeks'? 'Weekly':(rep_u=='months'? 'Monthly':(rep_u=='years'? 'Annually':''))));
	Rep_u = rep_u.charAt(0).toUpperCase() + rep_u.substr(1);
	dows=''; $('.repeat_dows_check:checked').each(function(){ dows+= ' '+$(this).attr('dval')+','; });
	end = $('#series_end_date').val();

	txt  = 'Repeats '+(rep_i==1? rep_u_single:'Every '+rep_i+' '+Rep_u);
	if(rep_u!='days') txt += ' on ';
	if(rep_u=='weeks') txt += (dows==''? '[SELECT DAY]':dows.substr(0,dows.length-1));
	if(rep_u=='months') txt += ' the '+getDateOrdinal(d);
	if(rep_u=='years') txt += month+' '+getDateOrdinal(d);
	if(end!='Never') txt += ' (until '+end+')';
	$('#repeat_text').html(txt);
}
if(typeof $("#beg_date").val() != "undefined") {
	recalc_rep_text();
}
$('#repeat_period,#repeat_units,.repeat_dows_check,#series_end_date').change(recalc_rep_text);

function hide_show_other_calendar(userID)
{
	// Drop all icons, except the one selected
	$("IMG.other_calendar_view_state").fadeTo('slow',0.25);
	$(".other_calendar_" + userID + " IMG.other_calendar_view_state").fadeTo('slow',1);

	if($(".other_calendar_" + userID + " IMG.other_calendar_view_state").css('opacity') == 1) {
		console.log('The calendar for user: ' + userID + ' is already enabled.');
	} else {
		$(".left_column").fadeTo('fast',0.15);

		var date = $("#selected_date").val();
		var mode = $("#mode").val();

		var url = "events?ai_skin=full_page&multi=no&mode=" + mode + "&selected_date=" + date + "&show_calendar=" + userID;
		$(".left_column").load(url, function() {
			$(".left_column").fadeTo('fast',1);
			$(".hidden_hour").slideUp("fast");
			$(".hidden_event").css({"visibility":"hidden"});
		});
	}
}

function hide_show_multi_calendar(userID)
{
	if($(".other_calendar_" + userID + " IMG.other_calendar_view_state").css('opacity') == 1) {
		$(".other_calendar_" + userID + " IMG.other_calendar_view_state").fadeTo('slow',0.25);
		$(".left_column").fadeTo('fast',0.15);

		var url = "events?ai_skin=full_page&hide_calendar=" + userID;
		$(".left_column").load(url, function() {
			$(".left_column").fadeTo('fast',1);
		});
	} else {
		$(".other_calendar_" + userID + " IMG.other_calendar_view_state").fadeTo('slow',1);
		$(".left_column").fadeTo('fast',0.15);

		var url = "events?ai_skin=full_page&show_calendar=" + userID;
		$(".left_column").load(url, function() {
			$(".left_column").fadeTo('fast',1);
		});
	}
}

function add_other_calendar(d)
{
	user_information = d[0].split(" ");
	var userID = user_information[0];
	var first_name = user_information[1];
	var last_name = user_information[2];

	if(typeof first_name === "undefined") {
		user_information = d.split(" ");
		var userID = user_information[0];
		var first_name = user_information[1];
		var last_name = user_information[2];
	}

	var html = "";

	html += "<tr class='other_calendar_container other_calendar_" + userID + "'>";
	html += "<td width='12'><a href='javascript:void(0);' onclick='hide_show_other_calendar(" + userID + ");'><img src='images/te/sphere_zoom_16.gif' class='other_calendar_view_state'></a></td>";
	html += "<td>&nbsp;" + first_name + " " + last_name + "</td>";
	html += "<td width='12'><a href='javascript:void(0);' onclick='remove_other_calendar(" + userID + ");'><img src='images/te/drop.png'></a></td>";
	html += "</tr>";

	$(".other_calendar").append(html);
	$(".other_calendar_" + userID + " IMG.other_calendar_view_state").fadeTo('fast',0.25, function() { hide_show_other_calendar(userID); });

	$("#other_calendar_lookup").val('');
}
function remove_other_calendar(contact_id)
{
	$(".left_column").fadeTo('fast',0.15);
	$(".other_calendar_" + contact_id).hide('slow');
	var url = "events?ai_skin=full_page&delete_calendar=" + contact_id;
	$(".left_column").load(url, function() {
		$(".left_column").fadeTo('fast',1);
	});
}
function add_connected_contact(d)
{
	$(".empty_results_contacts").hide(0);
	user_information = d[0].split(" ");
	var userID = user_information[0];
	var first_name = user_information[1];
	var last_name = user_information[2];

	if(typeof first_name === "undefined") {
		user_information = d.split(" ");
		var userID = user_information[0];
		var first_name = user_information[1];
		var last_name = user_information[2];
	}

	var html = "";
	html += "<tr class='connected_contact_" + userID + "'>";
	html += "<td width='16'><img src='images/menu_tree/user_48.png' width='16'></td>";
	html += "<td>" + first_name + " " + last_name + "</td>";
	html += "<td width='16'><a href='lead_management?te_class=lead_management&te_mode=update&te_key=" + userID + "' target='_blank'><img src='images/te/sphere_zoom_16.gif'></a></td>";
	html += "<td width='16'><a href='javascript:void(0);' onclick='remove_connected_contact(" + userID + ");'><img src='images/te/drop.png'></a></td>";
	html += "</tr>";

	$(".connected_contacts").append(html);
	$("#connected_contacts_lookup").val('');
	$("#connected_contacts_string").val($("#connected_contacts_string").val() + "," + userID);
}
function remove_connected_contact(contact_id)
{
	var old_string = $("#connected_contacts_string").val();
	$(".connected_contact_" + contact_id).hide('slow');
	$("#connected_contacts_string").val(old_string.replace("," + contact_id,""));
}
function add_shared_event(d)
{
	$(".empty_results_users").hide(0);
	user_information = d[0].split(" ");
	var userID = user_information[0];
	var first_name = user_information[1];
	var last_name = user_information[2];

	if(typeof first_name === "undefined") {
		user_information = d.split(" ");
		var userID = user_information[0];
		var first_name = user_information[1];
		var last_name = user_information[2];
	}

	var html = "";
	html += "<tr class='shared_event_" + userID + "'>";
	html += "<td width='16'><img src='images/menu_tree/user_48.png' width='16'></td>";
	html += "<td>" + first_name + " " + last_name + "</td>";
	html += "<td width='16'><a href='javascript:void(0);' onclick='remove_shared_event(" + userID + ");'><img src='images/te/drop.png'></a></td>";
	html += "</tr>";

	$(".shared_events").append(html);
	$("#shared_event_lookup").val('');
	$("#shared_event_string").val($("#shared_event_string").val() + "," + userID);
}
function remove_shared_event(user_id)
{
	var old_string = $("#shared_event_string").val();
	$(".shared_event_" + user_id).hide('slow');
	$("#shared_event_string").val(old_string.replace("," + user_id,""));
}
/****** end css file: events.js ******/

/****** js file: events_dates.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/plugins/events/events_dates.js ******/
/****** last modified: 1477335686 (2016-10-24 14:01:26) ******/
//strtotime documentation, etc at http://locutus.io/php/datetime/strtotime/
function php_strtotime (text, now) {
	//  discuss at: http://locutus.io/php/strtotime/
	// original by: Caio Ariede (http://caioariede.com)
	// improved by: Kevin van Zonneveld (http://kvz.io)
	// improved by: Caio Ariede (http://caioariede.com)
	// improved by: A. Matas Quezada (http://amatiasq.com)
	// improved by: preuter
	// improved by: Brett Zamir (http://brett-zamir.me)
	// improved by: Mirko Faber
	//    input by: David
	// bugfixed by: Wagner B. Soares
	// bugfixed by: Artur Tchernychev
	// bugfixed by: Stephan Bsch-Plepelits (http://github.com/plepe)
	//      note 1: Examples all have a fixed timestamp to prevent
	//      note 1: tests to fail because of variable time(zones)
	//   example 1: strtotime('+1 day', 1129633200)
	//   returns 1: 1129719600
	//   example 2: strtotime('+1 week 2 days 4 hours 2 seconds', 1129633200)
	//   returns 2: 1130425202
	//   example 3: strtotime('last month', 1129633200)
	//   returns 3: 1127041200
	//   example 4: strtotime('2009-05-04 08:30:00 GMT')
	//   returns 4: 1241425800
	//   example 5: strtotime('2009-05-04 08:30:00+00')
	//   returns 5: 1241425800
	//   example 6: strtotime('2009-05-04 08:30:00+02:00')
	//   returns 6: 1241418600
	//   example 7: strtotime('2009-05-04T08:30:00Z')
	//   returns 7: 1241425800

	var parsed
	var match
	var today
	var year
	var date
	var days
	var ranges
	var len
	var times
	var regex
	var i
	var fail = false

	if (!text) {
		return fail
	}

	// Unecessary spaces
	text = text.replace(/^\s+|\s+$/g, '')
	.replace(/\s{2,}/g, ' ')
	.replace(/[\t\r\n]/g, '')
	.toLowerCase()

	// in contrast to php, js Date.parse function interprets:
	// dates given as yyyy-mm-dd as in timezone: UTC,
	// dates with "." or "-" as MDY instead of DMY
	// dates with two-digit years differently
	// etc...etc...
	// ...therefore we manually parse lots of common date formats
	var pattern = new RegExp([
	'^(\\d{1,4})',
					 '([\\-\\.\\/:])',
					 '(\\d{1,2})',
					 '([\\-\\.\\/:])',
					 '(\\d{1,4})',
					 '(?:\\s(\\d{1,2}):(\\d{2})?:?(\\d{2})?)?',
					 '(?:\\s([A-Z]+)?)?$'
	].join(''))
	match = text.match(pattern)

	if (match && match[2] === match[4]) {
		if (match[1] > 1901) {
			switch (match[2]) {
				case '-':
					// YYYY-M-D
					if (match[3] > 12 || match[5] > 31) {
						return fail
					}

					return new Date(match[1], parseInt(match[3], 10) - 1, match[5],
							    match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000
				case '.':
					// YYYY.M.D is not parsed by strtotime()
					return fail
				case '/':
					// YYYY/M/D
					if (match[3] > 12 || match[5] > 31) {
						return fail
					}

					return new Date(match[1], parseInt(match[3], 10) - 1, match[5],
							    match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000
			}
		} else if (match[5] > 1901) {
			switch (match[2]) {
				case '-':
					// D-M-YYYY
					if (match[3] > 12 || match[1] > 31) {
						return fail
					}

					return new Date(match[5], parseInt(match[3], 10) - 1, match[1],
							    match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000
				case '.':
					// D.M.YYYY
					if (match[3] > 12 || match[1] > 31) {
						return fail
					}

					return new Date(match[5], parseInt(match[3], 10) - 1, match[1],
							    match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000
				case '/':
					// M/D/YYYY
					if (match[1] > 12 || match[3] > 31) {
						return fail
					}

					return new Date(match[5], parseInt(match[1], 10) - 1, match[3],
							    match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000
			}
		} else {
			switch (match[2]) {
				case '-':
					// YY-M-D
					if (match[3] > 12 || match[5] > 31 || (match[1] < 70 && match[1] > 38)) {
						return fail
					}

					year = match[1] >= 0 && match[1] <= 38 ? +match[1] + 2000 : match[1]
					return new Date(year, parseInt(match[3], 10) - 1, match[5],
							    match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000
				case '.':
					// D.M.YY or H.MM.SS
					if (match[5] >= 70) {
						// D.M.YY
						if (match[3] > 12 || match[1] > 31) {
							return fail
						}

						return new Date(match[5], parseInt(match[3], 10) - 1, match[1],
								    match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000
					}
					if (match[5] < 60 && !match[6]) {
						// H.MM.SS
						if (match[1] > 23 || match[3] > 59) {
							return fail
						}

						today = new Date()
						return new Date(today.getFullYear(), today.getMonth(), today.getDate(),
								    match[1] || 0, match[3] || 0, match[5] || 0, match[9] || 0) / 1000
					}

					// invalid format, cannot be parsed
					return fail
				case '/':
					// M/D/YY
					if (match[1] > 12 || match[3] > 31 || (match[5] < 70 && match[5] > 38)) {
						return fail
					}

					year = match[5] >= 0 && match[5] <= 38 ? +match[5] + 2000 : match[5]
					return new Date(year, parseInt(match[1], 10) - 1, match[3],
							    match[6] || 0, match[7] || 0, match[8] || 0, match[9] || 0) / 1000
				case ':':
					// HH:MM:SS
					if (match[1] > 23 || match[3] > 59 || match[5] > 59) {
						return fail
					}

					today = new Date()
					return new Date(today.getFullYear(), today.getMonth(), today.getDate(),
							    match[1] || 0, match[3] || 0, match[5] || 0) / 1000
			}
		}
	}

	// other formats and "now" should be parsed by Date.parse()
	if (text === 'now') {
		return now === null || isNaN(now)
		? new Date().getTime() / 1000 | 0
		: now | 0
	}
	if (!isNaN(parsed = Date.parse(text))) {
		return parsed / 1000 | 0
	}
	// Browsers !== Chrome have problems parsing ISO 8601 date strings, as they do
	// not accept lower case characters, space, or shortened time zones.
	// Therefore, fix these problems and try again.
	// Examples:
	//   2015-04-15 20:33:59+02
	//   2015-04-15 20:33:59z
	//   2015-04-15t20:33:59+02:00
	pattern = new RegExp([
	'^([0-9]{4}-[0-9]{2}-[0-9]{2})',
				   '[ t]',
			    '([0-9]{2}:[0-9]{2}:[0-9]{2}(\\.[0-9]+)?)',
				   '([\\+-][0-9]{2}(:[0-9]{2})?|z)'
	].join(''))
	match = text.match(pattern)
	if (match) {
		// @todo: time zone information
		if (match[4] === 'z') {
			match[4] = 'Z'
		} else if (match[4].match(/^([\+-][0-9]{2})$/)) {
			match[4] = match[4] + ':00'
		}

		if (!isNaN(parsed = Date.parse(match[1] + 'T' + match[2] + match[4]))) {
			return parsed / 1000 | 0
		}
	}

	date = now ? new Date(now * 1000) : new Date()
	days = {
		'sun': 0,
		'mon': 1,
		'tue': 2,
		'wed': 3,
		'thu': 4,
		'fri': 5,
		'sat': 6
	}
	ranges = {
		'yea': 'FullYear',
		'mon': 'Month',
		'day': 'Date',
		'hou': 'Hours',
		'min': 'Minutes',
		'sec': 'Seconds'
	}

	function lastNext (type, range, modifier) {
		var diff
		var day = days[range]

		if (typeof day !== 'undefined') {
			diff = day - date.getDay()

			if (diff === 0) {
				diff = 7 * modifier
			} else if (diff > 0 && type === 'last') {
				diff -= 7
			} else if (diff < 0 && type === 'next') {
				diff += 7
			}

			date.setDate(date.getDate() + diff)
		}
	}

	function process (val) {
		// @todo: Reconcile this with regex using \s, taking into account
		// browser issues with split and regexes
		var splt = val.split(' ')
		var type = splt[0]
		var range = splt[1].substring(0, 3)
		var typeIsNumber = /\d+/.test(type)
		var ago = splt[2] === 'ago'
		var num = (type === 'last' ? -1 : 1) * (ago ? -1 : 1)

		if (typeIsNumber) {
			num *= parseInt(type, 10)
		}

		if (ranges.hasOwnProperty(range) && !splt[1].match(/^mon(day|\.)?$/i)) {
			return date['set' + ranges[range]](date['get' + ranges[range]]() + num)
		}

		if (range === 'wee') {
			return date.setDate(date.getDate() + (num * 7))
		}

		if (type === 'next' || type === 'last') {
			lastNext(type, range, num)
		} else if (!typeIsNumber) {
			return false
		}

		return true
	}

	times = '(years?|months?|weeks?|days?|hours?|minutes?|min|seconds?|sec' +
	'|sunday|sun\\.?|monday|mon\\.?|tuesday|tue\\.?|wednesday|wed\\.?' +
	'|thursday|thu\\.?|friday|fri\\.?|saturday|sat\\.?)'
	regex = '([+-]?\\d+\\s' + times + '|' + '(last|next)\\s' + times + ')(\\sago)?'

	match = text.match(new RegExp(regex, 'gi'))
	if (!match) {
		return fail
	}

	for (i = 0, len = match.length; i < len; i++) {
		if (!process(match[i])) {
			return fail
		}
	}

	return (date.getTime() / 1000)
}

//https://raw.githubusercontent.com/kvz/locutus/master/src/php/datetime/date.js
function php_date (format, timestamp) {
	//  discuss at: http://locutus.io/php/date/
	// original by: Carlos R. L. Rodrigues (http://www.jsfromhell.com)
	// original by: gettimeofday
	//    parts by: Peter-Paul Koch (http://www.quirksmode.org/js/beat.html)
	// improved by: Kevin van Zonneveld (http://kvz.io)
	// improved by: MeEtc (http://yass.meetcweb.com)
	// improved by: Brad Touesnard
	// improved by: Tim Wiel
	// improved by: Bryan Elliott
	// improved by: David Randall
	// improved by: Theriault (https://github.com/Theriault)
	// improved by: Theriault (https://github.com/Theriault)
	// improved by: Brett Zamir (http://brett-zamir.me)
	// improved by: Theriault (https://github.com/Theriault)
	// improved by: Thomas Beaucourt (http://www.webapp.fr)
	// improved by: JT
	// improved by: Theriault (https://github.com/Theriault)
	// improved by: Rafa Kukawski (http://blog.kukawski.pl)
	// improved by: Theriault (https://github.com/Theriault)
	//    input by: Brett Zamir (http://brett-zamir.me)
	//    input by: majak
	//    input by: Alex
	//    input by: Martin
	//    input by: Alex Wilson
	//    input by: Haravikk
	// bugfixed by: Kevin van Zonneveld (http://kvz.io)
	// bugfixed by: majak
	// bugfixed by: Kevin van Zonneveld (http://kvz.io)
	// bugfixed by: Brett Zamir (http://brett-zamir.me)
	// bugfixed by: omid (http://locutus.io/php/380:380#comment_137122)
	// bugfixed by: Chris (http://www.devotis.nl/)
	//      note 1: Uses global: locutus to store the default timezone
	//      note 1: Although the function potentially allows timezone info
	//      note 1: (see notes), it currently does not set
	//      note 1: per a timezone specified by date_default_timezone_set(). Implementers might use
	//      note 1: $locutus.currentTimezoneOffset and
	//      note 1: $locutus.currentTimezoneDST set by that function
	//      note 1: in order to adjust the dates in this function
	//      note 1: (or our other date functions!) accordingly
	//   example 1: date('H:m:s \\m \\i\\s \\m\\o\\n\\t\\h', 1062402400)
	//   returns 1: '07:09:40 m is month'
	//   example 2: date('F j, Y, g:i a', 1062462400)
	//   returns 2: 'September 2, 2003, 12:26 am'
	//   example 3: date('Y W o', 1062462400)
	//   returns 3: '2003 36 2003'
	//   example 4: var $x = date('Y m d', (new Date()).getTime() / 1000)
	//   example 4: $x = $x + ''
	//   example 4: var $result = $x.length // 2009 01 09
	//   returns 4: 10
	//   example 5: date('W', 1104534000)
	//   returns 5: '52'
	//   example 6: date('B t', 1104534000)
	//   returns 6: '999 31'
	//   example 7: date('W U', 1293750000.82); // 2010-12-31
	//   returns 7: '52 1293750000'
	//   example 8: date('W', 1293836400); // 2011-01-01
	//   returns 8: '52'
	//   example 9: date('W Y-m-d', 1293974054); // 2011-01-02
	//   returns 9: '52 2011-01-02'
	//        test: skip-1 skip-2 skip-5

	var jsdate, f
	// Keep this here (works, but for code commented-out below for file size reasons)
	// var tal= [];
	var txtWords = [
	'Sun', 'Mon', 'Tues', 'Wednes', 'Thurs', 'Fri', 'Satur',
	'January', 'February', 'March', 'April', 'May', 'June',
	'July', 'August', 'September', 'October', 'November', 'December'
	]
	// trailing backslash -> (dropped)
	// a backslash followed by any character (including backslash) -> the character
	// empty string -> empty string
	var formatChr = /\\?(.?)/gi
	var formatChrCb = function (t, s) {
		return f[t] ? f[t]() : s
	}
	var _pad = function (n, c) {
		n = String(n)
		while (n.length < c) {
			n = '0' + n
		}
		return n
	}
	f = {
		// Day
		d: function () {
			// Day of month w/leading 0; 01..31
			return _pad(f.j(), 2)
		},
		D: function () {
			// Shorthand day name; Mon...Sun
			return f.l()
			.slice(0, 3)
		},
		j: function () {
			// Day of month; 1..31
			return jsdate.getDate()
		},
		l: function () {
			// Full day name; Monday...Sunday
			return txtWords[f.w()] + 'day'
		},
		N: function () {
			// ISO-8601 day of week; 1[Mon]..7[Sun]
			return f.w() || 7
		},
		S: function () {
			// Ordinal suffix for day of month; st, nd, rd, th
			var j = f.j()
			var i = j % 10
			if (i <= 3 && parseInt((j % 100) / 10, 10) === 1) {
				i = 0
			}
			return ['st', 'nd', 'rd'][i - 1] || 'th'
		},
		w: function () {
			// Day of week; 0[Sun]..6[Sat]
			return jsdate.getDay()
		},
		z: function () {
			// Day of year; 0..365
			var a = new Date(f.Y(), f.n() - 1, f.j())
			var b = new Date(f.Y(), 0, 1)
			return Math.round((a - b) / 864e5)
		},

		// Week
		W: function () {
			// ISO-8601 week number
			var a = new Date(f.Y(), f.n() - 1, f.j() - f.N() + 3)
			var b = new Date(a.getFullYear(), 0, 4)
			return _pad(1 + Math.round((a - b) / 864e5 / 7), 2)
		},

		// Month
		F: function () {
			// Full month name; January...December
			return txtWords[6 + f.n()]
		},
		m: function () {
			// Month w/leading 0; 01...12
			return _pad(f.n(), 2)
		},
		M: function () {
			// Shorthand month name; Jan...Dec
			return f.F()
			.slice(0, 3)
		},
		n: function () {
			// Month; 1...12
			return jsdate.getMonth() + 1
		},
		t: function () {
			// Days in month; 28...31
			return (new Date(f.Y(), f.n(), 0))
			.getDate()
		},

		// Year
		L: function () {
			// Is leap year?; 0 or 1
			var j = f.Y()
			return j % 4 === 0 & j % 100 !== 0 | j % 400 === 0
		},
		o: function () {
			// ISO-8601 year
			var n = f.n()
			var W = f.W()
			var Y = f.Y()
			return Y + (n === 12 && W < 9 ? 1 : n === 1 && W > 9 ? -1 : 0)
		},
		Y: function () {
			// Full year; e.g. 1980...2010
			return jsdate.getFullYear()
		},
		y: function () {
			// Last two digits of year; 00...99
			return f.Y()
			.toString()
			.slice(-2)
		},

		// Time
		a: function () {
			// am or pm
			return jsdate.getHours() > 11 ? 'pm' : 'am'
		},
		A: function () {
			// AM or PM
			return f.a()
			.toUpperCase()
		},
		B: function () {
			// Swatch Internet time; 000..999
			var H = jsdate.getUTCHours() * 36e2
			// Hours
			var i = jsdate.getUTCMinutes() * 60
			// Minutes
			// Seconds
			var s = jsdate.getUTCSeconds()
			return _pad(Math.floor((H + i + s + 36e2) / 86.4) % 1e3, 3)
		},
		g: function () {
			// 12-Hours; 1..12
			return f.G() % 12 || 12
		},
		G: function () {
			// 24-Hours; 0..23
			return jsdate.getHours()
		},
		h: function () {
			// 12-Hours w/leading 0; 01..12
			return _pad(f.g(), 2)
		},
		H: function () {
			// 24-Hours w/leading 0; 00..23
			return _pad(f.G(), 2)
		},
		i: function () {
			// Minutes w/leading 0; 00..59
			return _pad(jsdate.getMinutes(), 2)
		},
		s: function () {
			// Seconds w/leading 0; 00..59
			return _pad(jsdate.getSeconds(), 2)
		},
		u: function () {
			// Microseconds; 000000-999000
			return _pad(jsdate.getMilliseconds() * 1000, 6)
		},

		// Timezone
		e: function () {
			// Timezone identifier; e.g. Atlantic/Azores, ...
			// The following works, but requires inclusion of the very large
			// timezone_abbreviations_list() function.
			/*              return that.date_default_timezone_get();
			 */
			var msg = 'Not supported (see source code of date() for timezone on how to add support)'
			throw new Error(msg)
		},
		I: function () {
			// DST observed?; 0 or 1
			// Compares Jan 1 minus Jan 1 UTC to Jul 1 minus Jul 1 UTC.
			// If they are not equal, then DST is observed.
			var a = new Date(f.Y(), 0)
			// Jan 1
			var c = Date.UTC(f.Y(), 0)
			// Jan 1 UTC
			var b = new Date(f.Y(), 6)
			// Jul 1
			// Jul 1 UTC
			var d = Date.UTC(f.Y(), 6)
			return ((a - c) !== (b - d)) ? 1 : 0
		},
		O: function () {
			// Difference to GMT in hour format; e.g. +0200
			var tzo = jsdate.getTimezoneOffset()
			var a = Math.abs(tzo)
			return (tzo > 0 ? '-' : '+') + _pad(Math.floor(a / 60) * 100 + a % 60, 4)
		},
		P: function () {
			// Difference to GMT w/colon; e.g. +02:00
			var O = f.O()
			return (O.substr(0, 3) + ':' + O.substr(3, 2))
		},
		T: function () {
			// The following works, but requires inclusion of the very
			// large timezone_abbreviations_list() function.
			/*              var abbr, i, os, _default;
			 *      if (!tal.length) {
			 *        tal = that.timezone_abbreviations_list();
		}
		if ($locutus && $locutus.default_timezone) {
			_default = $locutus.default_timezone;
			for (abbr in tal) {
				for (i = 0; i < tal[abbr].length; i++) {
					if (tal[abbr][i].timezone_id === _default) {
						return abbr.toUpperCase();
		}
		}
		}
		}
		for (abbr in tal) {
			for (i = 0; i < tal[abbr].length; i++) {
				os = -jsdate.getTimezoneOffset() * 60;
				if (tal[abbr][i].offset === os) {
					return abbr.toUpperCase();
		}
		}
		}
		*/
			return 'UTC'
		},
		Z: function () {
			// Timezone offset in seconds (-43200...50400)
			return -jsdate.getTimezoneOffset() * 60
		},

		// Full Date/Time
		c: function () {
			// ISO-8601 date.
			return 'Y-m-d\\TH:i:sP'.replace(formatChr, formatChrCb)
		},
		r: function () {
			// RFC 2822
			return 'D, d M Y H:i:s O'.replace(formatChr, formatChrCb)
		},
		U: function () {
			// Seconds since UNIX epoch
			return jsdate / 1000 | 0
		}
	}

	var _date = function (format, timestamp) {
		jsdate = (timestamp === undefined ? new Date() // Not provided
		: (timestamp instanceof Date) ? new Date(timestamp) // JS Date()
		: new Date(timestamp * 1000) // UNIX timestamp (auto-convert to int)
		)
		return format.replace(formatChr, formatChrCb)
	}

	return _date(format, timestamp)
}

/****** end css file: events_dates.js ******/

/****** js file: events.ajax.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/plugins/events/events.ajax.js ******/
/****** last modified: 1381192575 (2013-10-07 19:36:15) ******/
$(function() {
	$(".drop_arrow_indicator").css("cursor", "pointer").attr("title", "Click to View");
	$(".drop_arrow_indicator_with_div").css("cursor", "pointer").attr("title", "Click to View");

	$("table.event_agenda_draw_event_block, table.event_at_a_glance_event_block").hover(function( e ) {
		$(".te_view_button", this).show();
		$(".te_edit_button", this).show();
		$(".te_copy_button", this).show();
		$(".te_delete_button", this).show();
	}, function( e ) {
		$(".te_view_button", this).hide();
		$(".te_edit_button", this).hide();
		$(".te_copy_button", this).hide();
		$(".te_delete_button", this).hide();
	});

	// Hide them initially, if not already hidden
	$(".event_agenda_draw_event_block .te_view_button", this).hide();
	$(".event_agenda_draw_event_block .te_edit_button", this).hide();
	$(".event_agenda_draw_event_block .te_copy_button", this).hide();
	$(".event_agenda_draw_event_block .te_delete_button", this).hide();
	$(".event_at_a_glance_event_block .te_view_button", this).hide();
	$(".event_at_a_glance_event_block .te_edit_button", this).hide();
	$(".event_at_a_glance_event_block .te_copy_button", this).hide();
	$(".event_at_a_glance_event_block .te_delete_button", this).hide();
});

/****** end css file: events.ajax.js ******/

/****** js file: jquery.sidr.min.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/core/js/sidr/jquery.sidr.min.js ******/
/****** last modified: 1419010587 (2014-12-19 11:36:27) ******/
/*! Sidr - v1.2.1 - 2013-11-06
 * https://github.com/artberri/sidr
 * Copyright (c) 2013 Alberto Varela; Licensed MIT */
(function(e){var t=!1,i=!1,n={isUrl:function(e){var t=RegExp("^(https?:\\/\\/)?((([a-z\\d]([a-z\\d-]*[a-z\\d])*)\\.)+[a-z]{2,}|((\\d{1,3}\\.){3}\\d{1,3}))(\\:\\d+)?(\\/[-a-z\\d%_.~+]*)*(\\?[;&a-z\\d%_.~+=-]*)?(\\#[-a-z\\d_]*)?$","i");return t.test(e)?!0:!1},loadContent:function(e,t){e.html(t)},addPrefix:function(e){var t=e.attr("id"),i=e.attr("class");"string"==typeof t&&""!==t&&e.attr("id",t.replace(/([A-Za-z0-9_.\-]+)/g,"sidr-id-$1")),"string"==typeof i&&""!==i&&"sidr-inner"!==i&&e.attr("class",i.replace(/([A-Za-z0-9_.\-]+)/g,"sidr-class-$1")),e.removeAttr("style")},execute:function(n,s,a){"function"==typeof s?(a=s,s="sidr"):s||(s="sidr");var r,d,l,c=e("#"+s),u=e(c.data("body")),f=e("html"),p=c.outerWidth(!0),g=c.data("speed"),h=c.data("side"),m=c.data("displace"),v=c.data("onOpen"),y=c.data("onClose"),x="sidr"===s?"sidr-open":"sidr-open "+s+"-open";if("open"===n||"toggle"===n&&!c.is(":visible")){if(c.is(":visible")||t)return;if(i!==!1)return o.close(i,function(){o.open(s)}),void 0;t=!0,"left"===h?(r={left:p+"px"},d={left:"0px"}):(r={right:p+"px"},d={right:"0px"}),u.is("body")&&(l=f.scrollTop(),f.css("overflow-x","hidden").scrollTop(l)),m?u.addClass("sidr-animating").css({width:u.width(),position:"absolute"}).animate(r,g,function(){e(this).addClass(x)}):setTimeout(function(){e(this).addClass(x)},g),c.css("display","block").animate(d,g,function(){t=!1,i=s,"function"==typeof a&&a(s),u.removeClass("sidr-animating")}),v()}else{if(!c.is(":visible")||t)return;t=!0,"left"===h?(r={left:0},d={left:"-"+p+"px"}):(r={right:0},d={right:"-"+p+"px"}),u.is("body")&&(l=f.scrollTop(),f.removeAttr("style").scrollTop(l)),u.addClass("sidr-animating").animate(r,g).removeClass(x),c.animate(d,g,function(){c.removeAttr("style").hide(),u.removeAttr("style"),e("html").removeAttr("style"),t=!1,i=!1,"function"==typeof a&&a(s),u.removeClass("sidr-animating")}),y()}}},o={open:function(e,t){n.execute("open",e,t)},close:function(e,t){n.execute("close",e,t)},toggle:function(e,t){n.execute("toggle",e,t)},toogle:function(e,t){n.execute("toggle",e,t)}};e.sidr=function(t){return o[t]?o[t].apply(this,Array.prototype.slice.call(arguments,1)):"function"!=typeof t&&"string"!=typeof t&&t?(e.error("Method "+t+" does not exist on jQuery.sidr"),void 0):o.toggle.apply(this,arguments)},e.fn.sidr=function(t){var i=e.extend({name:"sidr",speed:200,side:"left",source:null,renaming:!0,body:"body",displace:!0,onOpen:function(){},onClose:function(){}},t),s=i.name,a=e("#"+s);if(0===a.length&&(a=e("<div />").attr("id",s).appendTo(e("body"))),a.addClass("sidr").addClass(i.side).data({speed:i.speed,side:i.side,body:i.body,displace:i.displace,onOpen:i.onOpen,onClose:i.onClose}),"function"==typeof i.source){var r=i.source(s);n.loadContent(a,r)}else if("string"==typeof i.source&&n.isUrl(i.source))e.get(i.source,function(e){n.loadContent(a,e)});else if("string"==typeof i.source){var d="",l=i.source.split(",");if(e.each(l,function(t,i){d+='<div class="sidr-inner">'+e(i).html()+"</div>"}),i.renaming){var c=e("<div />").html(d);c.find("*").each(function(t,i){var o=e(i);n.addPrefix(o)}),d=c.html()}n.loadContent(a,d)}else null!==i.source&&e.error("Invalid Sidr Source");return this.each(function(){var t=e(this),i=t.data("sidr");i||(t.data("sidr",s),"ontouchstart"in document.documentElement?(t.bind("touchstart",function(e){e.originalEvent.touches[0],this.touched=e.timeStamp}),t.bind("touchend",function(e){var t=Math.abs(e.timeStamp-this.touched);200>t&&(e.preventDefault(),o.toggle(s))})):t.click(function(e){e.preventDefault(),o.toggle(s)}))})}})(jQuery);
/****** end css file: jquery.sidr.min.js ******/

/****** js file: jquery.scrollspy.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/js/jquery.scrollspy.js ******/
/****** last modified: 1360217430 (2013-02-07 00:10:30) ******/
/*!
 * jQuery Scrollspy Plugin
 * Author: @sxalexander
 * Licensed under the MIT license
 */

;
(function($, window, document, undefined) {
	$.fn.extend({
		scrollspy: function(options) {
			var defaults = {
				min: 0,
				max: 0,
				mode: 'vertical',
				buffer: 0,
				container: window,
				onEnter: options.onEnter || [],
				onLeave: options.onLeave || [],
				onTick: options.onTick ||  []
			};

			var options = $.extend({}, defaults, options);

			return this.each(function(i) {
				var element = this;
				var o = options;
				var $container = $(o.container);
				var mode = o.mode;
				var buffer = o.buffer;
				var enters = leaves = 0;
				var inside = false;

				/* add listener to container */
				$container.bind('scroll', function(e) {
					var position = {
						top: $(this).scrollTop(),
						left: $(this).scrollLeft()
					};

					var xy = (mode == 'vertical') ? position.top + buffer : position.left + buffer,
						max = o.max,
						min = o.min;

					/* fix max */
					if ($.isFunction(o.max)) {
						max = o.max();
					}

					/* fix max */
					if ($.isFunction(o.min)) {
						min = o.min();
					}

					if (max == 0) {
						max = (mode == 'vertical') ? $container.height() : $container.outerWidth() + $(element).outerWidth();
					}

					/* if we have reached the minimum bound but are below the max ... */
					if (xy >= o.min && xy <= max) {
						/* trigger enter event */
						if (!inside) {
							inside = true;
							enters++;

							/* fire enter event */
							$(element).trigger('scrollEnter', {
								position : position
							});

							if ($.isFunction(o.onEnter)) {
								o.onEnter(element, position);
							}
						}

						/* triger tick event */
						$(element).trigger('scrollTick', {
							position: position,
							inside: inside,
							enters: enters,
							leaves: leaves
						});

						if ($.isFunction(o.onTick)) {
							o.onTick(element, position, inside, enters, leaves);
						}
					} else {
						if (inside) {
							inside = false;
							leaves++;

							/* trigger leave event */
							$(element).trigger('scrollLeave', {
								position: position,
								leaves: leaves
							});

							if ($.isFunction(o.onLeave)) {
								o.onLeave(element, position);
							}
						}
					}
				});
			});
		}
	});
})(jQuery, window);
/****** end css file: jquery.scrollspy.js ******/

/****** js file: top_bar.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/plugins/top_bar/top_bar.js ******/
/****** last modified: 1441393170 (2015-09-04 13:59:30) ******/
var ai_top_bar =
{
	init : function()
	{
		$("#ai_top_bar").prependTo("body");

		if ( $.fn.scrollspy != null )
		{
			var tb_bot = $("#ai_top_bar").outerHeight();
			$("#ai_top_bar").scrollspy({
				  'min': 1
				, 'max' : 1000000
				, 'onEnter': function()
				{
					$("#ai_top_bar").addClass("pinned");
				}
				, 'onLeave': function()
				{
					$("#ai_top_bar").removeClass("pinned");
				}
			});
		}

		$("#ai_top_bar a").on("click", function( e )
		{
			var $panels = $(this).parents(".ai_top_bar_panels");
			if ( $panels.length )
			{
				$panels.fadeOut(200);
				return;
			}

			var $ul = $(this).parents("ul.nested_level");
			if ( $ul.length )
			{
				$ul.fadeOut(200);
				return;
			}
		})

		// Fix menu clicks that disable entire menus (since some are AJAX clicks that do not leave the page)
		$("span.nohref", "#ai_top_bar").on("mouseenter", function( e ) {
			//$(".ai_top_bar_panels, ul.nested_level", "#ai_top_bar").prop("style", false);
			$(".ai_top_bar_panels, ul.nested_level", "#ai_top_bar").css("display", "");
		});

		/*$("#ai_top_bar_toggler").on("click", function( e ) {
			e.preventDefault();
			$("#ai_top_bar .sectioned_content").slideToggle();
		});*/
		$("#ai_top_bar_toggler").sidr({"name":"sidr-left", "source":"#ai_top_bar .sectioned_content.left_content"});
		$("#ai_top_bar_toggler_user").sidr({"name":"sidr-right", "source":"#ai_top_bar .sectioned_content.right_content", "side":"right"});
	}
};

$(document).ready(function( event )
{
	ai_top_bar.init();
});
/****** end css file: top_bar.js ******/

/****** js file: translation_manager.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/plugins/translator/translation_manager.js ******/
/****** last modified: 1477672763 (2016-10-28 11:39:23) ******/
var translation_manager = {
	initd : false
	,_highlight: false
	, init : function() {
	}
	, delayed_init : function() {
		if ( !this.initd ) {
			$("#translation_manager_translation").blur(function( e ) {
				$("#translation_manager_focus_input").focus();
			}).keydown(function( e ) {
				if ( e.ctrlKey && e.which == 13 ) {
					var $frm_obj = $("#translation_manager_form")
					translation_manager.update($frm_obj);
				} else if ( e.ctrlKey && e.which == 37 ) {
					$(this).blur();
				}
			});

			$("#translation_manager_focus_input").keydown(function( e ) {
				var $active_choice = $(".tm_phrase_choice_active");
				if ( $active_choice.length > 0 ) {
					if ( e.which == 38 ) {
						var $prev_choice = $active_choice.prevAll(".tm_phrase_choice:visible");
						console.log($prev_choice);
						if ( $prev_choice.length > 0 ) {
							translation_manager.choose($prev_choice[0]);
						}
					} else if ( e.which == 40 ) {
						var $next_choice = $active_choice.nextAll(".tm_phrase_choice:visible");
						console.log($next_choice);
						if ( $next_choice.length > 0 ) {
							translation_manager.choose($next_choice[0]);
						}
					} else if ( e.which == 39 || e.which == 13 ) {
						e.preventDefault();
						$("#translation_manager_translation").focus();
					}
				}
			});

			$("#modal-overlay").remove();
			$("#loadingDiv").remove();
			this.initd = true;
		}
	}
	, select : function( select_obj ) {
		this.delayed_init();

		var lang = $(select_obj).val();
		$("#translation_manager_lang_input").val(lang);

		var lang_name = $("#tm_lang_option_" + lang).html();
		$("#translation_manager_step4_title").html(lang_name);

		$("#translation_manager_original_phrase").html("");
		$("#translation_manager_translation").attr("placeholder", "").val("");
		$("#translation_manager_key").val("");

		$(".tm_phrase_choice").show();
		$(".tm_phrase_choice.not_in_" + lang).hide();
	}
	, choose : function( elem ) {
		this.delayed_init();

		$(".tm_phrase_choice_active").removeClass("tm_phrase_choice_active");
		$(elem).addClass("tm_phrase_choice_active");

		var pos = $(elem).position().top;
		if ( pos < 0 || pos > 350 ) {
			var pos_of_0 = $(".tm_phrase_choice_0").position().top;
			var new_top = pos_of_0 * -1;
			if ( pos < 0 ) {
				new_top -= 200;
			} else if ( pos > 350 ) {
				new_top += 200;
			}
			$("#translation_manager_phrase_list").animate({scrollTop: new_top}, 200);
		}

		var key = $(elem).attr("data-key");
		$("#translation_manager_key").val(key);

		var full_phrase = $(elem).html();
		$("#translation_manager_original_phrase").html(full_phrase);

		var lang = $("#translation_manager_lang_input").val();
		$("#translation_manager_translation").attr("placeholder", "Loading...").val("").blur();
		$.post("translation_manager.php?cmd=choose", "key=" + this.u(key) + "&lang=" + this.u(lang), function( data, success, xhr ) {
			switch ( data.status ) {
				case "0":
					translation_manager.error(data.message);
					break;
				case "1":
					$("#translation_manager_translation").val(data.message).blur();
					break;
				case "2":
					$("#translation_manager_translation").attr("placeholder", "No Data").val("").blur();
					break;
				default:
					translation_manager.error(data);
					break;
			}
		}, "json");
	}
	, update : function( frm_obj ) {
		this.delayed_init();

		var params = $(frm_obj).serialize();
		    params += "&phrase=" + this.u($("#translation_manager_translation").val());
		$.post("translation_manager.php?cmd=update", params, function( data, success, xhr ) {
			if ( data.status ) {
				switch ( data.status ) {
					case "1":
						$("#translation_manager_saved p").show();
						$("#translation_manager_translation").blur();
						setTimeout('$("#translation_manager_saved p").fadeOut();', 2000);
						break;
					default:
						translation_manager.error(data.message);
						break;
				}
			} else {
				translation_manager.error(data);
			}
		}, "json");
		return false;
	}

	, u : function( string ) {
		return encodeURIComponent(string);
	}

	, error : function( string ) {
		string += ' &nbsp; <a href="javascript:void(0)" onclick="translation_manager.dismiss();">Dismiss</a>';
		$("#translation_manager_error").html(string);
	}
	, dismiss : function() {
		$("#translation_manager_error").html("");
	}

	/**
	 *
	 */
	,_fix_input_highlight : function($elem)
	{
		$.each( utility2.get_element_attributes($elem), function ( property, attribute ) {
			if(/<[a-z][\s\S]*>/i.test(attribute) // has html tag
				&& attribute.indexOf('translate_highlight') != -1)
			{
				$($elem).prop(property, utility2.remove_html_tags_from_string(attribute));
				$($elem).addClass('translate_highlight_input');
			}
		});
	}
	/**
	 *
	 */
	,run_translate_highlight : function()
	{
		var that = this;

		if(!this._highlight){
			// when jonbox finish loading run this method everytime
			$(document).on("jonbox-ajaxStop", function( e ) { that.run_translate_highlight(); });
		}

		$.each($('input'),function(index,value) {
			that._fix_input_highlight($(this));
		});

		$.each($('option'),function(index,value)
		{
			if( $(this).html().indexOf("\u200C") > 0 ) // because option element cannot have html an visible code is existed to find
			{
				$(this).addClass('translate_highlight');
			}
		});


		this._highlight = true;
	}
};

$(document).ready(function( event ) {
	translation_manager.init();
});

/****** end css file: translation_manager.js ******/

/****** js file: match_height.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/js/match_height.js ******/
/****** last modified: 1467821330 (2016-07-06 11:08:50) ******/
/**
* jquery.matchHeight.js master
* http://brm.io/jquery-match-height/
* License: MIT
*/

;(function($) {
    /*
    *  internal
    */

    var _previousResizeWidth = -1,
        _updateTimeout = -1;

    /*
    *  _parse
    *  value parse utility function
    */

    var _parse = function(value) {
        // parse value and convert NaN to 0
        return parseFloat(value) || 0;
    };

    /*
    *  _rows
    *  utility function returns array of jQuery selections representing each row
    *  (as displayed after float wrapping applied by browser)
    */

    var _rows = function(elements) {
        var tolerance = 1,
            $elements = $(elements),
            lastTop = null,
            rows = [];

        // group elements by their top position
        $elements.each(function(){
            var $that = $(this),
                top = $that.offset().top - _parse($that.css('margin-top')),
                lastRow = rows.length > 0 ? rows[rows.length - 1] : null;

            if (lastRow === null) {
                // first item on the row, so just push it
                rows.push($that);
            } else {
                // if the row top is the same, add to the row group
                if (Math.floor(Math.abs(lastTop - top)) <= tolerance) {
                    rows[rows.length - 1] = lastRow.add($that);
                } else {
                    // otherwise start a new row group
                    rows.push($that);
                }
            }

            // keep track of the last row top
            lastTop = top;
        });

        return rows;
    };

    /*
    *  _parseOptions
    *  handle plugin options
    */

    var _parseOptions = function(options) {
        var opts = {
            byRow: true,
            property: 'height',
            target: null,
            remove: false
        };

        if (typeof options === 'object') {
            return $.extend(opts, options);
        }

        if (typeof options === 'boolean') {
            opts.byRow = options;
        } else if (options === 'remove') {
            opts.remove = true;
        }

        return opts;
    };

    /*
    *  matchHeight
    *  plugin definition
    */

    var matchHeight = $.fn.matchHeight = function(options) {
        var opts = _parseOptions(options);

        // handle remove
        if (opts.remove) {
            var that = this;

            // remove fixed height from all selected elements
            this.css(opts.property, '');

            // remove selected elements from all groups
            $.each(matchHeight._groups, function(key, group) {
                group.elements = group.elements.not(that);
            });

            // TODO: cleanup empty groups

            return this;
        }

        if (this.length <= 1 && !opts.target) {
            return this;
        }

        // keep track of this group so we can re-apply later on load and resize events
        matchHeight._groups.push({
            elements: this,
            options: opts
        });

        // match each element's height to the tallest element in the selection
        matchHeight._apply(this, opts);

        return this;
    };

    /*
    *  plugin global options
    */

    matchHeight._groups = [];
    matchHeight._throttle = 80;
    matchHeight._maintainScroll = false;
    matchHeight._beforeUpdate = null;
    matchHeight._afterUpdate = null;
    matchHeight._rows = _rows;

    /*
    *  matchHeight._apply
    *  apply matchHeight to given elements
    */

    matchHeight._apply = function(elements, options) {
        var opts = _parseOptions(options),
            $elements = $(elements),
            rows = [$elements];

        // take note of scroll position
        var scrollTop = $(window).scrollTop(),
            htmlHeight = $('html').outerHeight(true);

        // get hidden parents
        var $hiddenParents = $elements.parents().filter(':hidden');

        // cache the original inline style
        $hiddenParents.each(function() {
            var $that = $(this);
            $that.data('style-cache', $that.attr('style'));
        });

        // temporarily must force hidden parents visible
        $hiddenParents.css('display', 'block');

        // get rows if using byRow, otherwise assume one row
        if (opts.byRow && !opts.target) {

            // must first force an arbitrary equal height so floating elements break evenly
            $elements.each(function() {
                var $that = $(this),
                    display = $that.css('display');

                // temporarily force a usable display value
                if (display !== 'inline-block' && display !== 'inline-flex') {
                    display = 'block';
                }

                // cache the original inline style
                $that.data('style-cache', $that.attr('style'));

                $that.css({
                    'display': display,
                    'padding-top': '0',
                    'padding-bottom': '0',
                    'margin-top': '0',
                    'margin-bottom': '0',
                    'border-top-width': '0',
                    'border-bottom-width': '0',
                    'height': '100px'
                });
            });

            // get the array of rows (based on element top position)
            rows = _rows($elements);

            // revert original inline styles
            $elements.each(function() {
                var $that = $(this);
                $that.attr('style', $that.data('style-cache') || '');
            });
        }

        $.each(rows, function(key, row) {
            var $row = $(row),
                targetHeight = 0;

            if (!opts.target) {
                // skip apply to rows with only one item
                if (opts.byRow && $row.length <= 1) {
                    $row.css(opts.property, '');
                    return;
                }

                // iterate the row and find the max height
                $row.each(function(){
                    var $that = $(this),
                        display = $that.css('display');

                    // temporarily force a usable display value
                    if (display !== 'inline-block' && display !== 'inline-flex') {
                        display = 'block';
                    }

                    // ensure we get the correct actual height (and not a previously set height value)
                    var css = { 'display': display };
                    css[opts.property] = '';
                    $that.css(css);

                    // find the max height (including padding, but not margin)
                    if ($that.outerHeight(false) > targetHeight) {
                        targetHeight = $that.outerHeight(false);
                    }

                    // revert display block
                    $that.css('display', '');
                });
            } else {
                // if target set, use the height of the target element
                targetHeight = opts.target.outerHeight(false);
            }

            // iterate the row and apply the height to all elements
            $row.each(function(){
                var $that = $(this),
                    verticalPadding = 0;

                // don't apply to a target
                if (opts.target && $that.is(opts.target)) {
                    return;
                }

                // handle padding and border correctly (required when not using border-box)
                if ($that.css('box-sizing') !== 'border-box') {
                    verticalPadding += _parse($that.css('border-top-width')) + _parse($that.css('border-bottom-width'));
                    verticalPadding += _parse($that.css('padding-top')) + _parse($that.css('padding-bottom'));
                }

                // set the height (accounting for padding and border)
                $that.css(opts.property, (targetHeight - verticalPadding) + 'px');
            });
        });

        // revert hidden parents
        $hiddenParents.each(function() {
            var $that = $(this);
            $that.attr('style', $that.data('style-cache') || null);
        });

        // restore scroll position if enabled
        if (matchHeight._maintainScroll) {
            $(window).scrollTop((scrollTop / htmlHeight) * $('html').outerHeight(true));
        }

        return this;
    };

    /*
    *  matchHeight._applyDataApi
    *  applies matchHeight to all elements with a data-match-height attribute
    */

    matchHeight._applyDataApi = function() {
        var groups = {};

        // generate groups by their groupId set by elements using data-match-height
        $('[data-match-height], [data-mh]').each(function() {
            var $this = $(this),
                groupId = $this.attr('data-mh') || $this.attr('data-match-height');

            if (groupId in groups) {
                groups[groupId] = groups[groupId].add($this);
            } else {
                groups[groupId] = $this;
            }
        });

        // apply matchHeight to each group
        $.each(groups, function() {
            this.matchHeight(true);
        });
    };

    /*
    *  matchHeight._update
    *  updates matchHeight on all current groups with their correct options
    */

    var _update = function(event) {
        if (matchHeight._beforeUpdate) {
            matchHeight._beforeUpdate(event, matchHeight._groups);
        }

        $.each(matchHeight._groups, function() {
            matchHeight._apply(this.elements, this.options);
        });

        if (matchHeight._afterUpdate) {
            matchHeight._afterUpdate(event, matchHeight._groups);
        }
    };

    matchHeight._update = function(throttle, event) {
        // prevent update if fired from a resize event
        // where the viewport width hasn't actually changed
        // fixes an event looping bug in IE8
        if (event && event.type === 'resize') {
            var windowWidth = $(window).width();
            if (windowWidth === _previousResizeWidth) {
                return;
            }
            _previousResizeWidth = windowWidth;
        }

        // throttle updates
        if (!throttle) {
            _update(event);
        } else if (_updateTimeout === -1) {
            _updateTimeout = setTimeout(function() {
                _update(event);
                _updateTimeout = -1;
            }, matchHeight._throttle);
        }
    };

    /*
    *  bind events
    */

    // apply on DOM ready event
    $(matchHeight._applyDataApi);

    // update heights on load and resize events
    $(window).bind('load', function(event) {
        matchHeight._update(false, event);
    });

    // throttled update heights on resize events
    $(window).bind('resize orientationchange', function(event) {
        matchHeight._update(true, event);
    });

})(jQuery);

/****** end css file: match_height.js ******/

/****** js file: ai_match_height.js ******/
/****** full path: /home/aicore/public_html/backbone/includes/js/ai_match_height.js ******/
/****** last modified: 1468427004 (2016-07-13 11:23:24) ******/
/**
 *  Note: This depends on match_height.js
 *    
 *  usage:
 *  add class ai_match_height to containers to be matched
 *  add attribute match-group="group1"
 *  
 *  all containers with the same group will be grouped together    
*/

$(document).ready(function() {
	
	// apply matchHeight to each container with class 'ai_match_height'
	
	// build list of match-height groups
	var match_groups = [];
	$('.ai_match_height').each(function() {
		group = $(this).attr('match-group'); 
		if(group!=null && group!='' && $.inArray(group, match_groups)==-1 ) match_groups.push(group); 
	});
		
  //loop through the group array and run matchHeight on them
  $.each(match_groups,function(i,group){
		ops = {byRow:false};
		$('.ai_match_height[match-group="'+group+'"]').matchHeight(ops);
	});


});

/****** end css file: ai_match_height.js ******/
